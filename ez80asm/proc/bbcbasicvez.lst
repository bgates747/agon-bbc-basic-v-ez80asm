PC     Output      Line
040000             0001   ; --- Begin mos_api.inc ---
040000             0002   ;
040000             0003   ; Title:	AGON MOS - API for user projects
040000             0004   ; Author:	Dean Belfield
040000             0005   ; Created:	03/08/2022
040000             0006   ; Last Updated:	11/11/2023
040000             0007   ;
040000             0008   ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040000             0009   ;
040000             0010   ; Modinfo:
040000             0011   ; 05/08/2022:	Added mos_feof
040000             0012   ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0013   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0014   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0015   ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0016   ; 13/10/2022:	Added mos_oscli
040000             0017   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0018   ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0019   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0020   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0021   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0022   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0023   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0024   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0025   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0026   ; 19/05/2023:	Added sysvar_scrMode
040000             0027   ; 05/06/2023:	Added sysvar_rtcEnable
040000             0028   ; 03/08/2023:	Added mos_setkbvector
040000             0029   ; 10/08/2023:	Added mos_getkbmap
040000             0030   ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0031   ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040000             0032   ;
040000             0033   ; VDP control (VDU 23, 0, n)
040000             0034   ;
040000             0035   vdp_gp:			EQU 	80h
040000             0036   vdp_keycode:		EQU 	81h
040000             0037   vdp_cursor:		EQU	82h
040000             0038   vdp_scrchar:		EQU	83h
040000             0039   vdp_scrpixel:		EQU	84h
040000             0040   vdp_audio:		EQU	85h
040000             0041   vdp_mode:		EQU	86h
040000             0042   vdp_rtc:		EQU	87h
040000             0043   vdp_keystate:		EQU	88h
040000             0044   vdp_logicalcoords:	EQU	C0h
040000             0045   vdp_terminalmode:	EQU	FFh
040000             0046   
040000             0047   ; MOS high level functions
040000             0048   ;
040000             0049   mos_getkey:		EQU	00h
040000             0050   mos_load:		EQU	01h
040000             0051   mos_save:		EQU	02h
040000             0052   mos_cd:			EQU	03h
040000             0053   mos_dir:		EQU	04h
040000             0054   mos_del:		EQU	05h
040000             0055   mos_ren:		EQU	06h
040000             0056   mos_mkdir:		EQU	07h
040000             0057   mos_sysvars:		EQU	08h
040000             0058   mos_editline:		EQU	09h
040000             0059   mos_fopen:		EQU	0Ah
040000             0060   mos_fclose:		EQU	0Bh
040000             0061   mos_fgetc:		EQU	0Ch
040000             0062   mos_fputc:		EQU	0Dh
040000             0063   mos_feof:		EQU	0Eh
040000             0064   mos_getError:		EQU	0Fh
040000             0065   mos_oscli:		EQU	10h
040000             0066   mos_copy:		EQU	11h
040000             0067   mos_getrtc:		EQU	12h
040000             0068   mos_setrtc:		EQU	13h
040000             0069   mos_setintvector:	EQU	14h
040000             0070   mos_uopen:		EQU	15h
040000             0071   mos_uclose:		EQU	16h
040000             0072   mos_ugetc:		EQU	17h
040000             0073   mos_uputc:		EQU 	18h
040000             0074   mos_getfil:		EQU	19h
040000             0075   mos_fread:		EQU	1Ah
040000             0076   mos_fwrite:		EQU	1Bh
040000             0077   mos_flseek:		EQU	1Ch
040000             0078   mos_setkbvector:	EQU	1Dh
040000             0079   mos_getkbmap:		EQU	1Eh
040000             0080   mos_i2c_open:		EQU	1Fh
040000             0081   mos_i2c_close:		EQU	20h
040000             0082   mos_i2c_write:		EQU	21h
040000             0083   mos_i2c_read:		EQU	22h
040000             0084   
040000             0085   
040000             0086   ; FatFS file access functions
040000             0087   ;
040000             0088   ffs_fopen:		EQU	80h
040000             0089   ffs_fclose:		EQU	81h
040000             0090   ffs_fread:		EQU	82h
040000             0091   ffs_fwrite:		EQU	83h
040000             0092   ffs_flseek:		EQU	84h
040000             0093   ffs_ftruncate:		EQU	85h
040000             0094   ffs_fsync:		EQU	86h
040000             0095   ffs_fforward:		EQU	87h
040000             0096   ffs_fexpand:		EQU	88h
040000             0097   ffs_fgets:		EQU	89h
040000             0098   ffs_fputc:		EQU	8Ah
040000             0099   ffs_fputs:		EQU	8Bh
040000             0100   ffs_fprintf:		EQU	8Ch
040000             0101   ffs_ftell:		EQU	8Dh
040000             0102   ffs_feof:		EQU	8Eh
040000             0103   ffs_fsize:		EQU	8Fh
040000             0104   ffs_ferror:		EQU	90h
040000             0105   
040000             0106   ; FatFS directory access functions
040000             0107   ;
040000             0108   ffs_dopen:		EQU	91h
040000             0109   ffs_dclose:		EQU	92h
040000             0110   ffs_dread:		EQU	93h
040000             0111   ffs_dfindfirst:		EQU	94h
040000             0112   ffs_dfindnext:		EQU	95h
040000             0113   
040000             0114   ; FatFS file and directory management functions
040000             0115   ;
040000             0116   ffs_stat:		EQU	96h
040000             0117   ffs_unlink:		EQU	97h
040000             0118   ffs_rename:		EQU	98h
040000             0119   ffs_chmod:		EQU	99h
040000             0120   ffs_utime:		EQU	9Ah
040000             0121   ffs_mkdir:		EQU	9Bh
040000             0122   ffs_chdir:		EQU	9Ch
040000             0123   ffs_chdrive:		EQU	9Dh
040000             0124   ffs_getcwd:		EQU	9Eh
040000             0125   
040000             0126   ; FatFS volume management and system configuration functions
040000             0127   ;
040000             0128   ffs_mount:		EQU	9Fh
040000             0129   ffs_mkfs:		EQU	A0h
040000             0130   ffs_fdisk:		EQU	A1h
040000             0131   ffs_getfree:		EQU	A2h
040000             0132   ffs_getlabel:		EQU	A3h
040000             0133   ffs_setlabel:		EQU	A4h
040000             0134   ffs_setcp:		EQU	A5h
040000             0135   
040000             0136   ; File access modes
040000             0137   ;
040000             0138   fa_read:		EQU	01h
040000             0139   fa_write:		EQU	02h
040000             0140   fa_open_existing:	EQU	00h
040000             0141   fa_create_new:		EQU	04h
040000             0142   fa_create_always:	EQU	08h
040000             0143   fa_open_always:		EQU	10h
040000             0144   fa_open_append:		EQU	30h
040000             0145   
040000             0146   ; System variable indexes for api_sysvars
040000             0147   ; Index into _sysvars in globals.asm
040000             0148   ;
040000             0149   sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0150   sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0151   sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0152   sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0153   sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0154   sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0155   sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0156   sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0157   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0158   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0159   sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0160   sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0161   sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0162   sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0163   sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0164   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0165   sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0166   sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0167   sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0168   sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0169   sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0170   sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0171   sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0172   sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0173   sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0174   sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0175   sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0176   sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0177   sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0178   sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0179   sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0180   sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0181   ;
040000             0182   ; Flags for the VPD protocol
040000             0183   ;
040000             0184   vdp_pflag_cursor:	EQU	00000001b
040000             0185   vdp_pflag_scrchar:	EQU	00000010b
040000             0186   vdp_pflag_point:	EQU	00000100b
040000             0187   vdp_pflag_audio:	EQU	00001000b
040000             0188   vdp_pflag_mode:		EQU	00010000b
040000             0189   vdp_pflag_rtc:		EQU	00100000b
040000             0190   vdp_pflag_mouse:	EQU	01000000b
040000             0191   ; vdp_pflag_buffered:	EQU	10000000b
040000             0192   
040000             0193   
040000             0194   ; FatFS structures
040000             0195   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0196   ;
040000             0197   ; Object ID and allocation information (FFOBJID)
040000             0198   FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0199   FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0200   FFOBJID.attr:     EQU 5    ; Object attribute
040000             0201   FFOBJID.stat:     EQU 6    ; Object chain status
040000             0202   FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0203   FFOBJID.objsize:  EQU 11   ; Object size
040000             0204   FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0205   ;
040000             0206   ; File object structure (FIL)
040000             0207   ;
040000             0208   FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0209   FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0210   FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0211   FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0212   FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0213   FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0214   FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0215   FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0216   FIL.obj.objsize:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0217   ;
040000             0218   ; Directory object structure (DIR)
040000             0219   ;
040000             0220   DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0221   DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0222   DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0223   DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0224   DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0225   DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226   DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0227   DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0228   ;
040000             0229   ; File information structure (FILINFO)
040000             0230   ;
040000             0231   FILINFO.fsize:    EQU 0    ; File size
040000             0232   FILINFO.fdate:    EQU 4    ; Modified date
040000             0233   FILINFO.ftime:    EQU 6    ; Modified time
040000             0234   FILINFO.fattrib:  EQU 8    ; File attribute
040000             0235   FILINFO.altname:  EQU 9    ; Alternative file name
040000             0236   FILINFO.fname:    EQU 22   ; Primary file name
040000             0237   FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0238   ;
040000             0239   ; Macro for calling the API
040000             0240   ; Parameters:
040000             0241   ; - function: One of the function numbers listed above
040000             0242   ;
040000             0243   			MACRO MOSCALL	function
040000             0244   			LD	A, function
040000             0245   			RST.LIS	08h
040000             0246   			ENDMACRO 	; --- End mos_api.inc ---
040000             0247   
040000             0248   ; --- Begin equs.inc ---
040000             0249   ; ; TEMPORARY LABELS FOR PIECEMEAL ASSEMBLY
040000             0250   ; STAVAR: EQU 0
040000             0251   ; ACCS: EQU 0
040000             0252   ; ; END TEMPORARY LABELS FOR PIECEMEAL ASSEMBLY
040000             0253   
040000             0254   ;
040000             0255   ; Title:	BBC Basic for AGON - Equs
040000             0256   ; Author:	Dean Belfield
040000             0257   ; Created:	04/12/2024
040000             0258   ; Last Updated:	05/12/2024
040000             0259   ;
040000             0260   ; Modinfo:
040000             0261   ; 05/12/2024:	Removed Stack_Top
040000             0262   
040000             0263   ;			XREF		STAVAR
040000             0264   ;			XREF		ACCS
040000             0265   
040000             0266   RAM_Top:		EQU		0FF00h
040000             0267   
040000             0268   ; For GPIO
040000             0269   ; PA not available on eZ80L92
040000             0270   ;
040000             0271   PA_DR:			EQU		96h
040000             0272   PA_DDR:			EQU		97h
040000             0273   PA_ALT1:		EQU		98h
040000             0274   PA_ALT2:		EQU		99h
040000             0275   PB_DR:          	EQU		9Ah
040000             0276   PB_DDR:        	 	EQU		9Bh
040000             0277   PB_ALT1:        	EQU		9Ch
040000             0278   PB_ALT2:        	EQU		9Dh
040000             0279   PC_DR:          	EQU		9Eh
040000             0280   PC_DDR:         	EQU		9Fh
040000             0281   PC_ALT1:        	EQU		A0h
040000             0282   PC_ALT2:        	EQU		A1h
040000             0283   PD_DR:          	EQU		A2h
040000             0284   PD_DDR:			EQU		A3h
040000             0285   PD_ALT1:		EQU		A4h
040000             0286   PD_ALT2:		EQU		A5h
040000             0287   
040000             0288   GPIOMODE_OUT:		EQU		0	; Output
040000             0289   GPIOMODE_IN:		EQU		1	; Input
040000             0290   GPIOMODE_DIO:		EQU		2	; Open Drain IO
040000             0291   GPIOMODE_SIO:		EQU		3	; Open Source IO
040000             0292   GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040000             0293   GPIOMODE_ALTF:		EQU		5;	; Alt Function
040000             0294   GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040000             0295   GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040000             0296   GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040000             0297   GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040000             0298   
040000             0299   ; Originally in ram.asm
040000             0300   ;
040000             0301   ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%) ; back to data.asm
040000             0302   ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%) ; back to data.asm
040000             0303   ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands ; moved to data.asm
040000             0304   
040000             0305   ; Originally in main.asm
040000             0306   ;
040000             0307   CR:			EQU     0DH
040000             0308   LF:			EQU     0AH
040000             0309   ESC:			EQU     1BH
040000             0310   ; --- End equs.inc ---
040000             0311   
040000             0312   ; --- Begin macros.inc ---
040000             0313   ;
040000             0314   ; Title:	BBC Basic Interpreter - Z80 version
040000             0315   ;		Useful macros
040000             0316   ; Author:	Dean Belfield
040000             0317   ; Created:	04/12/2024
040000             0318   ; Last Updated:	04/12/2024
040000             0319   ;
040000             0320   ; Modinfo:
040000             0321   
040000             0322           MACRO EXREG rp1, rp2
040000             0323           PUSH    rp1
040000             0324           POP     rp2
040000             0325           ENDMACRO
040000             0326   
040000             0327           MACRO ADD8U_DE ; reg
040000             0328           ADD     A, E
040000             0329           LD      E, A
040000             0330           ADC     A, D
040000             0331           SUB     E
040000             0332           LD      D, A
040000             0333           ENDMACRO
040000             0334   
040000             0335           MACRO ADD8U_HL ; reg
040000             0336           ADD     A, L
040000             0337           LD      L, A
040000             0338           ADC     A, H
040000             0339           SUB     L
040000             0340           LD      H, A
040000             0341           ENDMACRO
040000             0342   
040000             0343           MACRO VDU VAL
040000             0344           LD      A, VAL
040000             0345           CALL    OSWRCH
040000             0346           ENDMACRO
040000             0347   
040000             0348           MACRO SET_GPIO REG, VAL
040000             0349           IN0     A, (REG)
040000             0350           OR      VAL
040000             0351           OUT0    (REG), A
040000             0352           ENDMACRO
040000             0353   
040000             0354           MACRO RES_GPIO REG, VAL
040000             0355           PUSH    BC
040000             0356           LD      A, VAL
040000             0357           CPL
040000             0358           LD      C, A
040000             0359           IN0     A, (REG)
040000             0360           AND     C
040000             0361           OUT0    (REG), A
040000             0362           POP     BC
040000             0363           ENDMACRO
040000             0364   ; --- End macros.inc ---
040000             0365   
040000             0366   ; --- Begin agon_init.asm ---
040000             0367   ;
040000             0368   ; Title:	BBC Basic for AGON - Initialisation Code
040000             0369   ;		Initialisation Code
040000             0370   ; Author:	Dean Belfield
040000             0371   ; Created:	04/12/2024
040000             0372   ; Last Updated:	14/12/2024
040000             0373   ;
040000             0374   ; Modinfo:
040000             0375   ; 14/12/2024:	Fix for *BYE command
040000             0376   
040000             0377   ;			SEGMENT __VECTORS
040000             0378   
040000             0379   ;			XREF	START
040000             0380   ;			XREF	ACCS
040000             0381   ;			XREF	TELL
040000             0382   
040000             0383   			.ASSUME	ADL = 0
040000             0384   			.ORG 0x0000
000000             0385   
000000             0386   			; INCLUDE	"equs.inc"
000000             0387   
000000             0388   argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
000000             0389   
000000             0390   ;
000000             0391   ; Start in mixed mode. Assumes MBASE is set to correct segment
000000             0392   ;
000000 C3 52 00    0393   			JP	_start				; Jump to start
000003             0394   			DS	5
000008             0395   
       FF FF FF FF 
       FF 
000008 49 CF       0396   RST_08:			RST.LIS	08h				; API call
00000A C9          0397   			RET
00000B             0398   			DS 	5
000010             0399   
       FF FF FF FF 
       FF 
000010 49 D7       0400   RST_10:			RST.LIS 10h				; Output
000012 C9          0401   			RET
000013             0402   			DS	5
000018             0403   
       FF FF FF FF 
       FF 
000018 49 DF       0404   RST_18:			RST.LIS	18h				; Block Output
00001A C9          0405   			RET
00001B             0406   			DS	5
000020             0407   
000020             0408   RST_20:			DS	8
000028             0409   RST_28:			DS	8
000030             0410   RST_30:			DS	8
000038             0411   
000038             0412   ;
000038             0413   ; The NMI interrupt vector (not currently used by AGON)
000038             0414   ;
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF 
000038 FB          0415   RST_38:			EI
000039 ED 4D       0416   			RETI
00003B             0417   ;
00003B             0418   ; The header stuff is from byte 64 onwards
00003B             0419   ;
00003B FF FF FF FF 0420   			ALIGN	64
       FF          
000040             0421   
000040 4D 4F 53    0422   			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
000043 00          0423   			DB	00h				; MOS header version 0
000044 00          0424   			DB	00h				; Flag for run mode (0: Z80, 1: ADL)
000045             0425   
000045 42 42 43 42 0426   _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
       41 53 49 43 
       2E 42 49 4E 
       00          
000052             0427   
000052             0428   ;
000052             0429   ; And the code follows on immediately after the header
000052             0430   ;
000052 5B FD E5    0431   _start:			PUSH.LIL	IY			; Preserve IY
000055             0432   
000055 FD 21 00 00 0433   			LD		IY, 0			; Preserve SPS
000059 FD 39       0434   			ADD		IY, SP
00005B 5B FD E5    0435   			PUSH.LIL	IY
00005E             0436   
00005E E3          0437   			EX		(SP), HL		; Get the SPS part of the return address
00005F 5B E5       0438   			PUSH.LIL	HL
000061 E3          0439   			EX		(SP), HL		; And restore it for BASIC
000062             0440   
000062 5B F5       0441   			PUSH.LIL	AF			; Preserve the rest of the registers
000064 5B C5       0442   			PUSH.LIL	BC
000066 5B D5       0443   			PUSH.LIL	DE
000068 5B DD E5    0444   			PUSH.LIL	IX
00006B             0445   
00006B ED 6E       0446   			LD		A, MB			; Segment base
00006D DD 21 65 01 0447   			LD		IX, argv_ptrs		; The argv array pointer address
000071 CD 51 01    0448   			CALL		_set_aix24		; Convert to a 24-bit address
000074 5B DD E5    0449   			PUSH.LIL	IX
000077 CD E1 00    0450   			CALL		_parse_params		; Parse the parameters
00007A 5B DD E1    0451   			POP.LIL		IX			; IX: argv
00007D 06 00       0452   			LD		B, 0			;  C: argc
00007F CD 9A 00    0453   			CALL		_main			; Start user code
000082             0454   
000082 5B DD E1    0455   			POP.LIL		IX			; Restore the registers
000085 5B D1       0456   			POP.LIL		DE
000087 5B C1       0457   			POP.LIL		BC
000089 5B F1       0458   			POP.LIL		AF
00008B             0459   
00008B EB          0460   			EX		DE, HL 			; DE: Return code from BASIC
00008C 5B E1       0461   			POP.LIL		HL 			; The SPS part of the return address
00008E 5B FD E1    0462   			POP.LIL		IY			; Get the preserved SPS
000091 FD F9       0463   			LD		SP, IY			; Restore SPS
000093 E3          0464   			EX		(SP), HL		; Store the SPS part of the return address on the stack
000094 EB          0465   			EX		DE, HL 			; HL: Return code from BASIC
000095             0466   
000095 5B FD E1    0467   			POP.LIL		IY			; Restore IY
000098 49 C9       0468   			RET.L					; Return to MOS
00009A             0469   
00009A             0470   ; The main routine
00009A             0471   ; IXU: argv - pointer to array of parameters
00009A             0472   ;   C: argc - number of parameters
00009A             0473   ; Returns:
00009A             0474   ;  HL: Error code, or 0 if OK
00009A             0475   ;
00009A 21 00 52    0476   _main:			LD	HL, ACCS		; Clear the ACCS
00009D 36 00       0477   			LD	(HL), 0
00009F 79          0478   			LD	A, C
0000A0 FE 02       0479   			CP	2
0000A2 28 24       0480   			JR	Z, _autoload		; 2 parameters = autoload
0000A4 38 35       0481   			JR	C, _startbasic		; 1 parameter = normal start
0000A6             0482   ;			CALL	STAR_VERSION		; Output the AGON version
0000A6 CD 7D 45    0483   			CALL	TELL
0000A9 55 73 61 67 0484   			DB	"Usage:\n\r"
       65 3A 0A 0D 
0000B1 52 55 4E 20 0485   			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
0000C4 21 00 00    0486   			LD	HL, 0			; The error code
0000C7 C9          0487   			RET
0000C8             0488   ;
0000C8 5B DD 27 03 0489   _autoload:		LD.LIL	HL, (IX+3)		; HLU: Address of filename
0000CC 11 00 52    0490   			LD	DE, ACCS		;  DE: Destination address
0000CF 5B 7E       0491   @@:			LD.LIL	A, (HL)			; Fetch the filename byte
0000D1 12          0492   			LD	(DE), A			;
0000D2 5B 23       0493   			INC.LIL	HL			; Increase the source pointer
0000D4 1C          0494   			INC	E			; We only need to increase E as ACCS is on a page boundary
0000D5 20 F8       0495   			JR	NZ, @B			; Loop until we hit a 0 byte
0000D7 1D          0496   			DEC	E
0000D8 3E 0D       0497   			LD	A, CR
0000DA 12          0498   			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
0000DB             0499   ;
0000DB E1          0500   _startbasic:		POP	 HL			; Pop the return address to init off SPS
0000DC 5B E5       0501   			PUSH.LIL HL 			; Stack it on SPL (*BYE will use this as the return address)
0000DE C3 9A 37    0502   			JP	 START			; And start BASIC
0000E1             0503   
0000E1             0504   ; Parse the parameter string into a C array
0000E1             0505   ; Parameters
0000E1             0506   ; -   A: Segment base
0000E1             0507   ; - HLU: Address of parameter string
0000E1             0508   ; - IXU: Address for array pointer storage
0000E1             0509   ; Returns:
0000E1             0510   ; -   C: Number of parameters parsed
0000E1             0511   ;
0000E1 01 45 00    0512   _parse_params:		LD		BC, _exec_name		; Get the address of the app name in this segment
0000E4 CD 3F 01    0513   			CALL		_set_abc24		; Convert it to a 24-bit address based upon segment base
0000E7 5B DD 0F 00 0514   			LD.LIL		(IX+0), BC		; ARGV[0] = the executable name
0000EB 5B DD 23    0515   			INC.LIL		IX
0000EE 5B DD 23    0516   			INC.LIL		IX
0000F1 5B DD 23    0517   			INC.LIL		IX
0000F4 CD 36 01    0518   			CALL		_skip_spaces		; Skip HL past any leading spaces
0000F7             0519   ;
0000F7 01 01 00    0520   			LD		BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0000FA 06 0F       0521   			LD		B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0000FC             0522   ;
0000FC C5          0523   _parse_params_1:	PUSH		BC			; Stack ARGC
0000FD 5B E5       0524   			PUSH.LIL	HL			; Stack start address of token
0000FF CD 25 01    0525   			CALL		_get_token		; Get the next token
000102 79          0526   			LD		A, C			; A: Length of the token in characters
000103 5B D1       0527   			POP.LIL		DE			; Start address of token (was in HL)
000105 C1          0528   			POP		BC			; ARGC
000106 B7          0529   			OR		A			; Check for A=0 (no token found) OR at end of string
000107 C8          0530   			RET		Z
000108             0531   ;
000108 5B DD 1F 00 0532   			LD.LIL		(IX+0), DE		; Store the pointer to the token
00010C 5B E5       0533   			PUSH.LIL	HL			; DE=HL
00010E 5B D1       0534   			POP.LIL		DE
000110 CD 36 01    0535   			CALL		_skip_spaces		; And skip HL past any spaces onto the next character
000113 AF          0536   			XOR		A
000114 5B 12       0537   			LD.LIL		(DE), A			; Zero-terminate the token
000116 5B DD 23    0538   			INC.LIL		IX
000119 5B DD 23    0539   			INC.LIL		IX
00011C 5B DD 23    0540   			INC.LIL		IX			; Advance to next pointer position
00011F 0C          0541   			INC		C			; Increment ARGC
000120 79          0542   			LD		A, C			; Check for C >= A
000121 B8          0543   			CP		B
000122 38 D8       0544   			JR		C, _parse_params_1	; And loop
000124 C9          0545   			RET
000125             0546   
000125             0547   ; Get the next token
000125             0548   ; Parameters:
000125             0549   ; - HL: Address of parameter string
000125             0550   ; Returns:
000125             0551   ; - HL: Address of first character after token
000125             0552   ; -  C: Length of token (in characters)
000125             0553   ;
000125 0E 00       0554   _get_token:		LD		C, 0			; Initialise length
000127 5B 7E       0555   @@:			LD.LIL		A, (HL)			; Get the character from the parameter string
000129 B7          0556   			OR		A			; Exit if 0 (end of parameter string in MOS)
00012A C8          0557   			RET 		Z
00012B FE 0D       0558   			CP		13			; Exit if CR (end of parameter string in BBC BASIC)
00012D C8          0559   			RET		Z
00012E FE 20       0560   			CP		' '			; Exit if space (end of token)
000130 C8          0561   			RET		Z
000131 5B 23       0562   			INC.LIL		HL			; Advance to next character
000133 0C          0563   			INC 		C			; Increment length
000134 18 F1       0564   			JR		@B
000136             0565   
000136             0566   ; Skip spaces in the parameter string
000136             0567   ; Parameters:
000136             0568   ; - HL: Address of parameter string
000136             0569   ; Returns:
000136             0570   ; - HL: Address of next none-space character
000136             0571   ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
000136             0572   ;
000136 5B 7E       0573   _skip_spaces:		LD.LIL		A, (HL)			; Get the character from the parameter string
000138 FE 20       0574   			CP		' '			; Exit if not space
00013A C0          0575   			RET		NZ
00013B 5B 23       0576   			INC.LIL		HL			; Advance to next character
00013D 18 F7       0577   			JR		_skip_spaces		; Increment length
00013F             0578   
00013F             0579   ; Set the MSB of BC (U) to A
00013F             0580   ; Parameters:
00013F             0581   ; - BC: 16-bit address
00013F             0582   ; -  A: Value to stick in U of BC
00013F             0583   ; Returns:
00013F             0584   ; - BCU
00013F             0585   ;
00013F 5B E5       0586   _set_abc24:		PUSH.LIL	HL			; Preserve HL
000141 5B C5       0587   			PUSH.LIL	BC			; Stick BC onto SPL
000143 5B 21 02 00 0588   			LD.LIL		HL, 2			; HL: SP+2
       00          
000148 5B 39       0589   			ADD.LIL		HL, SP
00014A 5B 77       0590   			LD.LIL		(HL), A			; Store A in it
00014C 5B C1       0591   			POP.LIL		BC			; Fetch ammended BC
00014E 5B E1       0592   			POP.LIL		HL			; Restore HL
000150 C9          0593   			RET
000151             0594   
000151             0595   ; Set the MSB of BC (U) to A
000151             0596   ; Parameters:
000151             0597   ; - IX: 16-bit address
000151             0598   ; -  A: Value to stick in U of BC
000151             0599   ; Returns:
000151             0600   ; - IXU
000151             0601   ;
000151 5B DD E5    0602   _set_aix24:		PUSH.LIL	IX			; Stick IX onto SPL
000154 5B DD 21 02 0603   			LD.LIL		IX, 2			; IX: SP+2
       00 00       
00015A 5B DD 39    0604   			ADD.LIL		IX, SP
00015D 5B DD 77 00 0605   			LD.LIL		(IX), A			; Store A in it
000161 5B DD E1    0606   			POP.LIL		IX			; Fetch ammended IX
000164 C9          0607   			RET
000165             0608   
000165             0609   ; Storage for the argv array pointers
000165             0610   ;
000165 00 00 00 00 0611   argv_ptrs:		BLKP	argv_ptrs_max, 0		; Storage for the argv array pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
000195             0612   ; --- End agon_init.asm ---
000195             0613   
000195             0614   ; --- Begin agon_graphics.asm ---
000195             0615   ;
000195             0616   ; Title:	BBC Basic for AGON - Graphics stuff
000195             0617   ; Author:	Dean Belfield
000195             0618   ; Created:	04/12/2024
000195             0619   ; Last Updated:	17/12/2024
000195             0620   ;
000195             0621   ; Modinfo:
000195             0622   ; 11/12/2024:	Modified POINT_ to work with OSWORD
000195             0623   ; 17/12/2024:	Modified GETSCHR
000195             0624   
000195             0625   			.ASSUME	ADL = 0
000195             0626   
000195             0627   			; INCLUDE	"equs.inc"
000195             0628   			; INCLUDE "macros.inc"
000195             0629   			; INCLUDE "mos_api.inc"	; In MOS/src
000195             0630   
000195             0631   			; SEGMENT CODE
000195             0632   
000195             0633   			; XDEF	MODE_
000195             0634   			; XDEF	COLOUR_
000195             0635   			; XDEF	POINT_
000195             0636   			; XDEF	GETSCHR
000195             0637   
000195             0638   			; XREF	ACCS
000195             0639   			; XREF	OSWRCH
000195             0640   			; XREF	ASC_TO_NUMBER
000195             0641   			; XREF	EXTERR
000195             0642   			; XREF	EXPRI
000195             0643   			; XREF	COMMA
000195             0644   			; XREF	XEQ
000195             0645   			; XREF	NXT
000195             0646   			; XREF	BRAKET
000195             0647   			; XREF	CRTONULL
000195             0648   			; XREF	NULLTOCR
000195             0649   			; XREF	CRLF
000195             0650   			; XREF	EXPR_W2
000195             0651   
000195             0652   ; MODE n: Set video mode
000195             0653   ;
000195 DD E5       0654   MODE_:			PUSH	IX			; Get the system vars in IX
000197             0655   			MOSCALL	mos_sysvars		; Reset the semaphore
000197 3E 08       0001M1 			LD	A, function
000199 49 CF       0002M1 			RST.LIS	08h
00019B 5B DD CB 04 0656   			RES.LIL	4, (IX+sysvar_vpd_pflags)
       A6          
0001A0 CD B6 18    0657   			CALL    EXPRI
0001A3 D9          0658   			EXX
0001A4             0659   			VDU	16H			; Mode change
0001A4 3E 16       0001M1         LD      A, VAL
0001A6 CD 97 05    0002M1         CALL    OSWRCH
0001A9             0660   			VDU	L
0001A9 7D          0001M1         LD      A, VAL
0001AA CD 97 05    0002M1         CALL    OSWRCH
0001AD             0661   			MOSCALL	mos_sysvars
0001AD 3E 08       0001M1 			LD	A, function
0001AF 49 CF       0002M1 			RST.LIS	08h
0001B1 5B DD CB 04 0662   @@:			BIT.LIL	4, (IX+sysvar_vpd_pflags)
       66          
0001B6 28 F9       0663   			JR	Z, @B			; Wait for the result
0001B8 DD E1       0664   			POP	IX
0001BA C3 1C 25    0665   			JP	XEQ
0001BD             0666   
0001BD             0667   ;
0001BD             0668   ; Fetch a character from the screen
0001BD             0669   ; - DE: X coordinate
0001BD             0670   ; - HL: Y coordinate
0001BD             0671   ; Returns
0001BD             0672   ; - A: The character or FFh if no match
0001BD             0673   ; - F: C if match, otherwise NC
0001BD             0674   ;
0001BD DD E5       0675   GETSCHR:		PUSH	IX			; Get the system vars in IX
0001BF             0676   			MOSCALL	mos_sysvars		; Reset the semaphore
0001BF 3E 08       0001M1 			LD	A, function
0001C1 49 CF       0002M1 			RST.LIS	08h
0001C3 5B DD CB 04 0677   			RES.LIL	1, (IX+sysvar_vpd_pflags)
       8E          
0001C8             0678   			VDU	23
0001C8 3E 17       0001M1         LD      A, VAL
0001CA CD 97 05    0002M1         CALL    OSWRCH
0001CD             0679   			VDU	0
0001CD 3E 00       0001M1         LD      A, VAL
0001CF CD 97 05    0002M1         CALL    OSWRCH
0001D2             0680   			VDU	vdp_scrchar
0001D2 3E 83       0001M1         LD      A, VAL
0001D4 CD 97 05    0002M1         CALL    OSWRCH
0001D7             0681   			VDU	E
0001D7 7B          0001M1         LD      A, VAL
0001D8 CD 97 05    0002M1         CALL    OSWRCH
0001DB             0682   			VDU	D
0001DB 7A          0001M1         LD      A, VAL
0001DC CD 97 05    0002M1         CALL    OSWRCH
0001DF             0683   			VDU	L
0001DF 7D          0001M1         LD      A, VAL
0001E0 CD 97 05    0002M1         CALL    OSWRCH
0001E3             0684   			VDU	H
0001E3 7C          0001M1         LD      A, VAL
0001E4 CD 97 05    0002M1         CALL    OSWRCH
0001E7 5B DD CB 04 0685   @@:			BIT.LIL	1, (IX+sysvar_vpd_pflags)
       4E          
0001EC 28 F9       0686   			JR	Z, @B			; Wait for the result
0001EE 5B DD 7E 09 0687   			LD.LIL	A, (IX+sysvar_scrchar)	; Fetch the result in A
0001F2 B7          0688   			OR	A			; Check for 00h
0001F3 37          0689   			SCF				; C = character map
0001F4 20 01       0690   			JR	NZ, @F			; We have a character, so skip next bit
0001F6 AF          0691   			XOR	A			; Clear carry
0001F7 DD E1       0692   @@:			POP	IX
0001F9 C9          0693   			RET
0001FA             0694   
0001FA             0695   ; POINT(x,y): Get the pixel colour of a point on screen
0001FA             0696   ; Parameters:
0001FA             0697   ; - DE: X-coordinate
0001FA             0698   ; - HL: Y-coordinate
0001FA             0699   ; Returns:
0001FA             0700   ; -  A: Pixel colour
0001FA             0701   ;
0001FA DD E5       0702   POINT_:			PUSH	IX			; Get the system vars in IX
0001FC             0703   			MOSCALL	mos_sysvars		; Reset the semaphore
0001FC 3E 08       0001M1 			LD	A, function
0001FE 49 CF       0002M1 			RST.LIS	08h
000200 5B DD CB 04 0704   			RES.LIL	2, (IX+sysvar_vpd_pflags)
       96          
000205             0705   			VDU	23
000205 3E 17       0001M1         LD      A, VAL
000207 CD 97 05    0002M1         CALL    OSWRCH
00020A             0706   			VDU	0
00020A 3E 00       0001M1         LD      A, VAL
00020C CD 97 05    0002M1         CALL    OSWRCH
00020F             0707   			VDU	vdp_scrpixel
00020F 3E 84       0001M1         LD      A, VAL
000211 CD 97 05    0002M1         CALL    OSWRCH
000214             0708   			VDU	E
000214 7B          0001M1         LD      A, VAL
000215 CD 97 05    0002M1         CALL    OSWRCH
000218             0709   			VDU	D
000218 7A          0001M1         LD      A, VAL
000219 CD 97 05    0002M1         CALL    OSWRCH
00021C             0710   			VDU	L
00021C 7D          0001M1         LD      A, VAL
00021D CD 97 05    0002M1         CALL    OSWRCH
000220             0711   			VDU	H
000220 7C          0001M1         LD      A, VAL
000221 CD 97 05    0002M1         CALL    OSWRCH
000224 5B DD CB 04 0712   @@:			BIT.LIL	2, (IX+sysvar_vpd_pflags)
       56          
000229 28 F9       0713   			JR	Z, @B			; Wait for the result
00022B             0714   ;
00022B             0715   ; Return the data as a 1 byte index
00022B             0716   ;
00022B 5B DD 7E 16 0717   			LD.LIL	A, (IX+sysvar_scrpixelIndex)
00022F DD E1       0718   			POP	IX
000231 C9          0719   			RET
000232             0720   
000232             0721   ; COLOUR colour
000232             0722   ; COLOUR L,P
000232             0723   ; COLOUR L,R,G,B
000232             0724   ;
000232 CD B6 18    0725   COLOUR_:		CALL	EXPRI			; The colour / mode
000235 D9          0726   			EXX
000236 7D          0727   			LD	A, L
000237 32 00 52    0728   			LD	(VDU_BUFFER+0), A	; Store first parameter
00023A CD 8E 45    0729   			CALL	NXT			; Are there any more parameters?
00023D FE 2C       0730   			CP	','
00023F 28 0E       0731   			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
000241             0732   ;
000241             0733   			VDU	11h			; Just set the colour
000241 3E 11       0001M1         LD      A, VAL
000243 CD 97 05    0002M1         CALL    OSWRCH
000246             0734   			VDU	(VDU_BUFFER+0)
000246 3A 00 52    0001M1         LD      A, VAL
000249 CD 97 05    0002M1         CALL    OSWRCH
00024C C3 1C 25    0735   			JP	XEQ
00024F             0736   ;
00024F CD 25 21    0737   COLOUR_1:		CALL	COMMA
000252 CD B6 18    0738   			CALL	EXPRI			; Parse R (OR P)
000255 D9          0739   			EXX
000256 7D          0740   			LD	A, L
000257 32 01 52    0741   			LD	(VDU_BUFFER+1), A
00025A CD 8E 45    0742   			CALL	NXT			; Are there any more parameters?
00025D FE 2C       0743   			CP	','
00025F 28 23       0744   			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
000261             0745   ;
000261             0746   			VDU	13h			; VDU:COLOUR
000261 3E 13       0001M1         LD      A, VAL
000263 CD 97 05    0002M1         CALL    OSWRCH
000266             0747   			VDU	(VDU_BUFFER+0)		; Logical Colour
000266 3A 00 52    0001M1         LD      A, VAL
000269 CD 97 05    0002M1         CALL    OSWRCH
00026C             0748   			VDU	(VDU_BUFFER+1)		; Palette Colour
00026C 3A 01 52    0001M1         LD      A, VAL
00026F CD 97 05    0002M1         CALL    OSWRCH
000272             0749   			VDU	0			; RGB set to 0
000272 3E 00       0001M1         LD      A, VAL
000274 CD 97 05    0002M1         CALL    OSWRCH
000277             0750   			VDU	0
000277 3E 00       0001M1         LD      A, VAL
000279 CD 97 05    0002M1         CALL    OSWRCH
00027C             0751   			VDU	0
00027C 3E 00       0001M1         LD      A, VAL
00027E CD 97 05    0002M1         CALL    OSWRCH
000281 C3 1C 25    0752   			JP	XEQ
000284             0753   ;
000284 CD 25 21    0754   COLOUR_2:		CALL	COMMA
000287 CD B6 18    0755   			CALL	EXPRI			; Parse G
00028A D9          0756   			EXX
00028B 7D          0757   			LD	A, L
00028C 32 02 52    0758   			LD	(VDU_BUFFER+2), A
00028F CD 25 21    0759   			CALL	COMMA
000292 CD B6 18    0760   			CALL	EXPRI			; Parse B
000295 D9          0761   			EXX
000296 7D          0762   			LD	A, L
000297 32 03 52    0763   			LD	(VDU_BUFFER+3), A
00029A             0764   			VDU	13h			; VDU:COLOUR
00029A 3E 13       0001M1         LD      A, VAL
00029C CD 97 05    0002M1         CALL    OSWRCH
00029F             0765   			VDU	(VDU_BUFFER+0)		; Logical Colour
00029F 3A 00 52    0001M1         LD      A, VAL
0002A2 CD 97 05    0002M1         CALL    OSWRCH
0002A5             0766   			VDU	FFh			; Physical Colour (-1 for RGB mode)
0002A5 3E FF       0001M1         LD      A, VAL
0002A7 CD 97 05    0002M1         CALL    OSWRCH
0002AA             0767   			VDU	(VDU_BUFFER+1)		; R
0002AA 3A 01 52    0001M1         LD      A, VAL
0002AD CD 97 05    0002M1         CALL    OSWRCH
0002B0             0768   			VDU	(VDU_BUFFER+2)		; G
0002B0 3A 02 52    0001M1         LD      A, VAL
0002B3 CD 97 05    0002M1         CALL    OSWRCH
0002B6             0769   			VDU	(VDU_BUFFER+3)		; B
0002B6 3A 03 52    0001M1         LD      A, VAL
0002B9 CD 97 05    0002M1         CALL    OSWRCH
0002BC C3 1C 25    0770   			JP	XEQ; --- End agon_graphics.asm ---
0002BF             0771   
0002BF             0772   ; --- Begin agon_gpio.asm ---
0002BF             0773   ;
0002BF             0774   ; Title:	BBC Basic for AGON - GPIO functions
0002BF             0775   ; Author:	Dean Belfield
0002BF             0776   ; Created:	04/12/2024
0002BF             0777   ; Last Updated:	04/12/2024
0002BF             0778   ;
0002BF             0779   ; Modinfo:
0002BF             0780   
0002BF             0781   			; INCLUDE	"macros.inc"
0002BF             0782   			; INCLUDE	"equs.inc"
0002BF             0783   
0002BF             0784   			.ASSUME	ADL = 0
0002BF             0785   ;	.ORG 0x0000
0002BF             0786   
0002BF             0787   ;			SEGMENT CODE
0002BF             0788   
0002BF             0789   ;			XDEF	GPIOB_SETMODE
0002BF             0790   
0002BF             0791   ;			XREF	SWITCH_A
0002BF             0792   
0002BF             0793   ;  A: Mode
0002BF             0794   ;  B: Pins
0002BF             0795   ;
0002BF CD 18 05    0796   GPIOB_SETMODE:		CALL	SWITCH_A
0002C2 D6 02       0797   			DW	GPIOB_M0	; Output
0002C4 FB 02       0798   			DW	GPIOB_M1	; Input
0002C6 1B 03       0799   			DW	GPIOB_M2	; Open Drain IO
0002C8 3B 03       0800   			DW	GPIOB_M3	; Open Source IO
0002CA 56 03       0801   			DW	GPIOB_M4	; Interrupt, Dual Edge
0002CC 82 03       0802   			DW	GPIOB_M5	; Alt Function
0002CE 9D 03       0803   			DW	GPIOB_M6	; Interrupt, Active Low
0002D0 C4 03       0804   			DW	GPIOB_M7	; Interrupt, Active High
0002D2 E6 03       0805   			DW	GPIOB_M8	; Interrupt, Falling Edge
0002D4 08 04       0806   			DW	GPIOB_M9	; Interrupt, Rising Edge
0002D6             0807   
0002D6             0808   ; Output
0002D6             0809   ;
0002D6             0810   GPIOB_M0:		RES_GPIO PB_DDR,  B
0002D6 C5          0001M1         PUSH    BC
0002D7 78          0002M1         LD      A, VAL
0002D8 2F          0003M1         CPL
0002D9 4F          0004M1         LD      C, A
0002DA ED 38 9B    0005M1         IN0     A, (REG)
0002DD A1          0006M1         AND     C
0002DE ED 39 9B    0007M1         OUT0    (REG), A
0002E1 C1          0008M1         POP     BC
0002E2             0811   			RES_GPIO PB_ALT1, B
0002E2 C5          0001M1         PUSH    BC
0002E3 78          0002M1         LD      A, VAL
0002E4 2F          0003M1         CPL
0002E5 4F          0004M1         LD      C, A
0002E6 ED 38 9C    0005M1         IN0     A, (REG)
0002E9 A1          0006M1         AND     C
0002EA ED 39 9C    0007M1         OUT0    (REG), A
0002ED C1          0008M1         POP     BC
0002EE             0812   			RES_GPIO PB_ALT2, B
0002EE C5          0001M1         PUSH    BC
0002EF 78          0002M1         LD      A, VAL
0002F0 2F          0003M1         CPL
0002F1 4F          0004M1         LD      C, A
0002F2 ED 38 9D    0005M1         IN0     A, (REG)
0002F5 A1          0006M1         AND     C
0002F6 ED 39 9D    0007M1         OUT0    (REG), A
0002F9 C1          0008M1         POP     BC
0002FA C9          0813   			RET
0002FB             0814   
0002FB             0815   ; Input
0002FB             0816   ;
0002FB             0817   GPIOB_M1:		SET_GPIO PB_DDR,  B
0002FB ED 38 9B    0001M1         IN0     A, (REG)
0002FE B0          0002M1         OR      VAL
0002FF ED 39 9B    0003M1         OUT0    (REG), A
000302             0818   			RES_GPIO PB_ALT1, B
000302 C5          0001M1         PUSH    BC
000303 78          0002M1         LD      A, VAL
000304 2F          0003M1         CPL
000305 4F          0004M1         LD      C, A
000306 ED 38 9C    0005M1         IN0     A, (REG)
000309 A1          0006M1         AND     C
00030A ED 39 9C    0007M1         OUT0    (REG), A
00030D C1          0008M1         POP     BC
00030E             0819   			RES_GPIO PB_ALT2, B
00030E C5          0001M1         PUSH    BC
00030F 78          0002M1         LD      A, VAL
000310 2F          0003M1         CPL
000311 4F          0004M1         LD      C, A
000312 ED 38 9D    0005M1         IN0     A, (REG)
000315 A1          0006M1         AND     C
000316 ED 39 9D    0007M1         OUT0    (REG), A
000319 C1          0008M1         POP     BC
00031A C9          0820   			RET
00031B             0821   
00031B             0822   ; Open Drain IO
00031B             0823   ;
00031B             0824   GPIOB_M2:		RES_GPIO PB_DDR,  B
00031B C5          0001M1         PUSH    BC
00031C 78          0002M1         LD      A, VAL
00031D 2F          0003M1         CPL
00031E 4F          0004M1         LD      C, A
00031F ED 38 9B    0005M1         IN0     A, (REG)
000322 A1          0006M1         AND     C
000323 ED 39 9B    0007M1         OUT0    (REG), A
000326 C1          0008M1         POP     BC
000327             0825   			SET_GPIO PB_ALT1, B
000327 ED 38 9C    0001M1         IN0     A, (REG)
00032A B0          0002M1         OR      VAL
00032B ED 39 9C    0003M1         OUT0    (REG), A
00032E             0826   			RES_GPIO PB_ALT2, B
00032E C5          0001M1         PUSH    BC
00032F 78          0002M1         LD      A, VAL
000330 2F          0003M1         CPL
000331 4F          0004M1         LD      C, A
000332 ED 38 9D    0005M1         IN0     A, (REG)
000335 A1          0006M1         AND     C
000336 ED 39 9D    0007M1         OUT0    (REG), A
000339 C1          0008M1         POP     BC
00033A C9          0827   			RET
00033B             0828   
00033B             0829   ; Open Source IO
00033B             0830   ;
00033B             0831   GPIOB_M3:		SET_GPIO PB_DDR,  B
00033B ED 38 9B    0001M1         IN0     A, (REG)
00033E B0          0002M1         OR      VAL
00033F ED 39 9B    0003M1         OUT0    (REG), A
000342             0832   			SET_GPIO PB_ALT1, B
000342 ED 38 9C    0001M1         IN0     A, (REG)
000345 B0          0002M1         OR      VAL
000346 ED 39 9C    0003M1         OUT0    (REG), A
000349             0833   			RES_GPIO PB_ALT2, B
000349 C5          0001M1         PUSH    BC
00034A 78          0002M1         LD      A, VAL
00034B 2F          0003M1         CPL
00034C 4F          0004M1         LD      C, A
00034D ED 38 9D    0005M1         IN0     A, (REG)
000350 A1          0006M1         AND     C
000351 ED 39 9D    0007M1         OUT0    (REG), A
000354 C1          0008M1         POP     BC
000355 C9          0834   			RET
000356             0835   
000356             0836   ; Interrupt, Dual Edge
000356             0837   ;
000356             0838   GPIOB_M4:		SET_GPIO PB_DR,   B
000356 ED 38 9A    0001M1         IN0     A, (REG)
000359 B0          0002M1         OR      VAL
00035A ED 39 9A    0003M1         OUT0    (REG), A
00035D             0839   			RES_GPIO PB_DDR,  B
00035D C5          0001M1         PUSH    BC
00035E 78          0002M1         LD      A, VAL
00035F 2F          0003M1         CPL
000360 4F          0004M1         LD      C, A
000361 ED 38 9B    0005M1         IN0     A, (REG)
000364 A1          0006M1         AND     C
000365 ED 39 9B    0007M1         OUT0    (REG), A
000368 C1          0008M1         POP     BC
000369             0840   			RES_GPIO PB_ALT1, B
000369 C5          0001M1         PUSH    BC
00036A 78          0002M1         LD      A, VAL
00036B 2F          0003M1         CPL
00036C 4F          0004M1         LD      C, A
00036D ED 38 9C    0005M1         IN0     A, (REG)
000370 A1          0006M1         AND     C
000371 ED 39 9C    0007M1         OUT0    (REG), A
000374 C1          0008M1         POP     BC
000375             0841   			RES_GPIO PB_ALT2, B
000375 C5          0001M1         PUSH    BC
000376 78          0002M1         LD      A, VAL
000377 2F          0003M1         CPL
000378 4F          0004M1         LD      C, A
000379 ED 38 9D    0005M1         IN0     A, (REG)
00037C A1          0006M1         AND     C
00037D ED 39 9D    0007M1         OUT0    (REG), A
000380 C1          0008M1         POP     BC
000381 C9          0842   			RET
000382             0843   
000382             0844   ; Alt Function
000382             0845   ;
000382             0846   GPIOB_M5:		SET_GPIO PB_DDR,  B
000382 ED 38 9B    0001M1         IN0     A, (REG)
000385 B0          0002M1         OR      VAL
000386 ED 39 9B    0003M1         OUT0    (REG), A
000389             0847   			RES_GPIO PB_ALT1, B
000389 C5          0001M1         PUSH    BC
00038A 78          0002M1         LD      A, VAL
00038B 2F          0003M1         CPL
00038C 4F          0004M1         LD      C, A
00038D ED 38 9C    0005M1         IN0     A, (REG)
000390 A1          0006M1         AND     C
000391 ED 39 9C    0007M1         OUT0    (REG), A
000394 C1          0008M1         POP     BC
000395             0848   			SET_GPIO PB_ALT2, B
000395 ED 38 9D    0001M1         IN0     A, (REG)
000398 B0          0002M1         OR      VAL
000399 ED 39 9D    0003M1         OUT0    (REG), A
00039C C9          0849   			RET
00039D             0850   
00039D             0851   ; Interrupt, Active Low
00039D             0852   ;
00039D             0853   GPIOB_M6:		RES_GPIO PB_DR,   B
00039D C5          0001M1         PUSH    BC
00039E 78          0002M1         LD      A, VAL
00039F 2F          0003M1         CPL
0003A0 4F          0004M1         LD      C, A
0003A1 ED 38 9A    0005M1         IN0     A, (REG)
0003A4 A1          0006M1         AND     C
0003A5 ED 39 9A    0007M1         OUT0    (REG), A
0003A8 C1          0008M1         POP     BC
0003A9             0854   			RES_GPIO PB_DDR,  B
0003A9 C5          0001M1         PUSH    BC
0003AA 78          0002M1         LD      A, VAL
0003AB 2F          0003M1         CPL
0003AC 4F          0004M1         LD      C, A
0003AD ED 38 9B    0005M1         IN0     A, (REG)
0003B0 A1          0006M1         AND     C
0003B1 ED 39 9B    0007M1         OUT0    (REG), A
0003B4 C1          0008M1         POP     BC
0003B5             0855   			SET_GPIO PB_ALT1, B
0003B5 ED 38 9C    0001M1         IN0     A, (REG)
0003B8 B0          0002M1         OR      VAL
0003B9 ED 39 9C    0003M1         OUT0    (REG), A
0003BC             0856   			SET_GPIO PB_ALT2, B
0003BC ED 38 9D    0001M1         IN0     A, (REG)
0003BF B0          0002M1         OR      VAL
0003C0 ED 39 9D    0003M1         OUT0    (REG), A
0003C3 C9          0857   			RET
0003C4             0858   
0003C4             0859   
0003C4             0860   ; Interrupt, Active High
0003C4             0861   ;
0003C4             0862   GPIOB_M7:		SET_GPIO PB_DR,   B
0003C4 ED 38 9A    0001M1         IN0     A, (REG)
0003C7 B0          0002M1         OR      VAL
0003C8 ED 39 9A    0003M1         OUT0    (REG), A
0003CB             0863   			RES_GPIO PB_DDR,  B
0003CB C5          0001M1         PUSH    BC
0003CC 78          0002M1         LD      A, VAL
0003CD 2F          0003M1         CPL
0003CE 4F          0004M1         LD      C, A
0003CF ED 38 9B    0005M1         IN0     A, (REG)
0003D2 A1          0006M1         AND     C
0003D3 ED 39 9B    0007M1         OUT0    (REG), A
0003D6 C1          0008M1         POP     BC
0003D7             0864   			SET_GPIO PB_ALT1, B
0003D7 ED 38 9C    0001M1         IN0     A, (REG)
0003DA B0          0002M1         OR      VAL
0003DB ED 39 9C    0003M1         OUT0    (REG), A
0003DE             0865   			SET_GPIO PB_ALT2, B
0003DE ED 38 9D    0001M1         IN0     A, (REG)
0003E1 B0          0002M1         OR      VAL
0003E2 ED 39 9D    0003M1         OUT0    (REG), A
0003E5 C9          0866   			RET
0003E6             0867   
0003E6             0868   
0003E6             0869   ; Interrupt, Falling Edge
0003E6             0870   ;
0003E6             0871   GPIOB_M8:		RES_GPIO PB_DR,   B
0003E6 C5          0001M1         PUSH    BC
0003E7 78          0002M1         LD      A, VAL
0003E8 2F          0003M1         CPL
0003E9 4F          0004M1         LD      C, A
0003EA ED 38 9A    0005M1         IN0     A, (REG)
0003ED A1          0006M1         AND     C
0003EE ED 39 9A    0007M1         OUT0    (REG), A
0003F1 C1          0008M1         POP     BC
0003F2             0872   			SET_GPIO PB_DDR,  B
0003F2 ED 38 9B    0001M1         IN0     A, (REG)
0003F5 B0          0002M1         OR      VAL
0003F6 ED 39 9B    0003M1         OUT0    (REG), A
0003F9             0873   			SET_GPIO PB_ALT1, B
0003F9 ED 38 9C    0001M1         IN0     A, (REG)
0003FC B0          0002M1         OR      VAL
0003FD ED 39 9C    0003M1         OUT0    (REG), A
000400             0874   			SET_GPIO PB_ALT2, B
000400 ED 38 9D    0001M1         IN0     A, (REG)
000403 B0          0002M1         OR      VAL
000404 ED 39 9D    0003M1         OUT0    (REG), A
000407 C9          0875   			RET
000408             0876   
000408             0877   ; Interrupt, Rising Edge
000408             0878   ;
000408             0879   GPIOB_M9:		SET_GPIO PB_DR,   B
000408 ED 38 9A    0001M1         IN0     A, (REG)
00040B B0          0002M1         OR      VAL
00040C ED 39 9A    0003M1         OUT0    (REG), A
00040F             0880   			SET_GPIO PB_DDR,  B
00040F ED 38 9B    0001M1         IN0     A, (REG)
000412 B0          0002M1         OR      VAL
000413 ED 39 9B    0003M1         OUT0    (REG), A
000416             0881   			SET_GPIO PB_ALT1, B
000416 ED 38 9C    0001M1         IN0     A, (REG)
000419 B0          0002M1         OR      VAL
00041A ED 39 9C    0003M1         OUT0    (REG), A
00041D             0882   			SET_GPIO PB_ALT2, B
00041D ED 38 9D    0001M1         IN0     A, (REG)
000420 B0          0002M1         OR      VAL
000421 ED 39 9D    0003M1         OUT0    (REG), A
000424 C9          0883   			RET
000425             0884   ; --- End agon_gpio.asm ---
000425             0885   
000425             0886   ; --- Begin agon_interrupt.asm ---
000425             0887   ;
000425             0888   ; Title:	BBC Basic for AGON - Interrupts
000425             0889   ; Author:	Dean Belfield
000425             0890   ; Created:	04/12/2024
000425             0891   ; Last Updated:	04/12/2024
000425             0892   ;
000425             0893   ; Modinfo:
000425             0894   
000425             0895   			.ASSUME	ADL = 0
000425             0896   ;	.ORG 0x0000
000425             0897   
000425             0898   			; INCLUDE	"macros.inc"
000425             0899   			; INCLUDE	"equs.inc"
000425             0900   			; INCLUDE "mos_api.inc"	; In MOS/src
000425             0901   
000425             0902   ;			SEGMENT CODE
000425             0903   
000425             0904   ;			XDEF	VBLANK_INIT
000425             0905   ;			XDEF	VBLANK_STOP
000425             0906   ;			XDEF	VBLANK_HANDLER
000425             0907   
000425             0908   ;			XREF	ESCSET
000425             0909   ;			XREF	KEYDOWN		; In ram.asm
000425             0910   ;			XREF	KEYASCII 	; In ram.asm
000425             0911   ;			XREF	KEYCOUNT	; In ram.asm
000425             0912   
000425             0913   ; Hook into the MOS VBLANK interrupt
000425             0914   ;
000425 F3          0915   VBLANK_INIT:		DI
000426             0916   
000426 ED 6E       0917   			LD		A, MB 				; Get a 24-bit pointer to
000428 21 A3 04    0918   			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
00042B CD 65 04    0919   			CALL		SET_AHL16 			; address is a 16-bit pointer in BBC BASIC's segment
00042E             0920   
00042E 1E 32       0921   			LD		E, 32h				; Set up the VBlank Interrupt Vector
000430             0922   			MOSCALL		mos_setintvector
000430 3E 14       0001M1 			LD	A, function
000432 49 CF       0002M1 			RST.LIS	08h
000434             0923   
000434 5B E5       0924   			PUSH.LIL	HL				; HLU: Pointer to the MOS interrupt vector
000436 5B D1       0925   			POP.LIL		DE 				; DEU: Pointer to the MOS interrupt vector
000438             0926   
000438 21 BB 04    0927   			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
00043B ED 6E       0928   			LD		A, MB	 			; Get the segment BBC BASIC is running in
00043D 32 AC 04    0929   			LD		(VBLANK_HANDLER_MB + 1), A 	; Store in the interrupt handler
000440 CD 65 04    0930   			CALL		SET_AHL16 			; Convert pointer to an absolute 24-bit address
000443 5B ED 1F    0931   			LD.LIL		(HL), DE			; Self-modify the code
000446 FB          0932   			EI
000447 C9          0933   			RET
000448             0934   
000448             0935   ; Unhook the custom VBLANK interrupt
000448             0936   ;
000448 F3          0937   VBLANK_STOP:		DI
000449 21 BB 04    0938   			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
00044C 3A AC 04    0939   			LD		A, (VBLANK_HANDLER_MB + 1)	; The stored MB of the segment BBC BASIC is running in
00044F F5          0940   			PUSH		AF 				; Stack the MB for later
000450 CD 65 04    0941   			CALL		SET_AHL16			; Convert pointer to an absolute 24-bit address
000453 5B ED 17    0942   			LD.LIL		DE, (HL)			; DEU: Address of MOS interrupt vector
000456 5B D5       0943   			PUSH.LIL	DE				; Transfer to HL
000458 5B E1       0944   			POP.LIL		HL
00045A 1E 32       0945   			LD		E, 32h
00045C             0946   			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
00045C 3E 14       0001M1 			LD	A, function
00045E 49 CF       0002M1 			RST.LIS	08h
000460 F1          0947   			POP		AF 				; Restore MB to this segment
000461 ED 6D       0948   			LD		MB, A
000463 FB          0949   			EI
000464 C9          0950   			RET
000465             0951   
000465             0952   ; Set the MSB of HL (U) to A
000465             0953   ;
000465 5B E5       0954   SET_AHL16:		PUSH.LIL	HL
000467 5B 21 02 00 0955   			LD.LIL		HL, 2
       00          
00046C 5B 39       0956   			ADD.LIL		HL, SP
00046E 5B 77       0957   			LD.LIL		(HL), A
000470 5B E1       0958   			POP.LIL		HL
000472 C9          0959   			RET
000473             0960   
000473             0961   ; A safe LIS call to ESCSET
000473             0962   ;
000473             0963   DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
000473 3E 08       0001M1 			LD	A, function
000475 49 CF       0002M1 			RST.LIS	08h
000477 21 99 51    0964   			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
00047A 5B DD 7E 19 0965   			LD.LIL		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
00047E BE          0966   			CP 		(HL)				; with our local copy
00047F 20 09       0967   			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
000481             0968   ;
000481 AF          0969   DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
000482 32 98 51    0970   			LD		(KEYASCII), A
000485 32 97 51    0971   			LD		(KEYDOWN), A
000488 5B C9       0972   			RET.LIL 					; And return
00048A             0973   ;
00048A 77          0974   DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
00048B 5B DD 7E 18 0975   			LD.LIL		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
00048F B7          0976   			OR		A
000490 28 EF       0977   			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
000492             0978   ;
000492 32 97 51    0979   			LD		(KEYDOWN), A 			; Store the keydown value
000495 5B DD 7E 05 0980   			LD.LIL		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
000499 32 98 51    0981   			LD		(KEYASCII), A 			; Store locally
00049C FE 1B       0982   			CP		1Bh				; Is it escape?
00049E CC 18 06    0983   			CALL		Z, ESCSET			; Yes, so set the escape flags
0004A1 49 C9       0984   			RET.LIS						; Return to the interrupt handler
0004A3             0985   
0004A3             0986   ;
0004A3             0987   ; Interrupts in mixed mode always run in ADL mode
0004A3             0988   ;
0004A3             0989   			.ASSUME	ADL = 1
0004A3             0990   
0004A3 F3          0991   VBLANK_HANDLER:		DI
0004A4 F5          0992   			PUSH		AF
0004A5 E5          0993   			PUSH		HL
0004A6 DD E5       0994   			PUSH		IX
0004A8 ED 6E       0995   			LD		A, MB
0004AA F5          0996   			PUSH		AF
0004AB 3E 00       0997   VBLANK_HANDLER_MB:	LD		A, 0				; This is self-modified by VBLANK_INIT
0004AD ED 6D       0998   			LD		MB, A
0004AF 49 CD 73 04 0999   			CALL.LIS	DO_KEYBOARD
0004B3 F1          1000   			POP		AF
0004B4 ED 6D       1001   			LD		MB, A
0004B6 DD E1       1002   			POP		IX
0004B8 E1          1003   			POP		HL
0004B9 F1          1004   			POP		AF
0004BA             1005   ;
0004BA             1006   ; Finally jump to the MOS interrupt
0004BA             1007   ;
0004BA C3 00 00 00 1008   VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
0004BE             1009   ; --- End agon_interrupt.asm ---
0004BE             1010   
0004BE             1011   ; --- Begin agon_misc.asm ---
0004BE             1012   ;
0004BE             1013   ; Title:	BBC Basic for AGON - Miscellaneous helper functions
0004BE             1014   ; Author:	Dean Belfield
0004BE             1015   ; Created:	04/12/2024
0004BE             1016   ; Last Updated:	04/12/2024
0004BE             1017   ;
0004BE             1018   ; Modinfo:
0004BE             1019   
0004BE             1020   			; INCLUDE	"equs.inc"
0004BE             1021   			; INCLUDE	"macros.inc"
0004BE             1022   
0004BE             1023   			.ASSUME	ADL = 0
0004BE             1024   ;	.ORG 0x0000
0004BE             1025   
0004BE             1026   ;			SEGMENT CODE
0004BE             1027   
0004BE             1028   ;			XDEF	ASC_TO_NUMBER
0004BE             1029   ;			XDEF	SWITCH_A
0004BE             1030   ;			XDEF	NULLTOCR
0004BE             1031   ;			XDEF	CRTONULL
0004BE             1032   ;			XDEF	CSTR_FNAME
0004BE             1033   ;			XDEF	CSTR_LINE
0004BE             1034   ;			XDEF	CSTR_FINDCH
0004BE             1035   ;			XDEF	CSTR_ENDSWITH
0004BE             1036   ;			XDEF	CSTR_CAT
0004BE             1037   
0004BE             1038   ;			XREF	OSWRCH
0004BE             1039   ;			XREF	KEYWDS
0004BE             1040   ;			XREF	KEYWDL
0004BE             1041   
0004BE             1042   ; Read a number and convert to binary
0004BE             1043   ; If prefixed with &, will read as hex, otherwise decimal
0004BE             1044   ;   Inputs: HL: Pointer in string buffer
0004BE             1045   ;  Outputs: HL: Updated text pointer
0004BE             1046   ;           DE: Value
0004BE             1047   ;            A: Terminator (spaces skipped)
0004BE             1048   ; Destroys: A,D,E,H,L,F
0004BE             1049   ;
0004BE C5          1050   ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
0004BF 11 00 00    1051   			LD	DE, 0			; Initialise DE
0004C2 CD 02 05    1052   			CALL	SKIPSPmisc			; Skip whitespace
0004C5 7E          1053   			LD	A, (HL)			; Read first character
0004C6 FE 26       1054   			CP	'&'			; Is it prefixed with '&' (HEX number)?
0004C8 20 1E       1055   			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0004CA 23          1056   			INC	HL			; Otherwise fall through to ASC_TO_HEX
0004CB             1057   ;
0004CB 7E          1058   ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
0004CC CD 10 05    1059   			CALL    UPPRCmisc			; Convert to uppercase
0004CF D6 30       1060   			SUB	'0'			; Normalise to 0
0004D1 38 2E       1061   			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0004D3 FE 0A       1062   			CP 	10			; Check if >= 10
0004D5 38 06       1063   			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
0004D7 D6 07       1064   			SUB 	7			; Adjust ASCII A-F to nibble
0004D9 FE 10       1065   			CP 	16			; Check for > F
0004DB 30 24       1066   			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
0004DD EB          1067   ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
0004DE 29          1068   			ADD	HL, HL
0004DF 29          1069   			ADD	HL, HL
0004E0 29          1070   			ADD	HL, HL
0004E1 29          1071   			ADD	HL, HL
0004E2 EB          1072   			EX	DE, HL
0004E3 B3          1073   			OR      E			; OR the new digit in to the least significant nibble
0004E4 5F          1074   			LD      E, A
0004E5 23          1075   			INC     HL			; Onto the next character
0004E6 18 E3       1076   			JR      ASC_TO_NUMBER1		; And loop
0004E8             1077   ;
0004E8 7E          1078   ASC_TO_NUMBER3:		LD	A, (HL)
0004E9 D6 30       1079   			SUB	'0'			; Normalise to 0
0004EB 38 14       1080   			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0004ED FE 0A       1081   			CP	10			; Check if >= 10
0004EF 30 10       1082   			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
0004F1 EB          1083   			EX 	DE, HL 			; Stick DE in HL
0004F2 44          1084   			LD	B, H 			; And copy HL into BC
0004F3 4D          1085   			LD	C, L
0004F4 29          1086   			ADD	HL, HL 			; x 2
0004F5 29          1087   			ADD	HL, HL 			; x 4
0004F6 09          1088   			ADD	HL, BC 			; x 5
0004F7 29          1089   			ADD	HL, HL 			; x 10
0004F8 EB          1090   			EX	DE, HL
0004F9             1091   			ADD8U_DE 			; Add A to DE (macro)
0004F9 83          0001M1         ADD     A, E
0004FA 5F          0002M1         LD      E, A
0004FB 8A          0003M1         ADC     A, D
0004FC 93          0004M1         SUB     E
0004FD 57          0005M1         LD      D, A
0004FE 23          1092   			INC	HL
0004FF 18 E7       1093   			JR	ASC_TO_NUMBER3
000501 C1          1094   ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSP here
000502             1095   
000502             1096   ; Skip a space
000502             1097   ; HL: Pointer in string buffer
000502             1098   ;
000502 7E          1099   SKIPSPmisc:			LD      A, (HL)
000503 FE 20       1100   			CP      ' '
000505 C0          1101   			RET     NZ
000506 23          1102   			INC     HL
000507 18 F9       1103   			JR      SKIPSPmisc
000509             1104   
000509             1105   ; Skip a string
000509             1106   ; HL: Pointer in string buffer
000509             1107   ;
000509 7E          1108   SKIPNOTSP:		LD	A, (HL)
00050A FE 20       1109   			CP	' '
00050C C8          1110   			RET	Z
00050D 23          1111   			INC	HL
00050E 18 F9       1112   			JR	SKIPNOTSP
000510             1113   
000510             1114   ; Convert a character to upper case
000510             1115   ;  A: Character to convert
000510             1116   ;
000510 E6 7F       1117   UPPRCmisc:  		AND     7FH
000512 FE 60       1118   			CP      '`'
000514 D8          1119   			RET     C
000515 E6 5F       1120   			AND     5FH			; Convert to upper case
000517 C9          1121   			RET
000518             1122   
000518             1123   ; Switch on A - lookup table immediately after call
000518             1124   ;  A: Index into lookup table
000518             1125   ;
000518 E3          1126   SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
000519 87          1127   			ADD	A, A			; Multiply A by two
00051A             1128   			ADD8U_HL 			; Add to HL (macro)
00051A 85          0001M1         ADD     A, L
00051B 6F          0002M1         LD      L, A
00051C 8C          0003M1         ADC     A, H
00051D 95          0004M1         SUB     L
00051E 67          0005M1         LD      H, A
00051F 7E          1129   			LD	A, (HL)			; follow the call. Fetch an address from the
000520 23          1130   			INC	HL 			; table.
000521 66          1131   			LD	H, (HL)
000522 6F          1132   			LD	L, A
000523 E3          1133   			EX	(SP), HL		; Swap this new address back, restores HL
000524 C9          1134   			RET				; Return program control to this new address
000525             1135   
000525             1136   ; Convert the buffer to a null terminated string and back
000525             1137   ; HL: Buffer address
000525             1138   ;
000525 C5          1139   NULLTOCR:		PUSH 	BC
000526 06 00       1140   			LD	B, 0
000528 0E 0D       1141   			LD	C, CR
00052A 18 05       1142   			JR	CRTONULL0
00052C             1143   ;
00052C C5          1144   CRTONULL:		PUSH	BC
00052D 06 0D       1145   			LD	B, CR
00052F 0E 00       1146   			LD	C, 0
000531             1147   ;
000531 E5          1148   CRTONULL0:		PUSH	HL
000532 7E          1149   CRTONULL1:		LD	A, (HL)
000533 B8          1150   			CP 	B
000534 28 03       1151   			JR	Z, CRTONULL2
000536 23          1152   			INC	HL
000537 18 F9       1153   			JR	CRTONULL1
000539 71          1154   CRTONULL2:		LD	(HL), C
00053A E1          1155   			POP 	HL
00053B C1          1156   			POP	BC
00053C C9          1157   			RET
00053D             1158   
00053D             1159   ; Copy a filename to DE and zero terminate it
00053D             1160   ; HL: Source
00053D             1161   ; DE: Destination (ACCS)
00053D             1162   ;
00053D 7E          1163   CSTR_FNAME:		LD	A, (HL)			; Get source
00053E FE 20       1164   			CP	32			; Is it space
000540 28 09       1165   			JR	Z, @F
000542 FE 0D       1166   			CP	CR			; Or is it CR
000544 28 05       1167   			JR	Z, @F
000546 12          1168   			LD	(DE), A			; No, so store
000547 23          1169   			INC	HL			; Increment
000548 13          1170   			INC	DE
000549 18 F2       1171   			JR	CSTR_FNAME		; And loop
00054B AF          1172   @@:			XOR	A			; Zero terminate the target string
00054C 12          1173   			LD	(DE), A
00054D 13          1174   			INC	DE			; And point to next free address
00054E C9          1175   			RET
00054F             1176   
00054F             1177   ; Copy a CR terminated line to DE and zero terminate it
00054F             1178   ; HL: Source
00054F             1179   ; DE: Destination (ACCS)
00054F             1180   ;
00054F 7E          1181   CSTR_LINE:		LD	A, (HL)			; Get source
000550 FE 0D       1182   			CP	CR			; Is it CR
000552 28 05       1183   			JR	Z, @F
000554 12          1184   			LD	(DE), A			; No, so store
000555 23          1185   			INC	HL			; Increment
000556 13          1186   			INC	DE
000557 18 F6       1187   			JR	CSTR_LINE		; And loop
000559 AF          1188   @@:			XOR	A			; Zero terminate the target string
00055A 12          1189   			LD	(DE), A
00055B 13          1190   			INC	DE			; And point to next free address
00055C C9          1191   			RET
00055D             1192   
00055D             1193   ; Find the first occurrence of a character (case sensitive)
00055D             1194   ; HL: Source
00055D             1195   ;  C: Character to find
00055D             1196   ; Returns:
00055D             1197   ; HL: Pointer to character, or end of string marker
00055D             1198   ;
00055D 7E          1199   CSTR_FINDCH:		LD	A, (HL)			; Get source
00055E B9          1200   			CP	C			; Is it our character?
00055F C8          1201   			RET	Z			; Yes, so exit
000560 B7          1202   			OR	A			; Is it the end of string?
000561 C8          1203   			RET	Z			; Yes, so exit
000562 23          1204   			INC	HL
000563 18 F8       1205   			JR	CSTR_FINDCH
000565             1206   
000565             1207   ; Check whether a string ends with another string (case insensitive)
000565             1208   ; HL: Source
000565             1209   ; DE: The substring we want to test with
000565             1210   ; Returns:
000565             1211   ;  F: Z if HL ends with DE, otherwise NZ
000565             1212   ;
000565 7E          1213   CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
000566 CD 10 05    1214   			CALL	UPPRCmisc			; Convert to upper case
000569 4F          1215   			LD	C, A
00056A 1A          1216   			LD	A, (DE)			; Get the substring byte
00056B B9          1217   			CP	C
00056C C0          1218   			RET	NZ			; Return NZ if at any point the strings don't match
00056D B1          1219   			OR	C			; Check whether both bytes are zero
00056E C8          1220   			RET	Z			; If so, return, as we have reached the end of both strings
00056F 23          1221   			INC	HL
000570 13          1222   			INC	DE
000571 18 F2       1223   			JR	CSTR_ENDSWITH		; And loop
000573             1224   
000573             1225   ; Concatenate a string onto the end of another string
000573             1226   ; HL: Source
000573             1227   ; DE: Second string
000573             1228   ;
000573 7E          1229   CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
000574 B7          1230   			OR	A
000575 28 03       1231   			JR	Z, CSTR_CAT_1
000577 23          1232   			INC	HL
000578 18 F9       1233   			JR	CSTR_CAT
00057A             1234   ;
00057A 1A          1235   CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
00057B 77          1236   			LD	(HL), A
00057C B7          1237   			OR	A			; Check for end of string
00057D C8          1238   			RET	Z			; And return
00057E 23          1239   			INC	HL
00057F 13          1240   			INC	DE
000580 18 F8       1241   			JR	CSTR_CAT_1		; Loop until finished
000582             1242   ; --- End agon_misc.asm ---
000582             1243   
000582             1244   ; --- Begin agon_os.asm ---
000582             1245   ;
000582             1246   ; Title:	BBC Basic for AGON - MOS stuff
000582             1247   ; Author:	Dean Belfield
000582             1248   ; Created:	04/12/2024
000582             1249   ; Last Updated:	17/12/2024
000582             1250   ;
000582             1251   ; Modinfo:
000582             1252   ; 08/12/2024:	Added OSCLI and file I/O
000582             1253   ; 11/12/2024:	Added ESC key handling
000582             1254   ; 		Added OSWORD
000582             1255   ; 12/12/2024:	Added OSRDCH, OSBYTE_81 and fixed *EDIT
000582             1256   ; 17/12/2024:	Added OSWORD_01, OSWORD_02, OSWORD_0E, GET$(x,y), fixed INKEY, POS, VPOS and autoload
000582             1257   
000582             1258   			.ASSUME	ADL = 0
000582             1259   
000582             1260   			; INCLUDE	"equs.inc"
000582             1261   			; INCLUDE "macros.inc"
000582             1262   			; INCLUDE "mos_api.inc"	; In MOS/src
000582             1263   
000582             1264   			; SEGMENT CODE
000582             1265   
000582             1266   			; XDEF	OSWORD
000582             1267   			; XDEF	OSBYTE
000582             1268   			; XDEF	OSINIT
000582             1269   			; XDEF	OSOPEN
000582             1270   			; XDEF	OSSHUT
000582             1271   			; XDEF	OSLOAD
000582             1272   			; XDEF	OSSAVE
000582             1273   			; XDEF	OSLINE
000582             1274   			; XDEF	OSSTAT
000582             1275   			; XDEF	OSWRCH
000582             1276   			; XDEF	OSRDCH
000582             1277   			; XDEF	OSBGET
000582             1278   			; XDEF	OSBPUT
000582             1279   			; XDEF	OSCLI
000582             1280   			; XDEF	PROMPT
000582             1281   			; XDEF	GETPTR
000582             1282   			; XDEF	PUTPTR
000582             1283   			; XDEF	GETEXT
000582             1284   			; XDEF	TRAP
000582             1285   			; XDEF	LTRAP
000582             1286   			; XDEF	BYE
000582             1287   			; XDEF	RESET
000582             1288   			; XDEF	ESCSET
000582             1289   
000582             1290   			; XREF	EXTERR
000582             1291   			; XREF	VBLANK_INIT
000582             1292   			; XREF	VBLANK_STOP
000582             1293   			; XREF	USER
000582             1294   			; XREF	COUNT
000582             1295   			; XREF	COUNT0
000582             1296   			; XREF	COUNT1
000582             1297   			; XREF	GETCSR
000582             1298   			; XREF	GETSCHR_1
000582             1299   			; XREF	NULLTOCR
000582             1300   			; XREF	CRLF
000582             1301   			; XREF	FLAGS
000582             1302   			; XREF	OSWRCHPT
000582             1303   			; XREF	OSWRCHCH
000582             1304   			; XREF	OSWRCHFH
000582             1305   			; XREF	KEYASCII
000582             1306   			; XREF	KEYDOWN
000582             1307   			; XREF	LISTON
000582             1308   			; XREF	PAGE_
000582             1309   			; XREF	CSTR_FNAME
000582             1310   			; XREF	CSTR_FINDCH
000582             1311   			; XREF	CSTR_CAT
000582             1312   			; XREF	CSTR_ENDSWITH
000582             1313   			; XREF	CSTR_LINE
000582             1314   			; XREF	NEWIT
000582             1315   			; XREF	BAD
000582             1316   			; XREF	CLEAN
000582             1317   			; XREF	LINNUM
000582             1318   			; XREF	BUFFER
000582             1319   			; XREF	NXT
000582             1320   			; XREF	ERROR_
000582             1321   			; XREF	XEQ
000582             1322   			; XREF	LEXAN2
000582             1323   			; XREF	GETTOP
000582             1324   			; XREF	FINDL
000582             1325   			; XREF	DEL
000582             1326   			; XREF	LISTIT
000582             1327   			; XREF	ESCAPE
000582             1328   			; XREF	ASC_TO_NUMBER
000582             1329   			; XREF	CLOOP
000582             1330   			; XREF	SCRAP
000582             1331   			; XREF	POINT_
000582             1332   			; XREF	SOUND_
000582             1333   			; XREF	EXPRI
000582             1334   			; XREF	COMMA
000582             1335   			; XREF	BRAKET
000582             1336   			; XREF 	GETSCHR
000582             1337   			; XREF	ZERO
000582             1338   			; XREF	TRUE
000582             1339   
000582             1340   ;OSINIT - Initialise RAM mapping etc.
000582             1341   ;If BASIC is entered by BBCBASIC FILENAME then file
000582             1342   ;FILENAME.BBC is automatically CHAINed.
000582             1343   ;   Outputs: DE = initial value of HIMEM (top of RAM)
000582             1344   ;            HL = initial value of PAGE (user program)
000582             1345   ;            Z-flag reset indicates AUTO-RUN.
000582             1346   ;  Destroys: A,D,E,H,L,F
000582             1347   ;
000582 CD 25 04    1348   OSINIT:			CALL	VBLANK_INIT
000585 AF          1349   			XOR	A
000586 32 92 51    1350   			LD	(FLAGS), A		; Clear flags and set F = Z
000589 21 00 55    1351   			LD 	HL, USER
00058C 11 00 FF    1352   			LD	DE, RAM_Top
00058F 5F          1353   			LD	E, A			; Page boundary
000590 3A 00 52    1354   			LD	A, (ACCS)		; Return NZ if there is a file to chain
000593 B7          1355   			OR	A
000594 C9          1356   			RET
000595             1357   
000595             1358   ; PROMPT: output the input prompt
000595             1359   ;
000595 3E 3E       1360   PROMPT: 		LD	A,'>'			; Falls through to OSWRCH
000597             1361   
000597             1362   ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
000597             1363   ; Parameters:
000597             1364   ; - A: Character to write
000597             1365   ;
000597 E5          1366   OSWRCH:			PUSH	HL
000598 21 FE 54    1367   			LD	HL, LISTON		; Fetch the LISTON variable
00059B CB 5E       1368   			BIT	3, (HL)			; Check whether we are in *EDIT mode
00059D 20 0A       1369   			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
00059F             1370   ;
00059F 2A 95 51    1371   			LD	HL, (OSWRCHCH)		; L: Channel #
0005A2 2D          1372   			DEC	L			; If it is 1
0005A3 28 17       1373   			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0005A5             1374   ;
0005A5 E1          1375   			POP	HL			; Otherwise
0005A6 49 D7       1376   			RST.LIS	10h			; Output the character to MOS
0005A8 C9          1377   			RET
0005A9             1378   ;
0005A9 2A 93 51    1379   OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0005AC FE 0A       1380   			CP	0AH			; Just ignore this
0005AE 28 0A       1381   			JR	Z, OSWRCH_BUFFER2
0005B0 FE 0D       1382   			CP	0DH			; Is it the end of line?
0005B2 20 01       1383   			JR	NZ, OSWRCH_BUFFER1	; No, so carry on
0005B4 AF          1384   			XOR	A			; Turn it into a NUL character
0005B5 77          1385   OSWRCH_BUFFER1:		LD	(HL), A			; Echo the character into the buffer
0005B6 23          1386   			INC	HL			; Increment pointer
0005B7 22 93 51    1387   			LD	(OSWRCHPT), HL		; Write pointer back
0005BA E1          1388   OSWRCH_BUFFER2:		POP	HL
0005BB C9          1389   			RET
0005BC             1390   ;
0005BC D5          1391   OSWRCH_FILE:		PUSH	DE
0005BD 5C          1392   			LD	E, H			; Filehandle to E
0005BE CD 65 06    1393   			CALL	OSBPUT			; Write the byte out
0005C1 D1          1394   			POP	DE
0005C2 E1          1395   			POP	HL
0005C3 C9          1396   			RET
0005C4             1397   
0005C4             1398   ; OSRDCH
0005C4             1399   ;
0005C4 CD 8E 45    1400   OSRDCH:			CALL    NXT			; Check if we are doing GET$(x,y)
0005C7 FE 28       1401   			CP      '('
0005C9 28 09       1402   			JR	Z, @F 			; Yes, so skip to that functionality
0005CB             1403   			MOSCALL	mos_getkey		; Otherwise, read keyboard
0005CB 3E 00       0001M1 			LD	A, function
0005CD 49 CF       0002M1 			RST.LIS	08h
0005CF FE 1B       1404   			CP	1Bh
0005D1 28 6A       1405   			JR	Z, LTRAP1
0005D3 C9          1406   			RET
0005D4             1407   ;
0005D4 FD 23       1408   @@:			INC	IY			; Skip '('
0005D6 CD B6 18    1409   			CALL    EXPRI         	  	; Get the first parameter
0005D9 D9          1410   			EXX
0005DA E5          1411   			PUSH	HL
0005DB CD 25 21    1412   			CALL	COMMA			; Get the second parameter
0005DE CD B6 18    1413   			CALL	EXPRI
0005E1 D9          1414   			EXX
0005E2 D1          1415   			POP	DE 			; DE: X coordinate
0005E3 CD 31 21    1416   			CALL	BRAKET 			; Check for trailing bracket
0005E6 C3 BD 01    1417   			JP 	GETSCHR			; Read the character
0005E9             1418   
0005E9             1419   ; OSLINE: Invoke the line editor
0005E9             1420   ;
0005E9 1E 01       1421   OSLINE:			LD 	E, 1			; Default is to clear the buffer
0005EB             1422   
0005EB             1423   ; Entry point to line editor that does not clear the buffer
0005EB             1424   ; Parameters:
0005EB             1425   ; - HL: addresses destination buffer (on page boundary)
0005EB             1426   ; Returns:
0005EB             1427   ; -  A: 0
0005EB             1428   ; NB: Buffer filled, terminated by CR
0005EB             1429   ;
0005EB FD E5       1430   OSLINE1:		PUSH	IY
0005ED E5          1431   			PUSH	HL			; Buffer address
0005EE 01 00 01    1432   			LD	BC, 256			; Buffer length
0005F1             1433   			MOSCALL	mos_editline		; Call the MOS line editor
0005F1 3E 09       0001M1 			LD	A, function
0005F3 49 CF       0002M1 			RST.LIS	08h
0005F5 E1          1434   			POP	HL			; Pop the address
0005F6 FD E1       1435   			POP	IY
0005F8 F5          1436   			PUSH	AF			; Stack the return value (key pressed)
0005F9 CD 25 05    1437   			CALL	NULLTOCR		; Turn the 0 character to a CR
0005FC CD 7E 41    1438   			CALL	CRLF			; Display CRLF
0005FF F1          1439   			POP	AF
000600 FE 1B       1440   			CP	1Bh 			; Check if ESC terminated the input
000602 CA 3D 06    1441   			JP	Z, LTRAP1 		; Yes, so do the ESC thing
000605 3A 92 51    1442   			LD	A, (FLAGS)		; Otherwise
000608 CB BF       1443   			RES	7, A 			; Clear the escape flag
00060A 32 92 51    1444   			LD	(FLAGS), A
00060D CD 0E 0B    1445   			CALL	WAIT_VBLANK 		; Wait a frame
000610 AF          1446    			XOR	A			; Return A = 0
000611 32 97 51    1447   			LD	(KEYDOWN), A
000614 32 98 51    1448   			LD	(KEYASCII), A
000617 C9          1449   			RET
000618             1450   
000618             1451   ;
000618             1452   ; ESCSET
000618             1453   ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
000618             1454   ;
000618 E5          1455   ESCSET: 		PUSH    HL
000619 21 92 51    1456           		LD      HL,FLAGS		; Pointer to FLAGS
00061C CB 76       1457           		BIT     6,(HL)			; If bit 6 is set, then
00061E 20 02       1458           		JR      NZ,ESCDIS		; escape is disabled, so skip
000620 CB FE       1459           		SET     7,(HL)			; Set bit 7, the escape flag
000622 E1          1460   ESCDIS: 		POP     HL
000623 C9          1461           		RET
000624             1462   
000624             1463   ;
000624             1464   ; ESCTEST
000624             1465   ; Test for ESC key
000624             1466   ;
000624 CD 2D 06    1467   ESCTEST:		CALL	READKEY			; Read the keyboard
000627 C0          1468   			RET	NZ			; Skip if no key is pressed
000628 FE 1B       1469   			CP	1BH			; If ESC pressed then
00062A 28 EC       1470   			JR	Z,ESCSET		; jump to the escape set routine
00062C C9          1471   			RET
00062D             1472   
00062D             1473   ; Read the keyboard
00062D             1474   ; Returns:
00062D             1475   ; - A: ASCII of the pressed key
00062D             1476   ; - F: Z if the key is pressed, otherwise NZ
00062D             1477   ;
00062D 3A 97 51    1478   READKEY:		LD	A, (KEYDOWN)		; Get key down
000630 3D          1479   			DEC	A 			; Set Z flag if keydown is 1
000631 3A 98 51    1480   			LD	A, (KEYASCII)		; Get key ASCII value
000634 C9          1481   			RET
000635             1482   ;
000635             1483   ; TRAP
000635             1484   ; This is called whenever BASIC needs to check for ESC
000635             1485   ;
000635 CD 24 06    1486   TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
000638             1487   ;
000638 3A 92 51    1488   LTRAP:			LD	A,(FLAGS)		; Get FLAGS
00063B B7          1489   			OR	A			; This checks for bit 7; if it is not set then the result will
00063C F0          1490   			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
00063D 21 92 51    1491   LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
000640 CB BE       1492   			RES	7,(HL)			; Clear the escape pressed flag and
000642 C3 66 26    1493   			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
000645             1494   
000645             1495   ; RESET
000645             1496   ;
000645 C9          1497   RESET:			RET				; Yes this is fine
000646             1498   
000646             1499   ; OSOPEN
000646             1500   ; HL: Pointer to path
000646             1501   ;  F: C Z
000646             1502   ;     x x OPENIN
000646             1503   ; 	  OPENOUT
000646             1504   ;     x	  OPENUP
000646             1505   ; Returns:
000646             1506   ;  A: Filehandle, 0 if cannot open
000646             1507   ;
000646 0E 01       1508   OSOPEN:			LD	C, fa_read
000648 28 06       1509   			JR	Z, @F
00064A 0E 32       1510   			LD	C, fa_write | fa_open_append
00064C 38 02       1511   			JR	C, @F
00064E 0E 0A       1512   			LD	C, fa_write | fa_create_always
000650             1513   @@:			MOSCALL	mos_fopen
000650 3E 0A       0001M1 			LD	A, function
000652 49 CF       0002M1 			RST.LIS	08h
000654 C9          1514   			RET
000655             1515   
000655             1516   ;OSSHUT - Close disk file(s).
000655             1517   ; E = file channel
000655             1518   ;  If E=0 all files are closed (except SPOOL)
000655             1519   ; Destroys: A,B,C,D,E,H,L,F
000655             1520   ;
000655 C5          1521   OSSHUT:			PUSH	BC
000656 4B          1522   			LD	C, E
000657             1523   			MOSCALL	mos_fclose
000657 3E 0B       0001M1 			LD	A, function
000659 49 CF       0002M1 			RST.LIS	08h
00065B C1          1524   			POP	BC
00065C C9          1525   			RET
00065D             1526   
00065D             1527   ; OSBGET - Read a byte from a random disk file.
00065D             1528   ;  E = file channel
00065D             1529   ; Returns
00065D             1530   ;  A = byte read
00065D             1531   ;  Carry set if LAST BYTE of file
00065D             1532   ; Destroys: A,B,C,F
00065D             1533   ;
00065D C5          1534   OSBGET:			PUSH	BC
00065E 4B          1535   			LD	C, E
00065F             1536   			MOSCALL	mos_fgetc
00065F 3E 0C       0001M1 			LD	A, function
000661 49 CF       0002M1 			RST.LIS	08h
000663 C1          1537   			POP	BC
000664 C9          1538   			RET
000665             1539   
000665             1540   ; OSBPUT - Write a byte to a random disk file.
000665             1541   ;  E = file channel
000665             1542   ;  A = byte to write
000665             1543   ; Destroys: A,B,C,F
000665             1544   ;
000665 C5          1545   OSBPUT:			PUSH	BC
000666 4B          1546   			LD	C, E
000667 47          1547   			LD	B, A
000668             1548   			MOSCALL	mos_fputc
000668 3E 0D       0001M1 			LD	A, function
00066A 49 CF       0002M1 			RST.LIS	08h
00066C C1          1549   			POP	BC
00066D C9          1550   			RET
00066E             1551   
00066E             1552   ; OSSTAT - Read file status
00066E             1553   ;  E = file channel
00066E             1554   ; Returns
00066E             1555   ;  F: Z flag set - EOF
00066E             1556   ;  A: If Z then A = 0
00066E             1557   ; Destroys: A,D,E,H,L,F
00066E             1558   ;
00066E C5          1559   OSSTAT:			PUSH	BC
00066F 4B          1560   			LD	C, E
000670             1561   			MOSCALL	mos_feof
000670 3E 0E       0001M1 			LD	A, function
000672 49 CF       0002M1 			RST.LIS	08h
000674 C1          1562   			POP	BC
000675 FE 01       1563   			CP	1
000677 C9          1564   			RET
000678             1565   
000678             1566   ; GETPTR - Return file pointer.
000678             1567   ;    E = file channel
000678             1568   ; Returns:
000678             1569   ; DEHL = pointer (0-&7FFFFF)
000678             1570   ; Destroys: A,B,C,D,E,H,L,F
000678             1571   ;
000678 FD E5       1572   GETPTR:			PUSH		IY
00067A 4B          1573   			LD		C, E
00067B             1574   			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
00067B 3E 19       0001M1 			LD	A, function
00067D 49 CF       0002M1 			RST.LIS	08h
00067F 5B E5       1575   			PUSH.LIL	HL
000681 5B FD E1    1576   			POP.LIL		IY		; IYU: Pointer to FIL structure
000684 5B FD 6E 11 1577   			LD.LIL		L, (IY + FIL.fptr + 0)
000688 5B FD 66 12 1578   			LD.LIL		H, (IY + FIL.fptr + 1)
00068C 5B FD 5E 13 1579   			LD.LIL		E, (IY + FIL.fptr + 2)
000690 5B FD 56 14 1580   			LD.LIL		D, (IY + FIL.fptr + 3)
000694 FD E1       1581   			POP		IY
000696 C9          1582   			RET
000697             1583   
000697             1584   ; PUTPTR - Update file pointer.
000697             1585   ;    A = file channel
000697             1586   ; DEHL = new pointer (0-&7FFFFF)
000697             1587   ; Destroys: A,B,C,D,E,H,L,F
000697             1588   ;
000697 FD E5       1589   PUTPTR:			PUSH		IY
000699 4F          1590   			LD		C, A  		; C: Filehandle
00069A 5B E5       1591   			PUSH.LIL	HL
00069C 5B 21 02 00 1592   			LD.LIL		HL, 2
       00          
0006A1 5B 39       1593   			ADD.LIL		HL, SP
0006A3 5B 73       1594   			LD.LIL		(HL), E 	; 3rd byte of DWORD set to E
0006A5 5B E1       1595   			POP.LIL		HL
0006A7 5A          1596   			LD		E, D  		; 4th byte passed as E
0006A8             1597   			MOSCALL		mos_flseek
0006A8 3E 1C       0001M1 			LD	A, function
0006AA 49 CF       0002M1 			RST.LIS	08h
0006AC FD E1       1598   			POP		IY
0006AE C9          1599   			RET
0006AF             1600   
0006AF             1601   ; GETEXT - Find file size.
0006AF             1602   ;    E = file channel
0006AF             1603   ; Returns:
0006AF             1604   ; DEHL = file size (0-&800000)
0006AF             1605   ; Destroys: A,B,C,D,E,H,L,F
0006AF             1606   ;
0006AF FD E5       1607   GETEXT:			PUSH		IY
0006B1 4B          1608   			LD		C, E
0006B2             1609   			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0006B2 3E 19       0001M1 			LD	A, function
0006B4 49 CF       0002M1 			RST.LIS	08h
0006B6 5B E5       1610   			PUSH.LIL	HL
0006B8 5B FD E1    1611   			POP.LIL		IY		; IYU: Pointer to FIL structure
0006BB 5B FD 6E 24 1612   			LD.LIL		L, (IY + FIL.obj.objsize + 0)
0006BF 5B FD 66 25 1613   			LD.LIL		H, (IY + FIL.obj.objsize + 1)
0006C3 5B FD 5E 26 1614   			LD.LIL		E, (IY + FIL.obj.objsize + 2)
0006C7 5B FD 56 27 1615   			LD.LIL		D, (IY + FIL.obj.objsize + 3)
0006CB FD E1       1616   			POP		IY
0006CD C9          1617   			RET
0006CE             1618   
0006CE             1619   ;OSLOAD - Load an area of memory from a file.
0006CE             1620   ;   Inputs: HL addresses filename (CR terminated)
0006CE             1621   ;           DE = address at which to load
0006CE             1622   ;           BC = maximum allowed size (bytes)
0006CE             1623   ;  Outputs: Carry reset indicates no room for file.
0006CE             1624   ; Destroys: A,B,C,D,E,H,L,F
0006CE             1625   ;
0006CE C5          1626   OSLOAD:			PUSH	BC			; Stack the size
0006CF D5          1627   			PUSH	DE			; Stack the load address
0006D0 11 00 52    1628   			LD	DE, ACCS		; Buffer address for filename
0006D3 CD 3D 05    1629   			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0006D6 21 00 52    1630   			LD	HL, ACCS		; HL: Filename
0006D9 CD 17 08    1631   			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0006DC CD 28 08    1632   			CALL	EXT_HANDLER		; Get the default handler
0006DF D1          1633   			POP	DE			; Restore the load address
0006E0 C1          1634   			POP	BC			; Restore the size
0006E1 B7          1635   			OR	A
0006E2 CA A9 07    1636   			JP 	Z, OSLOAD_BBC
0006E5             1637   ;
0006E5             1638   ; Load the file in as a text file
0006E5             1639   ;
0006E5 AF          1640   OSLOAD_TXT:		XOR	A			; Set file attributes to read
0006E6 CD 46 06    1641   			CALL	OSOPEN			; Open the file
0006E9 5F          1642   			LD 	E, A 			; The filehandle
0006EA B7          1643   			OR	A
0006EB 3E 04       1644   			LD	A, 4			; File not found error
0006ED CA B1 07    1645   			JP	Z, OSERROR		; Jump to error handler
0006F0 CD C1 40    1646   			CALL	NEWIT			; Call NEW to clear the program space
0006F3             1647   ;
0006F3 21 00 52    1648   OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0006F6             1649   ;
0006F6             1650   ; First skip any whitespace (indents) at the beginning of the input
0006F6             1651   ;
0006F6 CD 5D 06    1652   @@:			CALL	OSBGET			; Read the byte into A
0006F9 38 1C       1653   			JR	C, OSLOAD_TXT3		; Is it EOF?
0006FB FE 0A       1654   			CP	LF 			; Is it LF?
0006FD 28 18       1655   			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0006FF FE 21       1656   			CP	21h			; Is it less than or equal to ASCII space?
000701 38 F3       1657   			JR	C, @B 			; Yes, so keep looping
000703 77          1658   			LD	(HL), A 		; Store the first character
000704 2C          1659   			INC	L
000705             1660   ;
000705             1661   ; Now read the rest of the line in
000705             1662   ;
000705 CD 5D 06    1663   OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
000708 38 26       1664   			JR	C, OSLOAD_TXT4		; Is it EOF?
00070A FE 20       1665   			CP	20h			; Skip if not an ASCII character
00070C 38 05       1666   			JR	C, @F
00070E 77          1667   			LD	(HL), A 		; Store in the input buffer
00070F 2C          1668   			INC	L			; Increment the buffer pointer
000710 CA 72 3F    1669   			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
000713 FE 0A       1670   @@:			CP	LF			; Check for LF
000715 20 EE       1671   			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
000717             1672   ;
000717             1673   ; Finally, handle EOL/EOF
000717             1674   ;
000717 36 0D       1675   OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
000719 7D          1676   			LD	A, L			; Check for minimum line length
00071A FE 02       1677   			CP	2			; If it is 2 characters or less (including CR)
00071C 38 08       1678   			JR	C, @F			; Then don't bother entering it
00071E D5          1679   			PUSH	DE			; Preserve the filehandle
00071F CD 3B 07    1680   			CALL	OSEDIT			; Enter the line in memory
000722 DC 9D 40    1681   			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
000725 D1          1682   			POP	DE
000726 CD 6E 06    1683   @@:			CALL	OSSTAT			; End of file?
000729 20 C8       1684   			JR	NZ, OSLOAD_TXT1		; No, so loop
00072B CD 55 06    1685   			CALL	OSSHUT			; Close the file
00072E 37          1686   			SCF				; Flag to BASIC that we're good
00072F C9          1687   			RET
000730             1688   ;
000730             1689   ; Special case for BASIC programs with no blank line at the end
000730             1690   ;
000730 FE 20       1691   OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
000732 38 05       1692   			JR	C, @F
000734 77          1693   			LD	(HL), A			; Store the character
000735 2C          1694   			INC	L
000736 CA 72 3F    1695   			JP	Z, BAD
000739 18 DC       1696   @@:			JR	OSLOAD_TXT3
00073B             1697   ;
00073B             1698   ; This bit enters the line into memory
00073B             1699   ; Also called from OSLOAD_TXT
00073B             1700   ; Returns:
00073B             1701   ; F: C if a new line has been entered (CLEAN will need to be called)
00073B             1702   ;
00073B AF          1703   OSEDIT:			XOR	A			; Entry point after *EDIT
00073C 32 FB 54    1704   			LD      (COUNT),A
00073F FD 21 00 52 1705   			LD      IY,ACCS
000743 CD 0D 44    1706   			CALL    LINNUM			; HL: The line number from the input buffer
000746 CD 8E 45    1707   			CALL    NXT			; Skip spaces
000749 7C          1708   			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
00074A B5          1709   			OR      L
00074B 28 00       1710   			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
00074D             1711   ;
00074D             1712   ; This bit does the lexical analysis and tokenisation
00074D             1713   ;
00074D 11 00 53    1714   LNZERO:			LD	DE,BUFFER
000750 0E 01       1715                   	LD	C,1			; LEFT MODE
000752 E5          1716                   	PUSH	HL
000753 CD 9B 44    1717                   	CALL	LEXAN2			; LEXICAL ANALYSIS
000756 E1          1718                   	POP	HL
000757 12          1719                   	LD	(DE),A			; TERMINATOR
000758 AF          1720                   	XOR	A
000759 47          1721                   	LD	B,A
00075A 4B          1722                   	LD	C,E			; BC=LINE LENGTH
00075B 13          1723                   	INC	DE
00075C 12          1724                   	LD	(DE),A			; ZERO NEXT
00075D 7C          1725                   	LD	A,H
00075E B5          1726                   	OR	L
00075F FD 21 00 53 1727                   	LD	IY,BUFFER		; FOR XEQ
000763 CA 1C 25    1728                   	JP	Z,XEQ			; DIRECT MODE
000766 C5          1729                   	PUSH	BC
000767 CD C6 41    1730                   	CALL	FINDL
00076A CC 6C 40    1731                   	CALL	Z,DEL
00076D C1          1732                   	POP	BC
00076E 79          1733                   	LD	A,C
00076F B7          1734                   	OR	A
000770 C8          1735                   	RET	Z
000771 C6 04       1736                   	ADD	A,4
000773 4F          1737                   	LD	C,A			; LENGTH INCLUSIVE
000774 D5          1738                   	PUSH	DE			; LINE NUMBER
000775 C5          1739                   	PUSH	BC			; SAVE LINE LENGTH
000776 EB          1740                   	EX	DE,HL
000777 C5          1741                   	PUSH	BC
000778 CD A8 40    1742                   	CALL	GETTOP
00077B C1          1743                   	POP	BC
00077C E5          1744                   	PUSH	HL
00077D 09          1745                   	ADD	HL,BC
00077E E5          1746                   	PUSH	HL
00077F 24          1747                   	INC	H
000780 AF          1748                   	XOR	A
000781 ED 72       1749                   	SBC	HL,SP
000783 E1          1750                   	POP	HL
000784 D2 C7 3F    1751                   	JP	NC,ERROR_		; "No room"
000787 E3          1752                   	EX	(SP),HL
000788 E5          1753                   	PUSH	HL
000789 23          1754                   	INC	HL
00078A B7          1755                   	OR	A
00078B ED 52       1756                   	SBC	HL,DE
00078D 44          1757                   	LD	B,H			; BC=AMOUNT TO MOVE
00078E 4D          1758                   	LD	C,L
00078F E1          1759                   	POP	HL
000790 D1          1760                   	POP	DE
000791 28 02       1761                   	JR	Z,ATENDos
000793 ED B8       1762                   	LDDR				; MAKE SPACE
000795 C1          1763   ATENDos:          	POP	BC			; LINE LENGTH
000796 D1          1764                   	POP	DE			; LINE NUMBER
000797 23          1765                   	INC	HL
000798 71          1766                   	LD	(HL),C			; STORE LENGTH
000799 23          1767                   	INC	HL
00079A 73          1768                   	LD	(HL),E			; STORE LINE NUMBER
00079B 23          1769                   	INC	HL
00079C 72          1770                   	LD	(HL),D
00079D 23          1771                   	INC	HL
00079E 11 00 53    1772                   	LD	DE,BUFFER
0007A1 EB          1773                   	EX	DE,HL
0007A2 0D          1774                   	DEC	C
0007A3 0D          1775                   	DEC	C
0007A4 0D          1776                   	DEC	C
0007A5 ED B0       1777                   	LDIR				; ADD LINE
0007A7 37          1778   			SCF
0007A8 C9          1779   			RET
0007A9             1780   ;
0007A9             1781   ; Load the file in as a tokenised binary blob
0007A9             1782   ;
0007A9             1783   OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
0007A9 3E 01       0001M1 			LD	A, function
0007AB 49 CF       0002M1 			RST.LIS	08h
0007AD D0          1784   			RET	NC			; If load returns with carry reset - NO ROOM
0007AE B7          1785   			OR	A			; If there is no error (A=0)
0007AF 37          1786   			SCF				; Need to set carry indicating there was room
0007B0 C8          1787   			RET	Z			; Return
0007B1             1788   ;
0007B1 F5          1789   OSERROR:		PUSH	AF			; Handle the MOS error
0007B2 21 00 52    1790   			LD	HL, ACCS		; Address of the buffer
0007B5 01 00 01    1791   			LD	BC, 256			; Length of the buffer
0007B8 5F          1792   			LD	E, A			; The error code
0007B9             1793   			MOSCALL	mos_getError		; Copy the error message into the buffer
0007B9 3E 0F       0001M1 			LD	A, function
0007BB 49 CF       0002M1 			RST.LIS	08h
0007BD F1          1794   			POP	AF
0007BE E5          1795   			PUSH	HL			; Stack the address of the error (now in ACCS)
0007BF C6 7F       1796   			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
0007C1 C3 D8 3F    1797   			JP	EXTERR			; Trigger an external error
0007C4             1798   
0007C4             1799   ;OSSAVE - Save an area of memory to a file.
0007C4             1800   ;   Inputs: HL addresses filename (term CR)
0007C4             1801   ;           DE = start address of data to save
0007C4             1802   ;           BC = length of data to save (bytes)
0007C4             1803   ; Destroys: A,B,C,D,E,H,L,F
0007C4             1804   ;
0007C4 C5          1805   OSSAVE:			PUSH	BC			; Stack the size
0007C5 D5          1806   			PUSH	DE			; Stack the save address
0007C6 11 00 52    1807   			LD	DE, ACCS		; Buffer address for filename
0007C9 CD 3D 05    1808   			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0007CC 21 00 52    1809   			LD	HL, ACCS		; HL: Filename
0007CF CD 17 08    1810   			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0007D2 CD 28 08    1811   			CALL	EXT_HANDLER		; Get the default handler
0007D5 D1          1812   			POP	DE			; Restore the save address
0007D6 C1          1813   			POP	BC			; Restore the size
0007D7 B7          1814   			OR	A			; Is the extension .BBC
0007D8 28 35       1815   			JR	Z, OSSAVE_BBC		; Yes, so use that
0007DA             1816   ;
0007DA             1817   ; Save the file out as a text file
0007DA             1818   ;
0007DA 3A 95 51    1819   OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0007DD F5          1820   			PUSH	AF
0007DE AF          1821   			XOR	A
0007DF 3C          1822   			INC	A			; Make sure C is clear, A is 1, for OPENOUT
0007E0 32 95 51    1823   			LD	(OSWRCHCH), A
0007E3 CD 46 06    1824   			CALL	OSOPEN			; Open the file
0007E6 32 96 51    1825   			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0007E9 DD 21 FE 54 1826   			LD	IX, LISTON		; Required for LISTIT
0007ED 2A DC 54    1827   			LD	HL, (PAGE_)		; Get start of program area
0007F0 D9          1828   			EXX
0007F1 01 00 00    1829   			LD	BC, 0			; Set the initial indent counters
0007F4 D9          1830   			EXX
0007F5 7E          1831   OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0007F6 B7          1832   			OR	A
0007F7 28 0A       1833   			JR	Z, OSSAVE_TXT2
0007F9 23          1834   			INC	HL			; Skip the length byte
0007FA 5E          1835   			LD	E, (HL)			; Get the line number
0007FB 23          1836   			INC	HL
0007FC 56          1837   			LD	D, (HL)
0007FD 23          1838   			INC	HL
0007FE CD E0 40    1839   			CALL	LISTIT			; List the line
000801 18 F2       1840   			JR	OSSAVE_TXT1
000803 3A 96 51    1841   OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
000806 5F          1842   			LD	E, A
000807 CD 55 06    1843   			CALL	OSSHUT			; Close it
00080A F1          1844   			POP	AF			; Restore the channel
00080B 32 95 51    1845   			LD	(OSWRCHCH), A
00080E C9          1846   			RET
00080F             1847   ;
00080F             1848   ; Save the file out as a tokenised binary blob
00080F             1849   ;
00080F             1850   OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
00080F 3E 02       0001M1 			LD	A, function
000811 49 CF       0002M1 			RST.LIS	08h
000813 B7          1851   			OR	A			; If there is no error (A=0)
000814 C8          1852   			RET	Z			; Just return
000815 18 9A       1853   			JR	OSERROR			; Trip an error
000817             1854   
000817             1855   ; Check if an extension is specified in the filename
000817             1856   ; Add a default if not specified
000817             1857   ; HL: Filename (CSTR format)
000817             1858   ;
000817 E5          1859   EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
000818 0E 2E       1860   			LD	C, '.'			; Search for dot (marks start of extension)
00081A CD 5D 05    1861   			CALL	CSTR_FINDCH
00081D B7          1862   			OR	A			; Check for end of string marker
00081E 20 06       1863   			JR	NZ, @F			; No, so skip as we have an extension at this point
000820 11 54 08    1864   			LD	DE, EXT_LOOKUP		; Get the first (default extension)
000823 CD 73 05    1865   			CALL	CSTR_CAT		; Concat it to string pointed to by HL
000826 E1          1866   @@:			POP	HL			; Restore the filename pointer
000827 C9          1867   			RET
000828             1868   
000828             1869   ; Check if an extension is valid and, if so, provide a pointer to a handler
000828             1870   ; HL: Filename (CSTR format)
000828             1871   ; Returns:
000828             1872   ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
000828             1873   ;
000828 E5          1874   EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
000829 0E 2E       1875   			LD	C, '.'			; Find the '.'
00082B CD 5D 05    1876   			CALL	CSTR_FINDCH
00082E 11 54 08    1877   			LD	DE, EXT_LOOKUP		; The lookup table
000831             1878   ;
000831 E5          1879   EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
000832 CD 65 05    1880   			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
000835 E1          1881   			POP	HL			; Restore the pointer to the extension
000836 28 18       1882   			JR	Z, EXT_HANDLER_2	; We have a match!
000838             1883   ;
000838 1A          1884   @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
000839 13          1885   			INC	DE
00083A B7          1886   			OR	A
00083B 20 FB       1887   			JR	NZ, @B
00083D 13          1888   			INC	DE			; Skip the file extension # byte
00083E             1889   ;
00083E 1A          1890   			LD	A, (DE)			; Are we at the end of the table?
00083F B7          1891   			OR	A
000840 20 EF       1892   			JR	NZ, EXT_HANDLER_1	; No, so loop
000842             1893   ;
000842 3E CC       1894   			LD      A,204			; Throw a "Bad name" error
000844 CD D8 3F    1895           		CALL    EXTERR
000847 42 61 64 20 1896           		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
000850             1897   ;
000850 13          1898   EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
000851 1A          1899   			LD	A, (DE)
000852 E1          1900   			POP	HL			; Restore the filename pointer
000853 C9          1901   			RET
000854             1902   
000854             1903   ; Extension lookup table
000854             1904   ; CSTR, TYPE
000854             1905   ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
000854             1906   ; 	- 1: Human readable plain text
000854             1907   ;
000854 2E 42 42 43 1908   EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
00085A 2E 54 58 54 1909   			DB	".TXT", 0, 1
       00 01       
000860 2E 41 53 43 1910   			DB	".ASC", 0, 1
       00 01       
000866 2E 42 41 53 1911   			DB	".BAS", 0, 1
       00 01       
00086C 00          1912   			DB	0			; End of table
00086D             1913   ; OSWORD
00086D             1914   ;
00086D FE 01       1915   OSWORD:			CP	01H			; GETIME
00086F 28 1C       1916   			JR	Z, OSWORD_01
000871 FE 02       1917   			CP	02H			; PUTIME
000873 28 2E       1918   			JR	Z, OSWORD_02
000875 FE 0E       1919   			CP	0EH			; GETIMS
000877 28 4E       1920   			JR	Z, OSWORD_0E
000879 FE 0F       1921   			CP	0FH			; PUTIMS
00087B 28 0F       1922   			JR	Z, @F
00087D FE 07       1923   			CP	07H			; SOUND
00087F 28 A0       1924   			JR	Z, OSWORD_07
