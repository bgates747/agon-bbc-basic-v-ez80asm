PC     Output      Line
040000             0001   ; --- Begin mos_api.inc ---
040000             0002   ;
040000             0003   ; Title:	AGON MOS - API for user projects
040000             0004   ; Author:	Dean Belfield
040000             0005   ; Created:	03/08/2022
040000             0006   ; Last Updated:	11/11/2023
040000             0007   ;
040000             0008   ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040000             0009   ;
040000             0010   ; Modinfo:
040000             0011   ; 05/08/2022:	Added mos_feof
040000             0012   ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0013   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0014   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0015   ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0016   ; 13/10/2022:	Added mos_oscli
040000             0017   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0018   ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0019   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0020   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0021   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0022   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0023   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0024   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0025   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0026   ; 19/05/2023:	Added sysvar_scrMode
040000             0027   ; 05/06/2023:	Added sysvar_rtcEnable
040000             0028   ; 03/08/2023:	Added mos_setkbvector
040000             0029   ; 10/08/2023:	Added mos_getkbmap
040000             0030   ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0031   ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040000             0032   ;
040000             0033   ; VDP control (VDU 23, 0, n)
040000             0034   ;
040000             0035   vdp_gp:			EQU 	80h
040000             0036   vdp_keycode:		EQU 	81h
040000             0037   vdp_cursor:		EQU	82h
040000             0038   vdp_scrchar:		EQU	83h
040000             0039   vdp_scrpixel:		EQU	84h
040000             0040   vdp_audio:		EQU	85h
040000             0041   vdp_mode:		EQU	86h
040000             0042   vdp_rtc:		EQU	87h
040000             0043   vdp_keystate:		EQU	88h
040000             0044   vdp_logicalcoords:	EQU	C0h
040000             0045   vdp_terminalmode:	EQU	FFh
040000             0046   
040000             0047   ; MOS high level functions
040000             0048   ;
040000             0049   mos_getkey:		EQU	00h
040000             0050   mos_load:		EQU	01h
040000             0051   mos_save:		EQU	02h
040000             0052   mos_cd:			EQU	03h
040000             0053   mos_dir:		EQU	04h
040000             0054   mos_del:		EQU	05h
040000             0055   mos_ren:		EQU	06h
040000             0056   mos_mkdir:		EQU	07h
040000             0057   mos_sysvars:		EQU	08h
040000             0058   mos_editline:		EQU	09h
040000             0059   mos_fopen:		EQU	0Ah
040000             0060   mos_fclose:		EQU	0Bh
040000             0061   mos_fgetc:		EQU	0Ch
040000             0062   mos_fputc:		EQU	0Dh
040000             0063   mos_feof:		EQU	0Eh
040000             0064   mos_getError:		EQU	0Fh
040000             0065   mos_oscli:		EQU	10h
040000             0066   mos_copy:		EQU	11h
040000             0067   mos_getrtc:		EQU	12h
040000             0068   mos_setrtc:		EQU	13h
040000             0069   mos_setintvector:	EQU	14h
040000             0070   mos_uopen:		EQU	15h
040000             0071   mos_uclose:		EQU	16h
040000             0072   mos_ugetc:		EQU	17h
040000             0073   mos_uputc:		EQU 	18h
040000             0074   mos_getfil:		EQU	19h
040000             0075   mos_fread:		EQU	1Ah
040000             0076   mos_fwrite:		EQU	1Bh
040000             0077   mos_flseek:		EQU	1Ch
040000             0078   mos_setkbvector:	EQU	1Dh
040000             0079   mos_getkbmap:		EQU	1Eh
040000             0080   mos_i2c_open:		EQU	1Fh
040000             0081   mos_i2c_close:		EQU	20h
040000             0082   mos_i2c_write:		EQU	21h
040000             0083   mos_i2c_read:		EQU	22h
040000             0084   
040000             0085   
040000             0086   ; FatFS file access functions
040000             0087   ;
040000             0088   ffs_fopen:		EQU	80h
040000             0089   ffs_fclose:		EQU	81h
040000             0090   ffs_fread:		EQU	82h
040000             0091   ffs_fwrite:		EQU	83h
040000             0092   ffs_flseek:		EQU	84h
040000             0093   ffs_ftruncate:		EQU	85h
040000             0094   ffs_fsync:		EQU	86h
040000             0095   ffs_fforward:		EQU	87h
040000             0096   ffs_fexpand:		EQU	88h
040000             0097   ffs_fgets:		EQU	89h
040000             0098   ffs_fputc:		EQU	8Ah
040000             0099   ffs_fputs:		EQU	8Bh
040000             0100   ffs_fprintf:		EQU	8Ch
040000             0101   ffs_ftell:		EQU	8Dh
040000             0102   ffs_feof:		EQU	8Eh
040000             0103   ffs_fsize:		EQU	8Fh
040000             0104   ffs_ferror:		EQU	90h
040000             0105   
040000             0106   ; FatFS directory access functions
040000             0107   ;
040000             0108   ffs_dopen:		EQU	91h
040000             0109   ffs_dclose:		EQU	92h
040000             0110   ffs_dread:		EQU	93h
040000             0111   ffs_dfindfirst:		EQU	94h
040000             0112   ffs_dfindnext:		EQU	95h
040000             0113   
040000             0114   ; FatFS file and directory management functions
040000             0115   ;
040000             0116   ffs_stat:		EQU	96h
040000             0117   ffs_unlink:		EQU	97h
040000             0118   ffs_rename:		EQU	98h
040000             0119   ffs_chmod:		EQU	99h
040000             0120   ffs_utime:		EQU	9Ah
040000             0121   ffs_mkdir:		EQU	9Bh
040000             0122   ffs_chdir:		EQU	9Ch
040000             0123   ffs_chdrive:		EQU	9Dh
040000             0124   ffs_getcwd:		EQU	9Eh
040000             0125   
040000             0126   ; FatFS volume management and system configuration functions
040000             0127   ;
040000             0128   ffs_mount:		EQU	9Fh
040000             0129   ffs_mkfs:		EQU	A0h
040000             0130   ffs_fdisk:		EQU	A1h
040000             0131   ffs_getfree:		EQU	A2h
040000             0132   ffs_getlabel:		EQU	A3h
040000             0133   ffs_setlabel:		EQU	A4h
040000             0134   ffs_setcp:		EQU	A5h
040000             0135   
040000             0136   ; File access modes
040000             0137   ;
040000             0138   fa_read:		EQU	01h
040000             0139   fa_write:		EQU	02h
040000             0140   fa_open_existing:	EQU	00h
040000             0141   fa_create_new:		EQU	04h
040000             0142   fa_create_always:	EQU	08h
040000             0143   fa_open_always:		EQU	10h
040000             0144   fa_open_append:		EQU	30h
040000             0145   
040000             0146   ; System variable indexes for api_sysvars
040000             0147   ; Index into _sysvars in globals.asm
040000             0148   ;
040000             0149   sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0150   sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0151   sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0152   sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0153   sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0154   sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0155   sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0156   sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0157   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0158   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0159   sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0160   sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0161   sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0162   sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0163   sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0164   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0165   sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0166   sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0167   sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0168   sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0169   sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0170   sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0171   sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0172   sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0173   sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0174   sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0175   sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0176   sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0177   sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0178   sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0179   sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0180   sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0181   ;
040000             0182   ; Flags for the VPD protocol
040000             0183   ;
040000             0184   vdp_pflag_cursor:	EQU	00000001b
040000             0185   vdp_pflag_scrchar:	EQU	00000010b
040000             0186   vdp_pflag_point:	EQU	00000100b
040000             0187   vdp_pflag_audio:	EQU	00001000b
040000             0188   vdp_pflag_mode:		EQU	00010000b
040000             0189   vdp_pflag_rtc:		EQU	00100000b
040000             0190   vdp_pflag_mouse:	EQU	01000000b
040000             0191   ; vdp_pflag_buffered:	EQU	10000000b
040000             0192   
040000             0193   
040000             0194   ; FatFS structures
040000             0195   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0196   ;
040000             0197   ; Object ID and allocation information (FFOBJID)
040000             0198   FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0199   FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0200   FFOBJID.attr:     EQU 5    ; Object attribute
040000             0201   FFOBJID.stat:     EQU 6    ; Object chain status
040000             0202   FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0203   FFOBJID.objsize:  EQU 11   ; Object size
040000             0204   FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0205   ;
040000             0206   ; File object structure (FIL)
040000             0207   ;
040000             0208   FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0209   FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0210   FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0211   FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0212   FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0213   FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0214   FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0215   FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0216   FIL.obj.objsize:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0217   ;
040000             0218   ; Directory object structure (DIR)
040000             0219   ;
040000             0220   DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0221   DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0222   DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0223   DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0224   DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0225   DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226   DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0227   DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0228   ;
040000             0229   ; File information structure (FILINFO)
040000             0230   ;
040000             0231   FILINFO.fsize:    EQU 0    ; File size
040000             0232   FILINFO.fdate:    EQU 4    ; Modified date
040000             0233   FILINFO.ftime:    EQU 6    ; Modified time
040000             0234   FILINFO.fattrib:  EQU 8    ; File attribute
040000             0235   FILINFO.altname:  EQU 9    ; Alternative file name
040000             0236   FILINFO.fname:    EQU 22   ; Primary file name
040000             0237   FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0238   ;
040000             0239   ; Macro for calling the API
040000             0240   ; Parameters:
040000             0241   ; - function: One of the function numbers listed above
040000             0242   ;
040000             0243   			MACRO MOSCALL	function
040000             0244   			LD	A, function
040000             0245   			RST.LIS	08h
040000             0246   			ENDMACRO 	; --- End mos_api.inc ---
040000             0247   
040000             0248   ; --- Begin equs.inc ---
040000             0249   ; ; TEMPORARY LABELS FOR PIECEMEAL ASSEMBLY
040000             0250   ; STAVAR: EQU 0
040000             0251   ; ACCS: EQU 0
040000             0252   ; ; END TEMPORARY LABELS FOR PIECEMEAL ASSEMBLY
040000             0253   
040000             0254   ;
040000             0255   ; Title:	BBC Basic for AGON - Equs
040000             0256   ; Author:	Dean Belfield
040000             0257   ; Created:	04/12/2024
040000             0258   ; Last Updated:	05/12/2024
040000             0259   ;
040000             0260   ; Modinfo:
040000             0261   ; 05/12/2024:	Removed Stack_Top
040000             0262   
040000             0263   ;			XREF		STAVAR
040000             0264   ;			XREF		ACCS
040000             0265   
040000             0266   RAM_Top:		EQU		0FF00h
040000             0267   
040000             0268   ; For GPIO
040000             0269   ; PA not available on eZ80L92
040000             0270   ;
040000             0271   PA_DR:			EQU		96h
040000             0272   PA_DDR:			EQU		97h
040000             0273   PA_ALT1:		EQU		98h
040000             0274   PA_ALT2:		EQU		99h
040000             0275   PB_DR:          	EQU		9Ah
040000             0276   PB_DDR:        	 	EQU		9Bh
040000             0277   PB_ALT1:        	EQU		9Ch
040000             0278   PB_ALT2:        	EQU		9Dh
040000             0279   PC_DR:          	EQU		9Eh
040000             0280   PC_DDR:         	EQU		9Fh
040000             0281   PC_ALT1:        	EQU		A0h
040000             0282   PC_ALT2:        	EQU		A1h
040000             0283   PD_DR:          	EQU		A2h
040000             0284   PD_DDR:			EQU		A3h
040000             0285   PD_ALT1:		EQU		A4h
040000             0286   PD_ALT2:		EQU		A5h
040000             0287   
040000             0288   GPIOMODE_OUT:		EQU		0	; Output
040000             0289   GPIOMODE_IN:		EQU		1	; Input
040000             0290   GPIOMODE_DIO:		EQU		2	; Open Drain IO
040000             0291   GPIOMODE_SIO:		EQU		3	; Open Source IO
040000             0292   GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040000             0293   GPIOMODE_ALTF:		EQU		5;	; Alt Function
040000             0294   GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040000             0295   GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040000             0296   GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040000             0297   GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040000             0298   
040000             0299   ; Originally in ram.asm
040000             0300   ;
040000             0301   ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%) ; back to data.asm
040000             0302   ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%) ; back to data.asm
040000             0303   ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands ; moved to data.asm
040000             0304   
040000             0305   ; Originally in main.asm
040000             0306   ;
040000             0307   CR:			EQU     0DH
040000             0308   LF:			EQU     0AH
040000             0309   ESC:			EQU     1BH
040000             0310   ; --- End equs.inc ---
040000             0311   
040000             0312   ; --- Begin macros.inc ---
040000             0313   ;
040000             0314   ; Title:	BBC Basic Interpreter - Z80 version
040000             0315   ;		Useful macros
040000             0316   ; Author:	Dean Belfield
040000             0317   ; Created:	04/12/2024
040000             0318   ; Last Updated:	04/12/2024
040000             0319   ;
040000             0320   ; Modinfo:
040000             0321   
040000             0322           MACRO EXREG rp1, rp2
040000             0323           PUSH    rp1
040000             0324           POP     rp2
040000             0325           ENDMACRO
040000             0326   
040000             0327           MACRO ADD8U_DE ; reg
040000             0328           ADD     A, E
040000             0329           LD      E, A
040000             0330           ADC     A, D
040000             0331           SUB     E
040000             0332           LD      D, A
040000             0333           ENDMACRO
040000             0334   
040000             0335           MACRO ADD8U_HL ; reg
040000             0336           ADD     A, L
040000             0337           LD      L, A
040000             0338           ADC     A, H
040000             0339           SUB     L
040000             0340           LD      H, A
040000             0341           ENDMACRO
040000             0342   
040000             0343           MACRO VDU VAL
040000             0344           LD      A, VAL
040000             0345           CALL    OSWRCH
040000             0346           ENDMACRO
040000             0347   
040000             0348           MACRO SET_GPIO REG, VAL
040000             0349           IN0     A, (REG)
040000             0350           OR      VAL
040000             0351           OUT0    (REG), A
040000             0352           ENDMACRO
040000             0353   
040000             0354           MACRO RES_GPIO REG, VAL
040000             0355           PUSH    BC
040000             0356           LD      A, VAL
040000             0357           CPL
040000             0358           LD      C, A
040000             0359           IN0     A, (REG)
040000             0360           AND     C
040000             0361           OUT0    (REG), A
040000             0362           POP     BC
040000             0363           ENDMACRO
040000             0364   ; --- End macros.inc ---
040000             0365   
040000             0366   ; --- Begin agon_init.asm ---
040000             0367   ;
040000             0368   ; Title:	BBC Basic for AGON - Initialisation Code
040000             0369   ;		Initialisation Code
040000             0370   ; Author:	Dean Belfield
040000             0371   ; Created:	04/12/2024
040000             0372   ; Last Updated:	14/12/2024
040000             0373   ;
040000             0374   ; Modinfo:
040000             0375   ; 14/12/2024:	Fix for *BYE command
040000             0376   
040000             0377   ;			SEGMENT __VECTORS
040000             0378   
040000             0379   ;			XREF	START
040000             0380   ;			XREF	ACCS
040000             0381   ;			XREF	TELL
040000             0382   
040000             0383   			.ASSUME	ADL = 0
040000             0384   			.ORG 0x0000
000000             0385   
000000             0386   			; INCLUDE	"equs.inc"
000000             0387   
000000             0388   argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
000000             0389   
000000             0390   ;
000000             0391   ; Start in mixed mode. Assumes MBASE is set to correct segment
000000             0392   ;
000000 C3 52 00    0393   			JP	_start				; Jump to start
000003             0394   			DS	5
000008             0395   
       FF FF FF FF 
       FF 
000008 49 CF       0396   RST_08:			RST.LIS	08h				; API call
00000A C9          0397   			RET
00000B             0398   			DS 	5
000010             0399   
       FF FF FF FF 
       FF 
000010 49 D7       0400   RST_10:			RST.LIS 10h				; Output
000012 C9          0401   			RET
000013             0402   			DS	5
000018             0403   
       FF FF FF FF 
       FF 
000018 49 DF       0404   RST_18:			RST.LIS	18h				; Block Output
00001A C9          0405   			RET
00001B             0406   			DS	5
000020             0407   
000020             0408   RST_20:			DS	8
000028             0409   RST_28:			DS	8
000030             0410   RST_30:			DS	8
000038             0411   
000038             0412   ;
000038             0413   ; The NMI interrupt vector (not currently used by AGON)
000038             0414   ;
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF 
000038 FB          0415   RST_38:			EI
000039 ED 4D       0416   			RETI
00003B             0417   ;
00003B             0418   ; The header stuff is from byte 64 onwards
00003B             0419   ;
00003B FF FF FF FF 0420   			ALIGN	64
       FF          
000040             0421   
000040 4D 4F 53    0422   			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
000043 00          0423   			DB	00h				; MOS header version 0
000044 00          0424   			DB	00h				; Flag for run mode (0: Z80, 1: ADL)
000045             0425   
000045 42 42 43 42 0426   _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
       41 53 49 43 
       2E 42 49 4E 
       00          
000052             0427   
000052             0428   ;
000052             0429   ; And the code follows on immediately after the header
000052             0430   ;
000052 5B FD E5    0431   _start:			PUSH.LIL	IY			; Preserve IY
000055             0432   
000055 FD 21 00 00 0433   			LD		IY, 0			; Preserve SPS
000059 FD 39       0434   			ADD		IY, SP
00005B 5B FD E5    0435   			PUSH.LIL	IY
00005E             0436   
00005E E3          0437   			EX		(SP), HL		; Get the SPS part of the return address
00005F 5B E5       0438   			PUSH.LIL	HL
000061 E3          0439   			EX		(SP), HL		; And restore it for BASIC
000062             0440   
000062 5B F5       0441   			PUSH.LIL	AF			; Preserve the rest of the registers
000064 5B C5       0442   			PUSH.LIL	BC
000066 5B D5       0443   			PUSH.LIL	DE
000068 5B DD E5    0444   			PUSH.LIL	IX
00006B             0445   
00006B ED 6E       0446   			LD		A, MB			; Segment base
00006D DD 21 65 01 0447   			LD		IX, argv_ptrs		; The argv array pointer address
000071 CD 51 01    0448   			CALL		_set_aix24		; Convert to a 24-bit address
000074 5B DD E5    0449   			PUSH.LIL	IX
000077 CD E1 00    0450   			CALL		_parse_params		; Parse the parameters
00007A 5B DD E1    0451   			POP.LIL		IX			; IX: argv
00007D 06 00       0452   			LD		B, 0			;  C: argc
00007F CD 9A 00    0453   			CALL		_main			; Start user code
000082             0454   
000082 5B DD E1    0455   			POP.LIL		IX			; Restore the registers
000085 5B D1       0456   			POP.LIL		DE
000087 5B C1       0457   			POP.LIL		BC
000089 5B F1       0458   			POP.LIL		AF
00008B             0459   
00008B EB          0460   			EX		DE, HL 			; DE: Return code from BASIC
00008C 5B E1       0461   			POP.LIL		HL 			; The SPS part of the return address
00008E 5B FD E1    0462   			POP.LIL		IY			; Get the preserved SPS
000091 FD F9       0463   			LD		SP, IY			; Restore SPS
000093 E3          0464   			EX		(SP), HL		; Store the SPS part of the return address on the stack
000094 EB          0465   			EX		DE, HL 			; HL: Return code from BASIC
000095             0466   
000095 5B FD E1    0467   			POP.LIL		IY			; Restore IY
000098 49 C9       0468   			RET.L					; Return to MOS
00009A             0469   
00009A             0470   ; The main routine
00009A             0471   ; IXU: argv - pointer to array of parameters
00009A             0472   ;   C: argc - number of parameters
00009A             0473   ; Returns:
00009A             0474   ;  HL: Error code, or 0 if OK
00009A             0475   ;
00009A 21 00 52    0476   _main:			LD	HL, ACCS		; Clear the ACCS
00009D 36 00       0477   			LD	(HL), 0
00009F 79          0478   			LD	A, C
0000A0 FE 02       0479   			CP	2
0000A2 28 24       0480   			JR	Z, _autoload		; 2 parameters = autoload
0000A4 38 35       0481   			JR	C, _startbasic		; 1 parameter = normal start
0000A6             0482   ;			CALL	STAR_VERSION		; Output the AGON version
0000A6 CD E0 44    0483   			CALL	TELL
0000A9 55 73 61 67 0484   			DB	"Usage:\n\r"
       65 3A 0A 0D 
0000B1 52 55 4E 20 0485   			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
0000C4 21 00 00    0486   			LD	HL, 0			; The error code
0000C7 C9          0487   			RET
0000C8             0488   ;
0000C8 5B DD 27 03 0489   _autoload:		LD.LIL	HL, (IX+3)		; HLU: Address of filename
0000CC 11 00 52    0490   			LD	DE, ACCS		;  DE: Destination address
0000CF 5B 7E       0491   @@:			LD.LIL	A, (HL)			; Fetch the filename byte
0000D1 12          0492   			LD	(DE), A			;
0000D2 5B 23       0493   			INC.LIL	HL			; Increase the source pointer
0000D4 1C          0494   			INC	E			; We only need to increase E as ACCS is on a page boundary
0000D5 20 F8       0495   			JR	NZ, @B			; Loop until we hit a 0 byte
0000D7 1D          0496   			DEC	E
0000D8 3E 0D       0497   			LD	A, CR
0000DA 12          0498   			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
0000DB             0499   ;
0000DB E1          0500   _startbasic:		POP	 HL			; Pop the return address to init off SPS
0000DC 5B E5       0501   			PUSH.LIL HL 			; Stack it on SPL (*BYE will use this as the return address)
0000DE C3 FD 36    0502   			JP	 START			; And start BASIC
0000E1             0503   
0000E1             0504   ; Parse the parameter string into a C array
0000E1             0505   ; Parameters
0000E1             0506   ; -   A: Segment base
0000E1             0507   ; - HLU: Address of parameter string
0000E1             0508   ; - IXU: Address for array pointer storage
0000E1             0509   ; Returns:
0000E1             0510   ; -   C: Number of parameters parsed
0000E1             0511   ;
0000E1 01 45 00    0512   _parse_params:		LD		BC, _exec_name		; Get the address of the app name in this segment
0000E4 CD 3F 01    0513   			CALL		_set_abc24		; Convert it to a 24-bit address based upon segment base
0000E7 5B DD 0F 00 0514   			LD.LIL		(IX+0), BC		; ARGV[0] = the executable name
0000EB 5B DD 23    0515   			INC.LIL		IX
0000EE 5B DD 23    0516   			INC.LIL		IX
0000F1 5B DD 23    0517   			INC.LIL		IX
0000F4 CD 36 01    0518   			CALL		_skip_spaces		; Skip HL past any leading spaces
0000F7             0519   ;
0000F7 01 01 00    0520   			LD		BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0000FA 06 0F       0521   			LD		B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0000FC             0522   ;
0000FC C5          0523   _parse_params_1:	PUSH		BC			; Stack ARGC
0000FD 5B E5       0524   			PUSH.LIL	HL			; Stack start address of token
0000FF CD 25 01    0525   			CALL		_get_token		; Get the next token
000102 79          0526   			LD		A, C			; A: Length of the token in characters
000103 5B D1       0527   			POP.LIL		DE			; Start address of token (was in HL)
000105 C1          0528   			POP		BC			; ARGC
000106 B7          0529   			OR		A			; Check for A=0 (no token found) OR at end of string
000107 C8          0530   			RET		Z
000108             0531   ;
000108 5B DD 1F 00 0532   			LD.LIL		(IX+0), DE		; Store the pointer to the token
00010C 5B E5       0533   			PUSH.LIL	HL			; DE=HL
00010E 5B D1       0534   			POP.LIL		DE
000110 CD 36 01    0535   			CALL		_skip_spaces		; And skip HL past any spaces onto the next character
000113 AF          0536   			XOR		A
000114 5B 12       0537   			LD.LIL		(DE), A			; Zero-terminate the token
000116 5B DD 23    0538   			INC.LIL		IX
000119 5B DD 23    0539   			INC.LIL		IX
00011C 5B DD 23    0540   			INC.LIL		IX			; Advance to next pointer position
00011F 0C          0541   			INC		C			; Increment ARGC
000120 79          0542   			LD		A, C			; Check for C >= A
000121 B8          0543   			CP		B
000122 38 D8       0544   			JR		C, _parse_params_1	; And loop
000124 C9          0545   			RET
000125             0546   
000125             0547   ; Get the next token
000125             0548   ; Parameters:
000125             0549   ; - HL: Address of parameter string
000125             0550   ; Returns:
000125             0551   ; - HL: Address of first character after token
000125             0552   ; -  C: Length of token (in characters)
000125             0553   ;
000125 0E 00       0554   _get_token:		LD		C, 0			; Initialise length
000127 5B 7E       0555   @@:			LD.LIL		A, (HL)			; Get the character from the parameter string
000129 B7          0556   			OR		A			; Exit if 0 (end of parameter string in MOS)
00012A C8          0557   			RET 		Z
00012B FE 0D       0558   			CP		13			; Exit if CR (end of parameter string in BBC BASIC)
00012D C8          0559   			RET		Z
00012E FE 20       0560   			CP		' '			; Exit if space (end of token)
000130 C8          0561   			RET		Z
000131 5B 23       0562   			INC.LIL		HL			; Advance to next character
000133 0C          0563   			INC 		C			; Increment length
000134 18 F1       0564   			JR		@B
000136             0565   
000136             0566   ; Skip spaces in the parameter string
000136             0567   ; Parameters:
000136             0568   ; - HL: Address of parameter string
000136             0569   ; Returns:
000136             0570   ; - HL: Address of next none-space character
000136             0571   ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
000136             0572   ;
000136 5B 7E       0573   _skip_spaces:		LD.LIL		A, (HL)			; Get the character from the parameter string
000138 FE 20       0574   			CP		' '			; Exit if not space
00013A C0          0575   			RET		NZ
00013B 5B 23       0576   			INC.LIL		HL			; Advance to next character
00013D 18 F7       0577   			JR		_skip_spaces		; Increment length
00013F             0578   
00013F             0579   ; Set the MSB of BC (U) to A
00013F             0580   ; Parameters:
00013F             0581   ; - BC: 16-bit address
00013F             0582   ; -  A: Value to stick in U of BC
00013F             0583   ; Returns:
00013F             0584   ; - BCU
00013F             0585   ;
00013F 5B E5       0586   _set_abc24:		PUSH.LIL	HL			; Preserve HL
000141 5B C5       0587   			PUSH.LIL	BC			; Stick BC onto SPL
000143 5B 21 02 00 0588   			LD.LIL		HL, 2			; HL: SP+2
       00          
000148 5B 39       0589   			ADD.LIL		HL, SP
00014A 5B 77       0590   			LD.LIL		(HL), A			; Store A in it
00014C 5B C1       0591   			POP.LIL		BC			; Fetch ammended BC
00014E 5B E1       0592   			POP.LIL		HL			; Restore HL
000150 C9          0593   			RET
000151             0594   
000151             0595   ; Set the MSB of BC (U) to A
000151             0596   ; Parameters:
000151             0597   ; - IX: 16-bit address
000151             0598   ; -  A: Value to stick in U of BC
000151             0599   ; Returns:
000151             0600   ; - IXU
000151             0601   ;
000151 5B DD E5    0602   _set_aix24:		PUSH.LIL	IX			; Stick IX onto SPL
000154 5B DD 21 02 0603   			LD.LIL		IX, 2			; IX: SP+2
       00 00       
00015A 5B DD 39    0604   			ADD.LIL		IX, SP
00015D 5B DD 77 00 0605   			LD.LIL		(IX), A			; Store A in it
000161 5B DD E1    0606   			POP.LIL		IX			; Fetch ammended IX
000164 C9          0607   			RET
000165             0608   
000165             0609   ; Storage for the argv array pointers
000165             0610   ;
000165 00 00 00 00 0611   argv_ptrs:		BLKP	argv_ptrs_max, 0		; Storage for the argv array pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
000195             0612   ; --- End agon_init.asm ---
000195             0613   
000195             0614   ; --- Begin agon_graphics.asm ---
000195             0615   ;
000195             0616   ; Title:	BBC Basic for AGON - Graphics stuff
000195             0617   ; Author:	Dean Belfield
000195             0618   ; Created:	04/12/2024
000195             0619   ; Last Updated:	17/12/2024
000195             0620   ;
000195             0621   ; Modinfo:
000195             0622   ; 11/12/2024:	Modified POINT_ to work with OSWORD
000195             0623   ; 17/12/2024:	Modified GETSCHR
000195             0624   
000195             0625   			.ASSUME	ADL = 0
000195             0626   
000195             0627   			; INCLUDE	"equs.inc"
000195             0628   			; INCLUDE "macros.inc"
000195             0629   			; INCLUDE "mos_api.inc"	; In MOS/src
000195             0630   
000195             0631   			; SEGMENT CODE
000195             0632   
000195             0633   			; XDEF	MODE_
000195             0634   			; XDEF	COLOUR_
000195             0635   			; XDEF	POINT_
000195             0636   			; XDEF	GETSCHR
000195             0637   
000195             0638   			; XREF	ACCS
000195             0639   			; XREF	OSWRCH
000195             0640   			; XREF	ASC_TO_NUMBER
000195             0641   			; XREF	EXTERR
000195             0642   			; XREF	EXPRI
000195             0643   			; XREF	COMMA
000195             0644   			; XREF	XEQ
000195             0645   			; XREF	NXT
000195             0646   			; XREF	BRAKET
000195             0647   			; XREF	CRTONULL
000195             0648   			; XREF	NULLTOCR
000195             0649   			; XREF	CRLF
000195             0650   			; XREF	EXPR_W2
000195             0651   
000195             0652   ; MODE n: Set video mode
000195             0653   ;
000195 DD E5       0654   MODE_:			PUSH	IX			; Get the system vars in IX
000197             0655   			MOSCALL	mos_sysvars		; Reset the semaphore
000197 3E 08       0001M1 			LD	A, function
000199 49 CF       0002M1 			RST.LIS	08h
00019B 5B DD CB 04 0656   			RES.LIL	4, (IX+sysvar_vpd_pflags)
       A6          
0001A0 CD 19 18    0657   			CALL    EXPRI
0001A3 D9          0658   			EXX
0001A4             0659   			VDU	16H			; Mode change
0001A4 3E 16       0001M1         LD      A, VAL
0001A6 CD 97 05    0002M1         CALL    OSWRCH
0001A9             0660   			VDU	L
0001A9 7D          0001M1         LD      A, VAL
0001AA CD 97 05    0002M1         CALL    OSWRCH
0001AD             0661   			MOSCALL	mos_sysvars
0001AD 3E 08       0001M1 			LD	A, function
0001AF 49 CF       0002M1 			RST.LIS	08h
0001B1 5B DD CB 04 0662   @@:			BIT.LIL	4, (IX+sysvar_vpd_pflags)
       66          
0001B6 28 F9       0663   			JR	Z, @B			; Wait for the result
0001B8 DD E1       0664   			POP	IX
0001BA C3 7F 24    0665   			JP	XEQ
0001BD             0666   
0001BD             0667   ;
0001BD             0668   ; Fetch a character from the screen
0001BD             0669   ; - DE: X coordinate
0001BD             0670   ; - HL: Y coordinate
0001BD             0671   ; Returns
0001BD             0672   ; - A: The character or FFh if no match
0001BD             0673   ; - F: C if match, otherwise NC
0001BD             0674   ;
0001BD DD E5       0675   GETSCHR:		PUSH	IX			; Get the system vars in IX
0001BF             0676   			MOSCALL	mos_sysvars		; Reset the semaphore
0001BF 3E 08       0001M1 			LD	A, function
0001C1 49 CF       0002M1 			RST.LIS	08h
0001C3 5B DD CB 04 0677   			RES.LIL	1, (IX+sysvar_vpd_pflags)
       8E          
0001C8             0678   			VDU	23
0001C8 3E 17       0001M1         LD      A, VAL
0001CA CD 97 05    0002M1         CALL    OSWRCH
0001CD             0679   			VDU	0
0001CD 3E 00       0001M1         LD      A, VAL
0001CF CD 97 05    0002M1         CALL    OSWRCH
0001D2             0680   			VDU	vdp_scrchar
0001D2 3E 83       0001M1         LD      A, VAL
0001D4 CD 97 05    0002M1         CALL    OSWRCH
0001D7             0681   			VDU	E
0001D7 7B          0001M1         LD      A, VAL
0001D8 CD 97 05    0002M1         CALL    OSWRCH
0001DB             0682   			VDU	D
0001DB 7A          0001M1         LD      A, VAL
0001DC CD 97 05    0002M1         CALL    OSWRCH
0001DF             0683   			VDU	L
0001DF 7D          0001M1         LD      A, VAL
0001E0 CD 97 05    0002M1         CALL    OSWRCH
0001E3             0684   			VDU	H
0001E3 7C          0001M1         LD      A, VAL
0001E4 CD 97 05    0002M1         CALL    OSWRCH
0001E7 5B DD CB 04 0685   @@:			BIT.LIL	1, (IX+sysvar_vpd_pflags)
       4E          
0001EC 28 F9       0686   			JR	Z, @B			; Wait for the result
0001EE 5B DD 7E 09 0687   			LD.LIL	A, (IX+sysvar_scrchar)	; Fetch the result in A
0001F2 B7          0688   			OR	A			; Check for 00h
0001F3 37          0689   			SCF				; C = character map
0001F4 20 01       0690   			JR	NZ, @F			; We have a character, so skip next bit
0001F6 AF          0691   			XOR	A			; Clear carry
0001F7 DD E1       0692   @@:			POP	IX
0001F9 C9          0693   			RET
0001FA             0694   
0001FA             0695   ; POINT(x,y): Get the pixel colour of a point on screen
0001FA             0696   ; Parameters:
0001FA             0697   ; - DE: X-coordinate
0001FA             0698   ; - HL: Y-coordinate
0001FA             0699   ; Returns:
0001FA             0700   ; -  A: Pixel colour
0001FA             0701   ;
0001FA DD E5       0702   POINT_:			PUSH	IX			; Get the system vars in IX
0001FC             0703   			MOSCALL	mos_sysvars		; Reset the semaphore
0001FC 3E 08       0001M1 			LD	A, function
0001FE 49 CF       0002M1 			RST.LIS	08h
000200 5B DD CB 04 0704   			RES.LIL	2, (IX+sysvar_vpd_pflags)
       96          
000205             0705   			VDU	23
000205 3E 17       0001M1         LD      A, VAL
000207 CD 97 05    0002M1         CALL    OSWRCH
00020A             0706   			VDU	0
00020A 3E 00       0001M1         LD      A, VAL
00020C CD 97 05    0002M1         CALL    OSWRCH
00020F             0707   			VDU	vdp_scrpixel
00020F 3E 84       0001M1         LD      A, VAL
000211 CD 97 05    0002M1         CALL    OSWRCH
000214             0708   			VDU	E
000214 7B          0001M1         LD      A, VAL
000215 CD 97 05    0002M1         CALL    OSWRCH
000218             0709   			VDU	D
000218 7A          0001M1         LD      A, VAL
000219 CD 97 05    0002M1         CALL    OSWRCH
00021C             0710   			VDU	L
00021C 7D          0001M1         LD      A, VAL
00021D CD 97 05    0002M1         CALL    OSWRCH
000220             0711   			VDU	H
000220 7C          0001M1         LD      A, VAL
000221 CD 97 05    0002M1         CALL    OSWRCH
000224 5B DD CB 04 0712   @@:			BIT.LIL	2, (IX+sysvar_vpd_pflags)
       56          
000229 28 F9       0713   			JR	Z, @B			; Wait for the result
00022B             0714   ;
00022B             0715   ; Return the data as a 1 byte index
00022B             0716   ;
00022B 5B DD 7E 16 0717   			LD.LIL	A, (IX+sysvar_scrpixelIndex)
00022F DD E1       0718   			POP	IX
000231 C9          0719   			RET
000232             0720   
000232             0721   ; COLOUR colour
000232             0722   ; COLOUR L,P
000232             0723   ; COLOUR L,R,G,B
000232             0724   ;
000232 CD 19 18    0725   COLOUR_:		CALL	EXPRI			; The colour / mode
000235 D9          0726   			EXX
000236 7D          0727   			LD	A, L
000237 32 00 52    0728   			LD	(VDU_BUFFER+0), A	; Store first parameter
00023A CD F1 44    0729   			CALL	NXT			; Are there any more parameters?
00023D FE 2C       0730   			CP	','
00023F 28 0E       0731   			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
000241             0732   ;
000241             0733   			VDU	11h			; Just set the colour
000241 3E 11       0001M1         LD      A, VAL
000243 CD 97 05    0002M1         CALL    OSWRCH
000246             0734   			VDU	(VDU_BUFFER+0)
000246 3A 00 52    0001M1         LD      A, VAL
000249 CD 97 05    0002M1         CALL    OSWRCH
00024C C3 7F 24    0735   			JP	XEQ
00024F             0736   ;
00024F CD 88 20    0737   COLOUR_1:		CALL	COMMA
000252 CD 19 18    0738   			CALL	EXPRI			; Parse R (OR P)
000255 D9          0739   			EXX
000256 7D          0740   			LD	A, L
000257 32 01 52    0741   			LD	(VDU_BUFFER+1), A
00025A CD F1 44    0742   			CALL	NXT			; Are there any more parameters?
00025D FE 2C       0743   			CP	','
00025F 28 23       0744   			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
000261             0745   ;
000261             0746   			VDU	13h			; VDU:COLOUR
000261 3E 13       0001M1         LD      A, VAL
000263 CD 97 05    0002M1         CALL    OSWRCH
000266             0747   			VDU	(VDU_BUFFER+0)		; Logical Colour
000266 3A 00 52    0001M1         LD      A, VAL
000269 CD 97 05    0002M1         CALL    OSWRCH
00026C             0748   			VDU	(VDU_BUFFER+1)		; Palette Colour
00026C 3A 01 52    0001M1         LD      A, VAL
00026F CD 97 05    0002M1         CALL    OSWRCH
000272             0749   			VDU	0			; RGB set to 0
000272 3E 00       0001M1         LD      A, VAL
000274 CD 97 05    0002M1         CALL    OSWRCH
000277             0750   			VDU	0
000277 3E 00       0001M1         LD      A, VAL
000279 CD 97 05    0002M1         CALL    OSWRCH
00027C             0751   			VDU	0
00027C 3E 00       0001M1         LD      A, VAL
00027E CD 97 05    0002M1         CALL    OSWRCH
000281 C3 7F 24    0752   			JP	XEQ
000284             0753   ;
000284 CD 88 20    0754   COLOUR_2:		CALL	COMMA
000287 CD 19 18    0755   			CALL	EXPRI			; Parse G
00028A D9          0756   			EXX
00028B 7D          0757   			LD	A, L
00028C 32 02 52    0758   			LD	(VDU_BUFFER+2), A
00028F CD 88 20    0759   			CALL	COMMA
000292 CD 19 18    0760   			CALL	EXPRI			; Parse B
000295 D9          0761   			EXX
000296 7D          0762   			LD	A, L
000297 32 03 52    0763   			LD	(VDU_BUFFER+3), A
00029A             0764   			VDU	13h			; VDU:COLOUR
00029A 3E 13       0001M1         LD      A, VAL
00029C CD 97 05    0002M1         CALL    OSWRCH
00029F             0765   			VDU	(VDU_BUFFER+0)		; Logical Colour
00029F 3A 00 52    0001M1         LD      A, VAL
0002A2 CD 97 05    0002M1         CALL    OSWRCH
0002A5             0766   			VDU	FFh			; Physical Colour (-1 for RGB mode)
0002A5 3E FF       0001M1         LD      A, VAL
0002A7 CD 97 05    0002M1         CALL    OSWRCH
0002AA             0767   			VDU	(VDU_BUFFER+1)		; R
0002AA 3A 01 52    0001M1         LD      A, VAL
0002AD CD 97 05    0002M1         CALL    OSWRCH
0002B0             0768   			VDU	(VDU_BUFFER+2)		; G
0002B0 3A 02 52    0001M1         LD      A, VAL
0002B3 CD 97 05    0002M1         CALL    OSWRCH
0002B6             0769   			VDU	(VDU_BUFFER+3)		; B
0002B6 3A 03 52    0001M1         LD      A, VAL
0002B9 CD 97 05    0002M1         CALL    OSWRCH
0002BC C3 7F 24    0770   			JP	XEQ; --- End agon_graphics.asm ---
0002BF             0771   
0002BF             0772   ; --- Begin agon_gpio.asm ---
0002BF             0773   ;
0002BF             0774   ; Title:	BBC Basic for AGON - GPIO functions
0002BF             0775   ; Author:	Dean Belfield
0002BF             0776   ; Created:	04/12/2024
0002BF             0777   ; Last Updated:	04/12/2024
0002BF             0778   ;
0002BF             0779   ; Modinfo:
0002BF             0780   
0002BF             0781   			; INCLUDE	"macros.inc"
0002BF             0782   			; INCLUDE	"equs.inc"
0002BF             0783   
0002BF             0784   			.ASSUME	ADL = 0
0002BF             0785   ;	.ORG 0x0000
0002BF             0786   
0002BF             0787   ;			SEGMENT CODE
0002BF             0788   
0002BF             0789   ;			XDEF	GPIOB_SETMODE
0002BF             0790   
0002BF             0791   ;			XREF	SWITCH_A
0002BF             0792   
0002BF             0793   ;  A: Mode
0002BF             0794   ;  B: Pins
0002BF             0795   ;
0002BF CD 18 05    0796   GPIOB_SETMODE:		CALL	SWITCH_A
0002C2 D6 02       0797   			DW	GPIOB_M0	; Output
0002C4 FB 02       0798   			DW	GPIOB_M1	; Input
0002C6 1B 03       0799   			DW	GPIOB_M2	; Open Drain IO
0002C8 3B 03       0800   			DW	GPIOB_M3	; Open Source IO
0002CA 56 03       0801   			DW	GPIOB_M4	; Interrupt, Dual Edge
0002CC 82 03       0802   			DW	GPIOB_M5	; Alt Function
0002CE 9D 03       0803   			DW	GPIOB_M6	; Interrupt, Active Low
0002D0 C4 03       0804   			DW	GPIOB_M7	; Interrupt, Active High
0002D2 E6 03       0805   			DW	GPIOB_M8	; Interrupt, Falling Edge
0002D4 08 04       0806   			DW	GPIOB_M9	; Interrupt, Rising Edge
0002D6             0807   
0002D6             0808   ; Output
0002D6             0809   ;
0002D6             0810   GPIOB_M0:		RES_GPIO PB_DDR,  B
0002D6 C5          0001M1         PUSH    BC
0002D7 78          0002M1         LD      A, VAL
0002D8 2F          0003M1         CPL
0002D9 4F          0004M1         LD      C, A
0002DA ED 38 9B    0005M1         IN0     A, (REG)
0002DD A1          0006M1         AND     C
0002DE ED 39 9B    0007M1         OUT0    (REG), A
0002E1 C1          0008M1         POP     BC
0002E2             0811   			RES_GPIO PB_ALT1, B
0002E2 C5          0001M1         PUSH    BC
0002E3 78          0002M1         LD      A, VAL
0002E4 2F          0003M1         CPL
0002E5 4F          0004M1         LD      C, A
0002E6 ED 38 9C    0005M1         IN0     A, (REG)
0002E9 A1          0006M1         AND     C
0002EA ED 39 9C    0007M1         OUT0    (REG), A
0002ED C1          0008M1         POP     BC
0002EE             0812   			RES_GPIO PB_ALT2, B
0002EE C5          0001M1         PUSH    BC
0002EF 78          0002M1         LD      A, VAL
0002F0 2F          0003M1         CPL
0002F1 4F          0004M1         LD      C, A
0002F2 ED 38 9D    0005M1         IN0     A, (REG)
0002F5 A1          0006M1         AND     C
0002F6 ED 39 9D    0007M1         OUT0    (REG), A
0002F9 C1          0008M1         POP     BC
0002FA C9          0813   			RET
0002FB             0814   
0002FB             0815   ; Input
0002FB             0816   ;
0002FB             0817   GPIOB_M1:		SET_GPIO PB_DDR,  B
0002FB ED 38 9B    0001M1         IN0     A, (REG)
0002FE B0          0002M1         OR      VAL
0002FF ED 39 9B    0003M1         OUT0    (REG), A
000302             0818   			RES_GPIO PB_ALT1, B
000302 C5          0001M1         PUSH    BC
000303 78          0002M1         LD      A, VAL
000304 2F          0003M1         CPL
000305 4F          0004M1         LD      C, A
000306 ED 38 9C    0005M1         IN0     A, (REG)
000309 A1          0006M1         AND     C
00030A ED 39 9C    0007M1         OUT0    (REG), A
00030D C1          0008M1         POP     BC
00030E             0819   			RES_GPIO PB_ALT2, B
00030E C5          0001M1         PUSH    BC
00030F 78          0002M1         LD      A, VAL
000310 2F          0003M1         CPL
000311 4F          0004M1         LD      C, A
000312 ED 38 9D    0005M1         IN0     A, (REG)
000315 A1          0006M1         AND     C
000316 ED 39 9D    0007M1         OUT0    (REG), A
000319 C1          0008M1         POP     BC
00031A C9          0820   			RET
00031B             0821   
00031B             0822   ; Open Drain IO
00031B             0823   ;
00031B             0824   GPIOB_M2:		RES_GPIO PB_DDR,  B
00031B C5          0001M1         PUSH    BC
00031C 78          0002M1         LD      A, VAL
00031D 2F          0003M1         CPL
00031E 4F          0004M1         LD      C, A
00031F ED 38 9B    0005M1         IN0     A, (REG)
000322 A1          0006M1         AND     C
000323 ED 39 9B    0007M1         OUT0    (REG), A
000326 C1          0008M1         POP     BC
000327             0825   			SET_GPIO PB_ALT1, B
000327 ED 38 9C    0001M1         IN0     A, (REG)
00032A B0          0002M1         OR      VAL
00032B ED 39 9C    0003M1         OUT0    (REG), A
00032E             0826   			RES_GPIO PB_ALT2, B
00032E C5          0001M1         PUSH    BC
00032F 78          0002M1         LD      A, VAL
000330 2F          0003M1         CPL
000331 4F          0004M1         LD      C, A
000332 ED 38 9D    0005M1         IN0     A, (REG)
000335 A1          0006M1         AND     C
000336 ED 39 9D    0007M1         OUT0    (REG), A
000339 C1          0008M1         POP     BC
00033A C9          0827   			RET
00033B             0828   
00033B             0829   ; Open Source IO
00033B             0830   ;
00033B             0831   GPIOB_M3:		SET_GPIO PB_DDR,  B
00033B ED 38 9B    0001M1         IN0     A, (REG)
00033E B0          0002M1         OR      VAL
00033F ED 39 9B    0003M1         OUT0    (REG), A
000342             0832   			SET_GPIO PB_ALT1, B
000342 ED 38 9C    0001M1         IN0     A, (REG)
000345 B0          0002M1         OR      VAL
000346 ED 39 9C    0003M1         OUT0    (REG), A
000349             0833   			RES_GPIO PB_ALT2, B
000349 C5          0001M1         PUSH    BC
00034A 78          0002M1         LD      A, VAL
00034B 2F          0003M1         CPL
00034C 4F          0004M1         LD      C, A
00034D ED 38 9D    0005M1         IN0     A, (REG)
000350 A1          0006M1         AND     C
000351 ED 39 9D    0007M1         OUT0    (REG), A
000354 C1          0008M1         POP     BC
000355 C9          0834   			RET
000356             0835   
000356             0836   ; Interrupt, Dual Edge
000356             0837   ;
000356             0838   GPIOB_M4:		SET_GPIO PB_DR,   B
000356 ED 38 9A    0001M1         IN0     A, (REG)
000359 B0          0002M1         OR      VAL
00035A ED 39 9A    0003M1         OUT0    (REG), A
00035D             0839   			RES_GPIO PB_DDR,  B
00035D C5          0001M1         PUSH    BC
00035E 78          0002M1         LD      A, VAL
00035F 2F          0003M1         CPL
000360 4F          0004M1         LD      C, A
000361 ED 38 9B    0005M1         IN0     A, (REG)
000364 A1          0006M1         AND     C
000365 ED 39 9B    0007M1         OUT0    (REG), A
000368 C1          0008M1         POP     BC
000369             0840   			RES_GPIO PB_ALT1, B
000369 C5          0001M1         PUSH    BC
00036A 78          0002M1         LD      A, VAL
00036B 2F          0003M1         CPL
00036C 4F          0004M1         LD      C, A
00036D ED 38 9C    0005M1         IN0     A, (REG)
000370 A1          0006M1         AND     C
000371 ED 39 9C    0007M1         OUT0    (REG), A
000374 C1          0008M1         POP     BC
000375             0841   			RES_GPIO PB_ALT2, B
000375 C5          0001M1         PUSH    BC
000376 78          0002M1         LD      A, VAL
000377 2F          0003M1         CPL
000378 4F          0004M1         LD      C, A
000379 ED 38 9D    0005M1         IN0     A, (REG)
00037C A1          0006M1         AND     C
00037D ED 39 9D    0007M1         OUT0    (REG), A
000380 C1          0008M1         POP     BC
000381 C9          0842   			RET
000382             0843   
000382             0844   ; Alt Function
000382             0845   ;
000382             0846   GPIOB_M5:		SET_GPIO PB_DDR,  B
000382 ED 38 9B    0001M1         IN0     A, (REG)
000385 B0          0002M1         OR      VAL
000386 ED 39 9B    0003M1         OUT0    (REG), A
000389             0847   			RES_GPIO PB_ALT1, B
000389 C5          0001M1         PUSH    BC
00038A 78          0002M1         LD      A, VAL
00038B 2F          0003M1         CPL
00038C 4F          0004M1         LD      C, A
00038D ED 38 9C    0005M1         IN0     A, (REG)
000390 A1          0006M1         AND     C
000391 ED 39 9C    0007M1         OUT0    (REG), A
000394 C1          0008M1         POP     BC
000395             0848   			SET_GPIO PB_ALT2, B
000395 ED 38 9D    0001M1         IN0     A, (REG)
000398 B0          0002M1         OR      VAL
000399 ED 39 9D    0003M1         OUT0    (REG), A
00039C C9          0849   			RET
00039D             0850   
00039D             0851   ; Interrupt, Active Low
00039D             0852   ;
00039D             0853   GPIOB_M6:		RES_GPIO PB_DR,   B
00039D C5          0001M1         PUSH    BC
00039E 78          0002M1         LD      A, VAL
00039F 2F          0003M1         CPL
0003A0 4F          0004M1         LD      C, A
0003A1 ED 38 9A    0005M1         IN0     A, (REG)
0003A4 A1          0006M1         AND     C
0003A5 ED 39 9A    0007M1         OUT0    (REG), A
0003A8 C1          0008M1         POP     BC
0003A9             0854   			RES_GPIO PB_DDR,  B
0003A9 C5          0001M1         PUSH    BC
0003AA 78          0002M1         LD      A, VAL
0003AB 2F          0003M1         CPL
0003AC 4F          0004M1         LD      C, A
0003AD ED 38 9B    0005M1         IN0     A, (REG)
0003B0 A1          0006M1         AND     C
0003B1 ED 39 9B    0007M1         OUT0    (REG), A
0003B4 C1          0008M1         POP     BC
0003B5             0855   			SET_GPIO PB_ALT1, B
0003B5 ED 38 9C    0001M1         IN0     A, (REG)
0003B8 B0          0002M1         OR      VAL
0003B9 ED 39 9C    0003M1         OUT0    (REG), A
0003BC             0856   			SET_GPIO PB_ALT2, B
0003BC ED 38 9D    0001M1         IN0     A, (REG)
0003BF B0          0002M1         OR      VAL
0003C0 ED 39 9D    0003M1         OUT0    (REG), A
0003C3 C9          0857   			RET
0003C4             0858   
0003C4             0859   
0003C4             0860   ; Interrupt, Active High
0003C4             0861   ;
0003C4             0862   GPIOB_M7:		SET_GPIO PB_DR,   B
0003C4 ED 38 9A    0001M1         IN0     A, (REG)
0003C7 B0          0002M1         OR      VAL
0003C8 ED 39 9A    0003M1         OUT0    (REG), A
0003CB             0863   			RES_GPIO PB_DDR,  B
0003CB C5          0001M1         PUSH    BC
0003CC 78          0002M1         LD      A, VAL
0003CD 2F          0003M1         CPL
0003CE 4F          0004M1         LD      C, A
0003CF ED 38 9B    0005M1         IN0     A, (REG)
0003D2 A1          0006M1         AND     C
0003D3 ED 39 9B    0007M1         OUT0    (REG), A
0003D6 C1          0008M1         POP     BC
0003D7             0864   			SET_GPIO PB_ALT1, B
0003D7 ED 38 9C    0001M1         IN0     A, (REG)
0003DA B0          0002M1         OR      VAL
0003DB ED 39 9C    0003M1         OUT0    (REG), A
0003DE             0865   			SET_GPIO PB_ALT2, B
0003DE ED 38 9D    0001M1         IN0     A, (REG)
0003E1 B0          0002M1         OR      VAL
0003E2 ED 39 9D    0003M1         OUT0    (REG), A
0003E5 C9          0866   			RET
0003E6             0867   
0003E6             0868   
0003E6             0869   ; Interrupt, Falling Edge
0003E6             0870   ;
0003E6             0871   GPIOB_M8:		RES_GPIO PB_DR,   B
0003E6 C5          0001M1         PUSH    BC
0003E7 78          0002M1         LD      A, VAL
0003E8 2F          0003M1         CPL
0003E9 4F          0004M1         LD      C, A
0003EA ED 38 9A    0005M1         IN0     A, (REG)
0003ED A1          0006M1         AND     C
0003EE ED 39 9A    0007M1         OUT0    (REG), A
0003F1 C1          0008M1         POP     BC
0003F2             0872   			SET_GPIO PB_DDR,  B
0003F2 ED 38 9B    0001M1         IN0     A, (REG)
0003F5 B0          0002M1         OR      VAL
0003F6 ED 39 9B    0003M1         OUT0    (REG), A
0003F9             0873   			SET_GPIO PB_ALT1, B
0003F9 ED 38 9C    0001M1         IN0     A, (REG)
0003FC B0          0002M1         OR      VAL
0003FD ED 39 9C    0003M1         OUT0    (REG), A
000400             0874   			SET_GPIO PB_ALT2, B
000400 ED 38 9D    0001M1         IN0     A, (REG)
000403 B0          0002M1         OR      VAL
000404 ED 39 9D    0003M1         OUT0    (REG), A
000407 C9          0875   			RET
000408             0876   
000408             0877   ; Interrupt, Rising Edge
000408             0878   ;
000408             0879   GPIOB_M9:		SET_GPIO PB_DR,   B
000408 ED 38 9A    0001M1         IN0     A, (REG)
00040B B0          0002M1         OR      VAL
00040C ED 39 9A    0003M1         OUT0    (REG), A
00040F             0880   			SET_GPIO PB_DDR,  B
00040F ED 38 9B    0001M1         IN0     A, (REG)
000412 B0          0002M1         OR      VAL
000413 ED 39 9B    0003M1         OUT0    (REG), A
000416             0881   			SET_GPIO PB_ALT1, B
000416 ED 38 9C    0001M1         IN0     A, (REG)
000419 B0          0002M1         OR      VAL
00041A ED 39 9C    0003M1         OUT0    (REG), A
00041D             0882   			SET_GPIO PB_ALT2, B
00041D ED 38 9D    0001M1         IN0     A, (REG)
000420 B0          0002M1         OR      VAL
000421 ED 39 9D    0003M1         OUT0    (REG), A
000424 C9          0883   			RET
000425             0884   ; --- End agon_gpio.asm ---
000425             0885   
000425             0886   ; --- Begin agon_interrupt.asm ---
000425             0887   ;
000425             0888   ; Title:	BBC Basic for AGON - Interrupts
000425             0889   ; Author:	Dean Belfield
000425             0890   ; Created:	04/12/2024
000425             0891   ; Last Updated:	04/12/2024
000425             0892   ;
000425             0893   ; Modinfo:
000425             0894   
000425             0895   			.ASSUME	ADL = 0
000425             0896   ;	.ORG 0x0000
000425             0897   
000425             0898   			; INCLUDE	"macros.inc"
000425             0899   			; INCLUDE	"equs.inc"
000425             0900   			; INCLUDE "mos_api.inc"	; In MOS/src
000425             0901   
000425             0902   ;			SEGMENT CODE
000425             0903   
000425             0904   ;			XDEF	VBLANK_INIT
000425             0905   ;			XDEF	VBLANK_STOP
000425             0906   ;			XDEF	VBLANK_HANDLER
000425             0907   
000425             0908   ;			XREF	ESCSET
000425             0909   ;			XREF	KEYDOWN		; In ram.asm
000425             0910   ;			XREF	KEYASCII 	; In ram.asm
000425             0911   ;			XREF	KEYCOUNT	; In ram.asm
000425             0912   
000425             0913   ; Hook into the MOS VBLANK interrupt
000425             0914   ;
000425 F3          0915   VBLANK_INIT:		DI
000426             0916   
000426 ED 6E       0917   			LD		A, MB 				; Get a 24-bit pointer to
000428 21 A3 04    0918   			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
00042B CD 65 04    0919   			CALL		SET_AHL16 			; address is a 16-bit pointer in BBC BASIC's segment
00042E             0920   
00042E 1E 32       0921   			LD		E, 32h				; Set up the VBlank Interrupt Vector
000430             0922   			MOSCALL		mos_setintvector
000430 3E 14       0001M1 			LD	A, function
000432 49 CF       0002M1 			RST.LIS	08h
000434             0923   
000434 5B E5       0924   			PUSH.LIL	HL				; HLU: Pointer to the MOS interrupt vector
000436 5B D1       0925   			POP.LIL		DE 				; DEU: Pointer to the MOS interrupt vector
000438             0926   
000438 21 BB 04    0927   			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
00043B ED 6E       0928   			LD		A, MB	 			; Get the segment BBC BASIC is running in
00043D 32 AC 04    0929   			LD		(VBLANK_HANDLER_MB + 1), A 	; Store in the interrupt handler
000440 CD 65 04    0930   			CALL		SET_AHL16 			; Convert pointer to an absolute 24-bit address
000443 5B ED 1F    0931   			LD.LIL		(HL), DE			; Self-modify the code
000446 FB          0932   			EI
000447 C9          0933   			RET
000448             0934   
000448             0935   ; Unhook the custom VBLANK interrupt
000448             0936   ;
000448 F3          0937   VBLANK_STOP:		DI
000449 21 BB 04    0938   			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
00044C 3A AC 04    0939   			LD		A, (VBLANK_HANDLER_MB + 1)	; The stored MB of the segment BBC BASIC is running in
00044F F5          0940   			PUSH		AF 				; Stack the MB for later
000450 CD 65 04    0941   			CALL		SET_AHL16			; Convert pointer to an absolute 24-bit address
000453 5B ED 17    0942   			LD.LIL		DE, (HL)			; DEU: Address of MOS interrupt vector
000456 5B D5       0943   			PUSH.LIL	DE				; Transfer to HL
000458 5B E1       0944   			POP.LIL		HL
00045A 1E 32       0945   			LD		E, 32h
00045C             0946   			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
00045C 3E 14       0001M1 			LD	A, function
00045E 49 CF       0002M1 			RST.LIS	08h
000460 F1          0947   			POP		AF 				; Restore MB to this segment
000461 ED 6D       0948   			LD		MB, A
000463 FB          0949   			EI
000464 C9          0950   			RET
000465             0951   
000465             0952   ; Set the MSB of HL (U) to A
000465             0953   ;
000465 5B E5       0954   SET_AHL16:		PUSH.LIL	HL
000467 5B 21 02 00 0955   			LD.LIL		HL, 2
       00          
00046C 5B 39       0956   			ADD.LIL		HL, SP
00046E 5B 77       0957   			LD.LIL		(HL), A
000470 5B E1       0958   			POP.LIL		HL
000472 C9          0959   			RET
000473             0960   
000473             0961   ; A safe LIS call to ESCSET
000473             0962   ;
000473             0963   DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
000473 3E 08       0001M1 			LD	A, function
000475 49 CF       0002M1 			RST.LIS	08h
000477 21 FC 50    0964   			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
00047A 5B DD 7E 19 0965   			LD.LIL		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
00047E BE          0966   			CP 		(HL)				; with our local copy
00047F 20 09       0967   			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
000481             0968   ;
000481 AF          0969   DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
000482 32 FB 50    0970   			LD		(KEYASCII), A
000485 32 FA 50    0971   			LD		(KEYDOWN), A
000488 5B C9       0972   			RET.LIL 					; And return
00048A             0973   ;
00048A 77          0974   DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
00048B 5B DD 7E 18 0975   			LD.LIL		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
00048F B7          0976   			OR		A
000490 28 EF       0977   			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
000492             0978   ;
000492 32 FA 50    0979   			LD		(KEYDOWN), A 			; Store the keydown value
000495 5B DD 7E 05 0980   			LD.LIL		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
000499 32 FB 50    0981   			LD		(KEYASCII), A 			; Store locally
00049C FE 1B       0982   			CP		1Bh				; Is it escape?
00049E CC FC 05    0983   			CALL		Z, ESCSET			; Yes, so set the escape flags
0004A1 49 C9       0984   			RET.LIS						; Return to the interrupt handler
0004A3             0985   
0004A3             0986   ;
0004A3             0987   ; Interrupts in mixed mode always run in ADL mode
0004A3             0988   ;
0004A3             0989   			.ASSUME	ADL = 1
0004A3             0990   
0004A3 F3          0991   VBLANK_HANDLER:		DI
0004A4 F5          0992   			PUSH		AF
0004A5 E5          0993   			PUSH		HL
0004A6 DD E5       0994   			PUSH		IX
0004A8 ED 6E       0995   			LD		A, MB
0004AA F5          0996   			PUSH		AF
0004AB 3E 00       0997   VBLANK_HANDLER_MB:	LD		A, 0				; This is self-modified by VBLANK_INIT
0004AD ED 6D       0998   			LD		MB, A
0004AF 49 CD 73 04 0999   			CALL.LIS	DO_KEYBOARD
0004B3 F1          1000   			POP		AF
0004B4 ED 6D       1001   			LD		MB, A
0004B6 DD E1       1002   			POP		IX
0004B8 E1          1003   			POP		HL
0004B9 F1          1004   			POP		AF
0004BA             1005   ;
0004BA             1006   ; Finally jump to the MOS interrupt
0004BA             1007   ;
0004BA C3 00 00 00 1008   VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
0004BE             1009   ; --- End agon_interrupt.asm ---
0004BE             1010   
0004BE             1011   ; --- Begin agon_misc.asm ---
0004BE             1012   ;
0004BE             1013   ; Title:	BBC Basic for AGON - Miscellaneous helper functions
0004BE             1014   ; Author:	Dean Belfield
0004BE             1015   ; Created:	04/12/2024
0004BE             1016   ; Last Updated:	04/12/2024
0004BE             1017   ;
0004BE             1018   ; Modinfo:
0004BE             1019   
0004BE             1020   			; INCLUDE	"equs.inc"
0004BE             1021   			; INCLUDE	"macros.inc"
0004BE             1022   
0004BE             1023   			.ASSUME	ADL = 0
0004BE             1024   ;	.ORG 0x0000
0004BE             1025   
0004BE             1026   ;			SEGMENT CODE
0004BE             1027   
0004BE             1028   ;			XDEF	ASC_TO_NUMBER
0004BE             1029   ;			XDEF	SWITCH_A
0004BE             1030   ;			XDEF	NULLTOCR
0004BE             1031   ;			XDEF	CRTONULL
0004BE             1032   ;			XDEF	CSTR_FNAME
0004BE             1033   ;			XDEF	CSTR_LINE
0004BE             1034   ;			XDEF	CSTR_FINDCH
0004BE             1035   ;			XDEF	CSTR_ENDSWITH
0004BE             1036   ;			XDEF	CSTR_CAT
0004BE             1037   
0004BE             1038   ;			XREF	OSWRCH
0004BE             1039   ;			XREF	KEYWDS
0004BE             1040   ;			XREF	KEYWDL
0004BE             1041   
0004BE             1042   ; Read a number and convert to binary
0004BE             1043   ; If prefixed with &, will read as hex, otherwise decimal
0004BE             1044   ;   Inputs: HL: Pointer in string buffer
0004BE             1045   ;  Outputs: HL: Updated text pointer
0004BE             1046   ;           DE: Value
0004BE             1047   ;            A: Terminator (spaces skipped)
0004BE             1048   ; Destroys: A,D,E,H,L,F
0004BE             1049   ;
0004BE C5          1050   ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
0004BF 11 00 00    1051   			LD	DE, 0			; Initialise DE
0004C2 CD 02 05    1052   			CALL	SKIPSPmisc			; Skip whitespace
0004C5 7E          1053   			LD	A, (HL)			; Read first character
0004C6 FE 26       1054   			CP	'&'			; Is it prefixed with '&' (HEX number)?
0004C8 20 1E       1055   			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0004CA 23          1056   			INC	HL			; Otherwise fall through to ASC_TO_HEX
0004CB             1057   ;
0004CB 7E          1058   ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
0004CC CD 10 05    1059   			CALL    UPPRCmisc			; Convert to uppercase
0004CF D6 30       1060   			SUB	'0'			; Normalise to 0
0004D1 38 2E       1061   			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0004D3 FE 0A       1062   			CP 	10			; Check if >= 10
0004D5 38 06       1063   			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
0004D7 D6 07       1064   			SUB 	7			; Adjust ASCII A-F to nibble
0004D9 FE 10       1065   			CP 	16			; Check for > F
0004DB 30 24       1066   			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
0004DD EB          1067   ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
0004DE 29          1068   			ADD	HL, HL
0004DF 29          1069   			ADD	HL, HL
0004E0 29          1070   			ADD	HL, HL
0004E1 29          1071   			ADD	HL, HL
0004E2 EB          1072   			EX	DE, HL
0004E3 B3          1073   			OR      E			; OR the new digit in to the least significant nibble
0004E4 5F          1074   			LD      E, A
0004E5 23          1075   			INC     HL			; Onto the next character
0004E6 18 E3       1076   			JR      ASC_TO_NUMBER1		; And loop
0004E8             1077   ;
0004E8 7E          1078   ASC_TO_NUMBER3:		LD	A, (HL)
0004E9 D6 30       1079   			SUB	'0'			; Normalise to 0
0004EB 38 14       1080   			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0004ED FE 0A       1081   			CP	10			; Check if >= 10
0004EF 30 10       1082   			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
0004F1 EB          1083   			EX 	DE, HL 			; Stick DE in HL
0004F2 44          1084   			LD	B, H 			; And copy HL into BC
0004F3 4D          1085   			LD	C, L
0004F4 29          1086   			ADD	HL, HL 			; x 2
0004F5 29          1087   			ADD	HL, HL 			; x 4
0004F6 09          1088   			ADD	HL, BC 			; x 5
0004F7 29          1089   			ADD	HL, HL 			; x 10
0004F8 EB          1090   			EX	DE, HL
0004F9             1091   			ADD8U_DE 			; Add A to DE (macro)
0004F9 83          0001M1         ADD     A, E
0004FA 5F          0002M1         LD      E, A
0004FB 8A          0003M1         ADC     A, D
0004FC 93          0004M1         SUB     E
0004FD 57          0005M1         LD      D, A
0004FE 23          1092   			INC	HL
0004FF 18 E7       1093   			JR	ASC_TO_NUMBER3
000501 C1          1094   ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSP here
000502             1095   
000502             1096   ; Skip a space
000502             1097   ; HL: Pointer in string buffer
000502             1098   ;
000502 7E          1099   SKIPSPmisc:			LD      A, (HL)
000503 FE 20       1100   			CP      ' '
000505 C0          1101   			RET     NZ
000506 23          1102   			INC     HL
000507 18 F9       1103   			JR      SKIPSPmisc
000509             1104   
000509             1105   ; Skip a string
000509             1106   ; HL: Pointer in string buffer
000509             1107   ;
000509 7E          1108   SKIPNOTSP:		LD	A, (HL)
00050A FE 20       1109   			CP	' '
00050C C8          1110   			RET	Z
00050D 23          1111   			INC	HL
00050E 18 F9       1112   			JR	SKIPNOTSP
000510             1113   
000510             1114   ; Convert a character to upper case
000510             1115   ;  A: Character to convert
000510             1116   ;
000510 E6 7F       1117   UPPRCmisc:  		AND     7FH
000512 FE 60       1118   			CP      '`'
000514 D8          1119   			RET     C
000515 E6 5F       1120   			AND     5FH			; Convert to upper case
000517 C9          1121   			RET
000518             1122   
000518             1123   ; Switch on A - lookup table immediately after call
000518             1124   ;  A: Index into lookup table
000518             1125   ;
000518 E3          1126   SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
000519 87          1127   			ADD	A, A			; Multiply A by two
00051A             1128   			ADD8U_HL 			; Add to HL (macro)
00051A 85          0001M1         ADD     A, L
00051B 6F          0002M1         LD      L, A
00051C 8C          0003M1         ADC     A, H
00051D 95          0004M1         SUB     L
00051E 67          0005M1         LD      H, A
00051F 7E          1129   			LD	A, (HL)			; follow the call. Fetch an address from the
000520 23          1130   			INC	HL 			; table.
000521 66          1131   			LD	H, (HL)
000522 6F          1132   			LD	L, A
000523 E3          1133   			EX	(SP), HL		; Swap this new address back, restores HL
000524 C9          1134   			RET				; Return program control to this new address
000525             1135   
000525             1136   ; Convert the buffer to a null terminated string and back
000525             1137   ; HL: Buffer address
000525             1138   ;
000525 C5          1139   NULLTOCR:		PUSH 	BC
000526 06 00       1140   			LD	B, 0
000528 0E 0D       1141   			LD	C, CR
00052A 18 05       1142   			JR	CRTONULL0
00052C             1143   ;
00052C C5          1144   CRTONULL:		PUSH	BC
00052D 06 0D       1145   			LD	B, CR
00052F 0E 00       1146   			LD	C, 0
000531             1147   ;
000531 E5          1148   CRTONULL0:		PUSH	HL
000532 7E          1149   CRTONULL1:		LD	A, (HL)
000533 B8          1150   			CP 	B
000534 28 03       1151   			JR	Z, CRTONULL2
000536 23          1152   			INC	HL
000537 18 F9       1153   			JR	CRTONULL1
000539 71          1154   CRTONULL2:		LD	(HL), C
00053A E1          1155   			POP 	HL
00053B C1          1156   			POP	BC
00053C C9          1157   			RET
00053D             1158   
00053D             1159   ; Copy a filename to DE and zero terminate it
00053D             1160   ; HL: Source
00053D             1161   ; DE: Destination (ACCS)
00053D             1162   ;
00053D 7E          1163   CSTR_FNAME:		LD	A, (HL)			; Get source
00053E FE 20       1164   			CP	32			; Is it space
000540 28 09       1165   			JR	Z, @F
000542 FE 0D       1166   			CP	CR			; Or is it CR
000544 28 05       1167   			JR	Z, @F
000546 12          1168   			LD	(DE), A			; No, so store
000547 23          1169   			INC	HL			; Increment
000548 13          1170   			INC	DE
000549 18 F2       1171   			JR	CSTR_FNAME		; And loop
00054B AF          1172   @@:			XOR	A			; Zero terminate the target string
00054C 12          1173   			LD	(DE), A
00054D 13          1174   			INC	DE			; And point to next free address
00054E C9          1175   			RET
00054F             1176   
00054F             1177   ; Copy a CR terminated line to DE and zero terminate it
00054F             1178   ; HL: Source
00054F             1179   ; DE: Destination (ACCS)
00054F             1180   ;
00054F 7E          1181   CSTR_LINE:		LD	A, (HL)			; Get source
000550 FE 0D       1182   			CP	CR			; Is it CR
000552 28 05       1183   			JR	Z, @F
000554 12          1184   			LD	(DE), A			; No, so store
000555 23          1185   			INC	HL			; Increment
000556 13          1186   			INC	DE
000557 18 F6       1187   			JR	CSTR_LINE		; And loop
000559 AF          1188   @@:			XOR	A			; Zero terminate the target string
00055A 12          1189   			LD	(DE), A
00055B 13          1190   			INC	DE			; And point to next free address
00055C C9          1191   			RET
00055D             1192   
00055D             1193   ; Find the first occurrence of a character (case sensitive)
00055D             1194   ; HL: Source
00055D             1195   ;  C: Character to find
00055D             1196   ; Returns:
00055D             1197   ; HL: Pointer to character, or end of string marker
00055D             1198   ;
00055D 7E          1199   CSTR_FINDCH:		LD	A, (HL)			; Get source
00055E B9          1200   			CP	C			; Is it our character?
00055F C8          1201   			RET	Z			; Yes, so exit
000560 B7          1202   			OR	A			; Is it the end of string?
000561 C8          1203   			RET	Z			; Yes, so exit
000562 23          1204   			INC	HL
000563 18 F8       1205   			JR	CSTR_FINDCH
000565             1206   
000565             1207   ; Check whether a string ends with another string (case insensitive)
000565             1208   ; HL: Source
000565             1209   ; DE: The substring we want to test with
000565             1210   ; Returns:
000565             1211   ;  F: Z if HL ends with DE, otherwise NZ
000565             1212   ;
000565 7E          1213   CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
000566 CD 10 05    1214   			CALL	UPPRCmisc			; Convert to upper case
000569 4F          1215   			LD	C, A
00056A 1A          1216   			LD	A, (DE)			; Get the substring byte
00056B B9          1217   			CP	C
00056C C0          1218   			RET	NZ			; Return NZ if at any point the strings don't match
00056D B1          1219   			OR	C			; Check whether both bytes are zero
00056E C8          1220   			RET	Z			; If so, return, as we have reached the end of both strings
00056F 23          1221   			INC	HL
000570 13          1222   			INC	DE
000571 18 F2       1223   			JR	CSTR_ENDSWITH		; And loop
000573             1224   
000573             1225   ; Concatenate a string onto the end of another string
000573             1226   ; HL: Source
000573             1227   ; DE: Second string
000573             1228   ;
000573 7E          1229   CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
000574 B7          1230   			OR	A
000575 28 03       1231   			JR	Z, CSTR_CAT_1
000577 23          1232   			INC	HL
000578 18 F9       1233   			JR	CSTR_CAT
00057A             1234   ;
00057A 1A          1235   CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
00057B 77          1236   			LD	(HL), A
00057C B7          1237   			OR	A			; Check for end of string
00057D C8          1238   			RET	Z			; And return
00057E 23          1239   			INC	HL
00057F 13          1240   			INC	DE
000580 18 F8       1241   			JR	CSTR_CAT_1		; Loop until finished
000582             1242   ; --- End agon_misc.asm ---
000582             1243   
000582             1244   ; --- Begin agon_os.asm ---
000582             1245   ;
000582             1246   ; Title:	BBC Basic for AGON - MOS stuff
000582             1247   ; Author:	Dean Belfield
000582             1248   ; Created:	04/12/2024
000582             1249   ; Last Updated:	12/12/2024
000582             1250   ;
000582             1251   ; Modinfo:
000582             1252   ; 08/12/2024:	Added OSCLI and file I/O
000582             1253   ; 11/12/2024:	Added ESC key handling
000582             1254   ; 		Added OSWORD
000582             1255   ; 12/12/2024:	Added OSRDCH, OSBYTE_81 and fixed *EDIT
000582             1256   
000582             1257   			.ASSUME	ADL = 0
000582             1258   ;			.ORG 0x0000
000582             1259   
000582             1260   			; INCLUDE	"equs.inc"
000582             1261   			; INCLUDE "macros.inc"
000582             1262   			; INCLUDE "mos_api.inc"	; In MOS/src
000582             1263   
000582             1264   ;			SEGMENT CODE
000582             1265   
000582             1266   ;			XDEF	OSWORD
000582             1267   ;			XDEF	OSBYTE
000582             1268   ;			XDEF	OSINIT
000582             1269   ;			XDEF	OSOPEN
000582             1270   ;			XDEF	OSSHUT
000582             1271   ;			XDEF	OSLOAD
000582             1272   ;			XDEF	OSSAVE
000582             1273   ;			XDEF	OSLINE
000582             1274   ;			XDEF	OSSTAT
000582             1275   ;			XDEF	OSWRCH
000582             1276   ;			XDEF	OSRDCH
000582             1277   ;			XDEF	OSBGET
000582             1278   ;			XDEF	OSBPUT
000582             1279   ;			XDEF	OSCLI
000582             1280   ;			XDEF	PROMPT
000582             1281   ;			XDEF	GETPTR
000582             1282   ;			XDEF	PUTPTR
000582             1283   ;			XDEF	GETEXT
000582             1284   ;			XDEF	TRAP
000582             1285   ;			XDEF	LTRAP
000582             1286   ;			XDEF	BYE
000582             1287   ;			XDEF	RESET
000582             1288   ;			XDEF	ESCSET
000582             1289   
000582             1290   ;			XREF	EXTERR
000582             1291   ;			XREF	VBLANK_INIT
000582             1292   ;			XREF	VBLANK_STOP
000582             1293   ;			XREF	USER
000582             1294   ;			XREF	COUNT
000582             1295   ;			XREF	COUNT0
000582             1296   ;			XREF	COUNT1
000582             1297   ;			XREF	GETCSR
000582             1298   ;			XREF	GETSCHR_1
000582             1299   ;			XREF	NULLTOCR
000582             1300   ;			XREF	CRLF
000582             1301   ;			XREF	FLAGS
000582             1302   ;			XREF	OSWRCHPT
000582             1303   ;			XREF	OSWRCHCH
000582             1304   ;			XREF	OSWRCHFH
000582             1305   ;			XREF	KEYASCII
000582             1306   ;			XREF	KEYDOWN
000582             1307   ;			XREF	LISTON
000582             1308   ;			XREF	PAGE_
000582             1309   ;			XREF	CSTR_FNAME
000582             1310   ;			XREF	CSTR_FINDCH
000582             1311   ;			XREF	CSTR_CAT
000582             1312   ;			XREF	CSTR_ENDSWITH
000582             1313   ;			XREF	CSTR_LINE
000582             1314   ;			XREF	NEWIT
000582             1315   ;			XREF	BAD
000582             1316   ;			XREF	CLEAN
000582             1317   ;			XREF	LINNUM
000582             1318   ;			XREF	BUFFER
000582             1319   ;			XREF	NXT
000582             1320   ;			XREF	ERROR_
000582             1321   ;			XREF	XEQ
000582             1322   ;			XREF	LEXAN2
000582             1323   ;			XREF	GETTOP
000582             1324   ;			XREF	FINDL
000582             1325   ;			XREF	DEL
000582             1326   ;			XREF	LISTIT
000582             1327   ;			XREF	ESCAPE
000582             1328   ;			XREF	ASC_TO_NUMBER
000582             1329   ;			XREF	CLOOP
000582             1330   ;			XREF	SCRAP
000582             1331   ;			XREF	POINT_
000582             1332   ;			XREF	SOUND_
000582             1333   
000582             1334   ;OSINIT - Initialise RAM mapping etc.
000582             1335   ;If BASIC is entered by BBCBASIC FILENAME then file
000582             1336   ;FILENAME.BBC is automatically CHAINed.
000582             1337   ;   Outputs: DE = initial value of HIMEM (top of RAM)
000582             1338   ;            HL = initial value of PAGE (user program)
000582             1339   ;            Z-flag reset indicates AUTO-RUN.
000582             1340   ;  Destroys: A,D,E,H,L,F
000582             1341   ;
000582 CD 25 04    1342   OSINIT:			CALL	VBLANK_INIT
000585 AF          1343   			XOR	A
000586 32 F5 50    1344   			LD	(FLAGS), A		; Clear flags and set F = Z
000589 21 00 55    1345   			LD 	HL, USER
00058C 11 00 FF    1346   			LD	DE, RAM_Top
00058F 5F          1347   			LD	E, A			; Page boundary
000590 3A 00 52    1348   			LD	A, (ACCS)		; Return NZ if there is a file to chain
000593 B7          1349   			OR	A
000594 C9          1350   			RET
000595             1351   
000595             1352   ; PROMPT: output the input prompt
000595             1353   ;
000595 3E 3E       1354   PROMPT: 		LD	A,'>'			; Falls through to OSWRCH
000597             1355   
000597             1356   ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
000597             1357   ; Parameters:
000597             1358   ; - A: Character to write
000597             1359   ;
000597 E5          1360   OSWRCH:			PUSH	HL
000598 21 FE 54    1361   			LD	HL, LISTON		; Fetch the LISTON variable
00059B CB 5E       1362   			BIT	3, (HL)			; Check whether we are in *EDIT mode
00059D 20 0A       1363   			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
00059F             1364   ;
00059F 2A F8 50    1365   			LD	HL, (OSWRCHCH)		; L: Channel #
0005A2 2D          1366   			DEC	L			; If it is 1
0005A3 28 17       1367   			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0005A5             1368   ;
0005A5 E1          1369   			POP	HL			; Otherwise
0005A6 49 D7       1370   			RST.LIS	10h			; Output the character to MOS
0005A8 C9          1371   			RET
0005A9             1372   ;
0005A9 2A F6 50    1373   OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0005AC FE 0A       1374   			CP	0AH			; Just ignore this
0005AE 28 0A       1375   			JR	Z, OSWRCH_BUFFER2
0005B0 FE 0D       1376   			CP	0DH			; Is it the end of line?
0005B2 20 01       1377   			JR	NZ, OSWRCH_BUFFER1	; No, so carry on
0005B4 AF          1378   			XOR	A			; Turn it into a NUL character
0005B5 77          1379   OSWRCH_BUFFER1:		LD	(HL), A			; Echo the character into the buffer
0005B6 23          1380   			INC	HL			; Increment pointer
0005B7 22 F6 50    1381   			LD	(OSWRCHPT), HL		; Write pointer back
0005BA E1          1382   OSWRCH_BUFFER2:		POP	HL
0005BB C9          1383   			RET
0005BC             1384   ;
0005BC D5          1385   OSWRCH_FILE:		PUSH	DE
0005BD 5C          1386   			LD	E, H			; Filehandle to E
0005BE CD 49 06    1387   			CALL	OSBPUT			; Write the byte out
0005C1 D1          1388   			POP	DE
0005C2 E1          1389   			POP	HL
0005C3 C9          1390   			RET
0005C4             1391   
0005C4             1392   ; OSRDCH
0005C4             1393   ;
0005C4             1394   OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
0005C4 3E 00       0001M1 			LD	A, function
0005C6 49 CF       0002M1 			RST.LIS	08h
0005C8 FE 1B       1395   			CP	1Bh
0005CA 28 55       1396   			JR	Z, LTRAP1
0005CC C9          1397   			RET
0005CD             1398   
0005CD             1399   ; OSLINE: Invoke the line editor
0005CD             1400   ;
0005CD 1E 01       1401   OSLINE:			LD 	E, 1			; Default is to clear the buffer
0005CF             1402   
0005CF             1403   ; Entry point to line editor that does not clear the buffer
0005CF             1404   ; Parameters:
0005CF             1405   ; - HL: addresses destination buffer (on page boundary)
0005CF             1406   ; Returns:
0005CF             1407   ; -  A: 0
0005CF             1408   ; NB: Buffer filled, terminated by CR
0005CF             1409   ;
0005CF FD E5       1410   OSLINE1:		PUSH	IY
0005D1 E5          1411   			PUSH	HL			; Buffer address
0005D2 01 00 01    1412   			LD	BC, 256			; Buffer length
0005D5             1413   			MOSCALL	mos_editline		; Call the MOS line editor
0005D5 3E 09       0001M1 			LD	A, function
0005D7 49 CF       0002M1 			RST.LIS	08h
0005D9 E1          1414   			POP	HL			; Pop the address
0005DA FD E1       1415   			POP	IY
0005DC F5          1416   			PUSH	AF			; Stack the return value (key pressed)
0005DD CD 25 05    1417   			CALL	NULLTOCR		; Turn the 0 character to a CR
0005E0 CD E1 40    1418   			CALL	CRLF			; Display CRLF
0005E3 F1          1419   			POP	AF
0005E4 FE 1B       1420   			CP	1Bh 			; Check if ESC terminated the input
0005E6 CA 21 06    1421   			JP	Z, LTRAP1 		; Yes, so do the ESC thing
0005E9 3A F5 50    1422   			LD	A, (FLAGS)		; Otherwise
0005EC CB BF       1423   			RES	7, A 			; Clear the escape flag
0005EE 32 F5 50    1424   			LD	(FLAGS), A
0005F1 CD 71 0A    1425   			CALL	WAIT_VBLANK 		; Wait a frame
0005F4 AF          1426    			XOR	A			; Return A = 0
0005F5 32 FA 50    1427   			LD	(KEYDOWN), A
0005F8 32 FB 50    1428   			LD	(KEYASCII), A
0005FB C9          1429   			RET
0005FC             1430   
0005FC             1431   ;
0005FC             1432   ; ESCSET
0005FC             1433   ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
0005FC             1434   ;
0005FC E5          1435   ESCSET: 		PUSH    HL
0005FD 21 F5 50    1436           		LD      HL,FLAGS		; Pointer to FLAGS
000600 CB 76       1437           		BIT     6,(HL)			; If bit 6 is set, then
000602 20 02       1438           		JR      NZ,ESCDIS		; escape is disabled, so skip
000604 CB FE       1439           		SET     7,(HL)			; Set bit 7, the escape flag
000606 E1          1440   ESCDIS: 		POP     HL
000607 C9          1441           		RET
000608             1442   
000608             1443   ;
000608             1444   ; ESCTEST
000608             1445   ; Test for ESC key
000608             1446   ;
000608 CD 11 06    1447   ESCTEST:		CALL	READKEY			; Read the keyboard
00060B C0          1448   			RET	NZ			; Skip if no key is pressed
00060C FE 1B       1449   			CP	1BH			; If ESC pressed then
00060E 28 EC       1450   			JR	Z,ESCSET		; jump to the escape set routine
000610 C9          1451   			RET
000611             1452   
000611             1453   ; Read the keyboard
000611             1454   ; Returns:
000611             1455   ; - A: ASCII of the pressed key
000611             1456   ; - F: Z if the key is pressed, otherwise NZ
000611             1457   ;
000611 3A FA 50    1458   READKEY:		LD	A, (KEYDOWN)		; Get key down
000614 3D          1459   			DEC	A 			; Set Z flag if keydown is 1
000615 3A FB 50    1460   			LD	A, (KEYASCII)		; Get key ASCII value
000618 C9          1461   			RET
000619             1462   ;
000619             1463   ; TRAP
000619             1464   ; This is called whenever BASIC needs to check for ESC
000619             1465   ;
000619 CD 08 06    1466   TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
00061C             1467   ;
00061C 3A F5 50    1468   LTRAP:			LD	A,(FLAGS)		; Get FLAGS
00061F B7          1469   			OR	A			; This checks for bit 7; if it is not set then the result will
000620 F0          1470   			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
000621 21 F5 50    1471   LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
000624 CB BE       1472   			RES	7,(HL)			; Clear the escape pressed flag and
000626 C3 C9 25    1473   			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
000629             1474   
000629             1475   ; RESET
000629             1476   ;
000629 C9          1477   RESET:			RET				; Yes this is fine
00062A             1478   
00062A             1479   ; OSOPEN
00062A             1480   ; HL: Pointer to path
00062A             1481   ;  F: C Z
00062A             1482   ;     x x OPENIN
00062A             1483   ; 	  OPENOUT
00062A             1484   ;     x	  OPENUP
00062A             1485   ; Returns:
00062A             1486   ;  A: Filehandle, 0 if cannot open
00062A             1487   ;
00062A 0E 01       1488   OSOPEN:			LD	C, fa_read
00062C 28 06       1489   			JR	Z, @F
00062E 0E 32       1490   			LD	C, fa_write | fa_open_append
000630 38 02       1491   			JR	C, @F
000632 0E 0A       1492   			LD	C, fa_write | fa_create_always
000634             1493   @@:			MOSCALL	mos_fopen
000634 3E 0A       0001M1 			LD	A, function
000636 49 CF       0002M1 			RST.LIS	08h
000638 C9          1494   			RET
000639             1495   
000639             1496   ;OSSHUT - Close disk file(s).
000639             1497   ; E = file channel
000639             1498   ;  If E=0 all files are closed (except SPOOL)
000639             1499   ; Destroys: A,B,C,D,E,H,L,F
000639             1500   ;
000639 C5          1501   OSSHUT:			PUSH	BC
00063A 4B          1502   			LD	C, E
00063B             1503   			MOSCALL	mos_fclose
00063B 3E 0B       0001M1 			LD	A, function
00063D 49 CF       0002M1 			RST.LIS	08h
00063F C1          1504   			POP	BC
000640 C9          1505   			RET
000641             1506   
000641             1507   ; OSBGET - Read a byte from a random disk file.
000641             1508   ;  E = file channel
000641             1509   ; Returns
000641             1510   ;  A = byte read
000641             1511   ;  Carry set if LAST BYTE of file
000641             1512   ; Destroys: A,B,C,F
000641             1513   ;
000641 C5          1514   OSBGET:			PUSH	BC
000642 4B          1515   			LD	C, E
000643             1516   			MOSCALL	mos_fgetc
000643 3E 0C       0001M1 			LD	A, function
000645 49 CF       0002M1 			RST.LIS	08h
000647 C1          1517   			POP	BC
000648 C9          1518   			RET
000649             1519   
000649             1520   ; OSBPUT - Write a byte to a random disk file.
000649             1521   ;  E = file channel
000649             1522   ;  A = byte to write
000649             1523   ; Destroys: A,B,C,F
000649             1524   ;
000649 C5          1525   OSBPUT:			PUSH	BC
00064A 4B          1526   			LD	C, E
00064B 47          1527   			LD	B, A
00064C             1528   			MOSCALL	mos_fputc
00064C 3E 0D       0001M1 			LD	A, function
00064E 49 CF       0002M1 			RST.LIS	08h
000650 C1          1529   			POP	BC
000651 C9          1530   			RET
000652             1531   
000652             1532   ; OSSTAT - Read file status
000652             1533   ;  E = file channel
000652             1534   ; Returns
000652             1535   ;  F: Z flag set - EOF
000652             1536   ;  A: If Z then A = 0
000652             1537   ; Destroys: A,D,E,H,L,F
000652             1538   ;
000652 C5          1539   OSSTAT:			PUSH	BC
000653 4B          1540   			LD	C, E
000654             1541   			MOSCALL	mos_feof
000654 3E 0E       0001M1 			LD	A, function
000656 49 CF       0002M1 			RST.LIS	08h
000658 C1          1542   			POP	BC
000659 FE 01       1543   			CP	1
00065B C9          1544   			RET
00065C             1545   
00065C             1546   ; GETPTR - Return file pointer.
00065C             1547   ;    E = file channel
00065C             1548   ; Returns:
00065C             1549   ; DEHL = pointer (0-&7FFFFF)
00065C             1550   ; Destroys: A,B,C,D,E,H,L,F
00065C             1551   ;
00065C FD E5       1552   GETPTR:			PUSH		IY
00065E 4B          1553   			LD		C, E
00065F             1554   			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
00065F 3E 19       0001M1 			LD	A, function
000661 49 CF       0002M1 			RST.LIS	08h
000663 5B E5       1555   			PUSH.LIL	HL
000665 5B FD E1    1556   			POP.LIL		IY		; IYU: Pointer to FIL structure
000668 5B FD 6E 11 1557   			LD.LIL		L, (IY + FIL.fptr + 0)
00066C 5B FD 66 12 1558   			LD.LIL		H, (IY + FIL.fptr + 1)
000670 5B FD 5E 13 1559   			LD.LIL		E, (IY + FIL.fptr + 2)
000674 5B FD 56 14 1560   			LD.LIL		D, (IY + FIL.fptr + 3)
000678 FD E1       1561   			POP		IY
00067A C9          1562   			RET
00067B             1563   
00067B             1564   ; PUTPTR - Update file pointer.
00067B             1565   ;    A = file channel
00067B             1566   ; DEHL = new pointer (0-&7FFFFF)
00067B             1567   ; Destroys: A,B,C,D,E,H,L,F
00067B             1568   ;
00067B FD E5       1569   PUTPTR:			PUSH		IY
00067D 4F          1570   			LD		C, A  		; C: Filehandle
00067E 5B E5       1571   			PUSH.LIL	HL
000680 5B 21 02 00 1572   			LD.LIL		HL, 2
       00          
000685 5B 39       1573   			ADD.LIL		HL, SP
000687 5B 73       1574   			LD.LIL		(HL), E 	; 3rd byte of DWORD set to E
000689 5B E1       1575   			POP.LIL		HL
00068B 5A          1576   			LD		E, D  		; 4th byte passed as E
00068C             1577   			MOSCALL		mos_flseek
00068C 3E 1C       0001M1 			LD	A, function
00068E 49 CF       0002M1 			RST.LIS	08h
000690 FD E1       1578   			POP		IY
000692 C9          1579   			RET
000693             1580   
000693             1581   ; GETEXT - Find file size.
000693             1582   ;    E = file channel
000693             1583   ; Returns:
000693             1584   ; DEHL = file size (0-&800000)
000693             1585   ; Destroys: A,B,C,D,E,H,L,F
000693             1586   ;
000693 FD E5       1587   GETEXT:			PUSH		IY
000695 4B          1588   			LD		C, E
000696             1589   			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
000696 3E 19       0001M1 			LD	A, function
000698 49 CF       0002M1 			RST.LIS	08h
00069A 5B E5       1590   			PUSH.LIL	HL
00069C 5B FD E1    1591   			POP.LIL		IY		; IYU: Pointer to FIL structure
00069F 5B FD 6E 24 1592   			LD.LIL		L, (IY + FIL.obj.objsize + 0)
0006A3 5B FD 66 25 1593   			LD.LIL		H, (IY + FIL.obj.objsize + 1)
0006A7 5B FD 5E 26 1594   			LD.LIL		E, (IY + FIL.obj.objsize + 2)
0006AB 5B FD 56 27 1595   			LD.LIL		D, (IY + FIL.obj.objsize + 3)
0006AF FD E1       1596   			POP		IY
0006B1 C9          1597   			RET
0006B2             1598   
0006B2             1599   ;OSLOAD - Load an area of memory from a file.
0006B2             1600   ;   Inputs: HL addresses filename (CR terminated)
0006B2             1601   ;           DE = address at which to load
0006B2             1602   ;           BC = maximum allowed size (bytes)
0006B2             1603   ;  Outputs: Carry reset indicates no room for file.
0006B2             1604   ; Destroys: A,B,C,D,E,H,L,F
0006B2             1605   ;
0006B2 C5          1606   OSLOAD:			PUSH	BC			; Stack the size
0006B3 D5          1607   			PUSH	DE			; Stack the load address
0006B4 11 00 52    1608   			LD	DE, ACCS		; Buffer address for filename
0006B7 CD 3D 05    1609   			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0006BA 21 00 52    1610   			LD	HL, ACCS		; HL: Filename
0006BD CD FB 07    1611   			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0006C0 CD 0C 08    1612   			CALL	EXT_HANDLER		; Get the default handler
0006C3 D1          1613   			POP	DE			; Restore the load address
0006C4 C1          1614   			POP	BC			; Restore the size
0006C5 B7          1615   			OR	A
0006C6 CA 8D 07    1616   			JP 	Z, OSLOAD_BBC
0006C9             1617   ;
0006C9             1618   ; Load the file in as a text file
0006C9             1619   ;
0006C9 AF          1620   OSLOAD_TXT:		XOR	A			; Set file attributes to read
0006CA CD 2A 06    1621   			CALL	OSOPEN			; Open the file
0006CD 5F          1622   			LD 	E, A 			; The filehandle
0006CE B7          1623   			OR	A
0006CF 3E 04       1624   			LD	A, 4			; File not found error
0006D1 CA 95 07    1625   			JP	Z, OSERROR		; Jump to error handler
0006D4 CD 24 40    1626   			CALL	NEWIT			; Call NEW to clear the program space
0006D7             1627   ;
0006D7 21 00 52    1628   OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0006DA             1629   ;
0006DA             1630   ; First skip any whitespace (indents) at the beginning of the input
0006DA             1631   ;
0006DA CD 41 06    1632   @@:			CALL	OSBGET			; Read the byte into A
0006DD 38 1C       1633   			JR	C, OSLOAD_TXT3		; Is it EOF?
0006DF FE 0A       1634   			CP	LF 			; Is it LF?
0006E1 28 18       1635   			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0006E3 FE 21       1636   			CP	21h			; Is it less than or equal to ASCII space?
0006E5 38 F3       1637   			JR	C, @B 			; Yes, so keep looping
0006E7 77          1638   			LD	(HL), A 		; Store the first character
0006E8 2C          1639   			INC	L
0006E9             1640   ;
0006E9             1641   ; Now read the rest of the line in
0006E9             1642   ;
0006E9 CD 41 06    1643   OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0006EC 38 26       1644   			JR	C, OSLOAD_TXT4		; Is it EOF?
0006EE FE 20       1645   			CP	20h			; Skip if not an ASCII character
0006F0 38 05       1646   			JR	C, @F
0006F2 77          1647   			LD	(HL), A 		; Store in the input buffer
0006F3 2C          1648   			INC	L			; Increment the buffer pointer
0006F4 CA D5 3E    1649   			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0006F7 FE 0A       1650   @@:			CP	LF			; Check for LF
0006F9 20 EE       1651   			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0006FB             1652   ;
0006FB             1653   ; Finally, handle EOL/EOF
0006FB             1654   ;
0006FB 36 0D       1655   OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0006FD 7D          1656   			LD	A, L			; Check for minimum line length
0006FE FE 02       1657   			CP	2			; If it is 2 characters or less (including CR)
000700 38 08       1658   			JR	C, @F			; Then don't bother entering it
000702 D5          1659   			PUSH	DE			; Preserve the filehandle
000703 CD 1F 07    1660   			CALL	OSEDIT			; Enter the line in memory
000706 DC 00 40    1661   			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
000709 D1          1662   			POP	DE
00070A CD 52 06    1663   @@:			CALL	OSSTAT			; End of file?
00070D 20 C8       1664   			JR	NZ, OSLOAD_TXT1		; No, so loop
00070F CD 39 06    1665   			CALL	OSSHUT			; Close the file
000712 37          1666   			SCF				; Flag to BASIC that we're good
000713 C9          1667   			RET
000714             1668   ;
000714             1669   ; Special case for BASIC programs with no blank line at the end
000714             1670   ;
000714 FE 20       1671   OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
000716 38 05       1672   			JR	C, @F
000718 77          1673   			LD	(HL), A			; Store the character
000719 2C          1674   			INC	L
00071A CA D5 3E    1675   			JP	Z, BAD
00071D 18 DC       1676   @@:			JR	OSLOAD_TXT3
00071F             1677   ;
00071F             1678   ; This bit enters the line into memory
00071F             1679   ; Also called from OSLOAD_TXT
00071F             1680   ; Returns:
00071F             1681   ; F: C if a new line has been entered (CLEAN will need to be called)
00071F             1682   ;
00071F AF          1683   OSEDIT:			XOR	A			; Entry point after *EDIT
000720 32 FB 54    1684   			LD      (COUNT),A
000723 FD 21 00 52 1685   			LD      IY,ACCS
000727 CD 70 43    1686   			CALL    LINNUM			; HL: The line number from the input buffer
00072A CD F1 44    1687   			CALL    NXT			; Skip spaces
00072D 7C          1688   			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
00072E B5          1689   			OR      L
00072F 28 00       1690   			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
000731             1691   ;
000731             1692   ; This bit does the lexical analysis and tokenisation
000731             1693   ;
000731 11 00 53    1694   LNZERO:			LD	DE,BUFFER
000734 0E 01       1695                   	LD	C,1			; LEFT MODE
000736 E5          1696                   	PUSH	HL
000737 CD FE 43    1697                   	CALL	LEXAN2			; LEXICAL ANALYSIS
00073A E1          1698                   	POP	HL
00073B 12          1699                   	LD	(DE),A			; TERMINATOR
00073C AF          1700                   	XOR	A
00073D 47          1701                   	LD	B,A
00073E 4B          1702                   	LD	C,E			; BC=LINE LENGTH
00073F 13          1703                   	INC	DE
000740 12          1704                   	LD	(DE),A			; ZERO NEXT
000741 7C          1705                   	LD	A,H
000742 B5          1706                   	OR	L
000743 FD 21 00 53 1707                   	LD	IY,BUFFER		; FOR XEQ
000747 CA 7F 24    1708                   	JP	Z,XEQ			; DIRECT MODE
00074A C5          1709                   	PUSH	BC
00074B CD 29 41    1710                   	CALL	FINDL
00074E CC CF 3F    1711                   	CALL	Z,DEL
000751 C1          1712                   	POP	BC
000752 79          1713                   	LD	A,C
000753 B7          1714                   	OR	A
000754 C8          1715                   	RET	Z
000755 C6 04       1716                   	ADD	A,4
000757 4F          1717                   	LD	C,A			; LENGTH INCLUSIVE
000758 D5          1718                   	PUSH	DE			; LINE NUMBER
000759 C5          1719                   	PUSH	BC			; SAVE LINE LENGTH
00075A EB          1720                   	EX	DE,HL
00075B C5          1721                   	PUSH	BC
00075C CD 0B 40    1722                   	CALL	GETTOP
00075F C1          1723                   	POP	BC
000760 E5          1724                   	PUSH	HL
000761 09          1725                   	ADD	HL,BC
000762 E5          1726                   	PUSH	HL
000763 24          1727                   	INC	H
000764 AF          1728                   	XOR	A
000765 ED 72       1729                   	SBC	HL,SP
000767 E1          1730                   	POP	HL
000768 D2 2A 3F    1731                   	JP	NC,ERROR_		; "No room"
00076B E3          1732                   	EX	(SP),HL
00076C E5          1733                   	PUSH	HL
00076D 23          1734                   	INC	HL
00076E B7          1735                   	OR	A
00076F ED 52       1736                   	SBC	HL,DE
000771 44          1737                   	LD	B,H			; BC=AMOUNT TO MOVE
000772 4D          1738                   	LD	C,L
000773 E1          1739                   	POP	HL
000774 D1          1740                   	POP	DE
000775 28 02       1741                   	JR	Z,ATENDos
000777 ED B8       1742                   	LDDR				; MAKE SPACE
000779 C1          1743   ATENDos:          	POP	BC			; LINE LENGTH
00077A D1          1744                   	POP	DE			; LINE NUMBER
00077B 23          1745                   	INC	HL
00077C 71          1746                   	LD	(HL),C			; STORE LENGTH
00077D 23          1747                   	INC	HL
00077E 73          1748                   	LD	(HL),E			; STORE LINE NUMBER
00077F 23          1749                   	INC	HL
000780 72          1750                   	LD	(HL),D
000781 23          1751                   	INC	HL
000782 11 00 53    1752                   	LD	DE,BUFFER
000785 EB          1753                   	EX	DE,HL
000786 0D          1754                   	DEC	C
000787 0D          1755                   	DEC	C
000788 0D          1756                   	DEC	C
000789 ED B0       1757                   	LDIR				; ADD LINE
00078B 37          1758   			SCF
00078C C9          1759   			RET
00078D             1760   ;
00078D             1761   ; Load the file in as a tokenised binary blob
00078D             1762   ;
00078D             1763   OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
00078D 3E 01       0001M1 			LD	A, function
00078F 49 CF       0002M1 			RST.LIS	08h
000791 D0          1764   			RET	NC			; If load returns with carry reset - NO ROOM
000792 B7          1765   			OR	A			; If there is no error (A=0)
000793 37          1766   			SCF				; Need to set carry indicating there was room
000794 C8          1767   			RET	Z			; Return
000795             1768   ;
000795 F5          1769   OSERROR:		PUSH	AF			; Handle the MOS error
000796 21 00 52    1770   			LD	HL, ACCS		; Address of the buffer
000799 01 00 01    1771   			LD	BC, 256			; Length of the buffer
00079C 5F          1772   			LD	E, A			; The error code
00079D             1773   			MOSCALL	mos_getError		; Copy the error message into the buffer
00079D 3E 0F       0001M1 			LD	A, function
00079F 49 CF       0002M1 			RST.LIS	08h
0007A1 F1          1774   			POP	AF
0007A2 E5          1775   			PUSH	HL			; Stack the address of the error (now in ACCS)
0007A3 C6 7F       1776   			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
0007A5 C3 3B 3F    1777   			JP	EXTERR			; Trigger an external error
0007A8             1778   
0007A8             1779   ;OSSAVE - Save an area of memory to a file.
0007A8             1780   ;   Inputs: HL addresses filename (term CR)
0007A8             1781   ;           DE = start address of data to save
0007A8             1782   ;           BC = length of data to save (bytes)
0007A8             1783   ; Destroys: A,B,C,D,E,H,L,F
0007A8             1784   ;
0007A8 C5          1785   OSSAVE:			PUSH	BC			; Stack the size
0007A9 D5          1786   			PUSH	DE			; Stack the save address
0007AA 11 00 52    1787   			LD	DE, ACCS		; Buffer address for filename
0007AD CD 3D 05    1788   			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0007B0 21 00 52    1789   			LD	HL, ACCS		; HL: Filename
0007B3 CD FB 07    1790   			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0007B6 CD 0C 08    1791   			CALL	EXT_HANDLER		; Get the default handler
0007B9 D1          1792   			POP	DE			; Restore the save address
0007BA C1          1793   			POP	BC			; Restore the size
0007BB B7          1794   			OR	A			; Is the extension .BBC
0007BC 28 35       1795   			JR	Z, OSSAVE_BBC		; Yes, so use that
0007BE             1796   ;
0007BE             1797   ; Save the file out as a text file
0007BE             1798   ;
0007BE 3A F8 50    1799   OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0007C1 F5          1800   			PUSH	AF
0007C2 AF          1801   			XOR	A
0007C3 3C          1802   			INC	A			; Make sure C is clear, A is 1, for OPENOUT
0007C4 32 F8 50    1803   			LD	(OSWRCHCH), A
0007C7 CD 2A 06    1804   			CALL	OSOPEN			; Open the file
0007CA 32 F9 50    1805   			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0007CD DD 21 FE 54 1806   			LD	IX, LISTON		; Required for LISTIT
0007D1 2A DC 54    1807   			LD	HL, (PAGE_)		; Get start of program area
0007D4 D9          1808   			EXX
0007D5 01 00 00    1809   			LD	BC, 0			; Set the initial indent counters
0007D8 D9          1810   			EXX
0007D9 7E          1811   OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0007DA B7          1812   			OR	A
0007DB 28 0A       1813   			JR	Z, OSSAVE_TXT2
0007DD 23          1814   			INC	HL			; Skip the length byte
0007DE 5E          1815   			LD	E, (HL)			; Get the line number
0007DF 23          1816   			INC	HL
0007E0 56          1817   			LD	D, (HL)
0007E1 23          1818   			INC	HL
0007E2 CD 43 40    1819   			CALL	LISTIT			; List the line
0007E5 18 F2       1820   			JR	OSSAVE_TXT1
0007E7 3A F9 50    1821   OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0007EA 5F          1822   			LD	E, A
0007EB CD 39 06    1823   			CALL	OSSHUT			; Close it
0007EE F1          1824   			POP	AF			; Restore the channel
0007EF 32 F8 50    1825   			LD	(OSWRCHCH), A
0007F2 C9          1826   			RET
0007F3             1827   ;
0007F3             1828   ; Save the file out as a tokenised binary blob
0007F3             1829   ;
0007F3             1830   OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0007F3 3E 02       0001M1 			LD	A, function
0007F5 49 CF       0002M1 			RST.LIS	08h
0007F7 B7          1831   			OR	A			; If there is no error (A=0)
0007F8 C8          1832   			RET	Z			; Just return
0007F9 18 9A       1833   			JR	OSERROR			; Trip an error
0007FB             1834   
0007FB             1835   ; Check if an extension is specified in the filename
0007FB             1836   ; Add a default if not specified
0007FB             1837   ; HL: Filename (CSTR format)
0007FB             1838   ;
0007FB E5          1839   EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0007FC 0E 2E       1840   			LD	C, '.'			; Search for dot (marks start of extension)
0007FE CD 5D 05    1841   			CALL	CSTR_FINDCH
000801 B7          1842   			OR	A			; Check for end of string marker
000802 20 06       1843   			JR	NZ, @F			; No, so skip as we have an extension at this point
000804 11 38 08    1844   			LD	DE, EXT_LOOKUP		; Get the first (default extension)
000807 CD 73 05    1845   			CALL	CSTR_CAT		; Concat it to string pointed to by HL
00080A E1          1846   @@:			POP	HL			; Restore the filename pointer
00080B C9          1847   			RET
00080C             1848   
00080C             1849   ; Check if an extension is valid and, if so, provide a pointer to a handler
00080C             1850   ; HL: Filename (CSTR format)
00080C             1851   ; Returns:
00080C             1852   ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
00080C             1853   ;
00080C E5          1854   EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
00080D 0E 2E       1855   			LD	C, '.'			; Find the '.'
00080F CD 5D 05    1856   			CALL	CSTR_FINDCH
000812 11 38 08    1857   			LD	DE, EXT_LOOKUP		; The lookup table
000815             1858   ;
000815 E5          1859   EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
000816 CD 65 05    1860   			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
000819 E1          1861   			POP	HL			; Restore the pointer to the extension
00081A 28 18       1862   			JR	Z, EXT_HANDLER_2	; We have a match!
00081C             1863   ;
00081C 1A          1864   @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
00081D 13          1865   			INC	DE
00081E B7          1866   			OR	A
00081F 20 FB       1867   			JR	NZ, @B
000821 13          1868   			INC	DE			; Skip the file extension # byte
000822             1869   ;
000822 1A          1870   			LD	A, (DE)			; Are we at the end of the table?
000823 B7          1871   			OR	A
000824 20 EF       1872   			JR	NZ, EXT_HANDLER_1	; No, so loop
000826             1873   ;
000826 3E CC       1874   			LD      A,204			; Throw a "Bad name" error
000828 CD 3B 3F    1875           		CALL    EXTERR
00082B 42 61 64 20 1876           		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
000834             1877   ;
000834 13          1878   EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
000835 1A          1879   			LD	A, (DE)
000836 E1          1880   			POP	HL			; Restore the filename pointer
000837 C9          1881   			RET
000838             1882   
000838             1883   ; Extension lookup table
000838             1884   ; CSTR, TYPE
000838             1885   ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
000838             1886   ; 	- 1: Human readable plain text
000838             1887   ;
000838 2E 42 42 43 1888   EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
00083E 2E 54 58 54 1889   			DB	".TXT", 0, 1
       00 01       
000844 2E 41 53 43 1890   			DB	".ASC", 0, 1
       00 01       
00084A 2E 42 41 53 1891   			DB	".BAS", 0, 1
       00 01       
000850 00          1892   			DB	0			; End of table
000851             1893   
000851             1894   ; OSWORD
000851             1895   ;
000851 FE 07       1896   OSWORD:			CP	07H			; SOUND
000853             1897   			; JR	Z, OSWORD_07
000853 CA 84 0A    1898   			JP	Z, OSWORD_07 ; JR WAS TOO LARGE
000856 FE 08       1899   			CP	08H			; ENVELOPE
000858 28 14       1900   			JR	Z, OSWORD_08
00085A FE 09       1901   			CP	09H			; POINT
00085C 28 03       1902   			JR	Z, OSWORD_09
00085E C3 93 08    1903   			JP	HUH			; Anything else trips an error
000861             1904   
000861             1905   ; moved to agon_sound.asm
000861             1906   ; ; SOUND channel,volume,pitch,duration
000861             1907   ; ; Parameters:
000861             1908   ; ; - HL: Pointer to data
000861             1909   ; ;   - 0,1: Channel
000861             1910   ; ;   - 2,3: Volume 0 (off) to 15 (full volume)
000861             1911   ; ;   - 4,5: Pitch 0 - 255
000861             1912   ; ;   - 6,7: Duration -1 to 254 (duration in 20ths of a second, -1 = play forever)
000861             1913   ; ;
000861             1914   ; OSWORD_07:		EQU	SOUND_
000861             1915   ; end moved to agon_sound.asm
000861             1916   
000861             1917   ; OSWORD 0x09: POINT
000861             1918   ; Parameters:
000861             1919   ; - HL: Address of data
000861             1920   ;   - 0,1: X coordinate
000861             1921   ;   - 2,3: Y coordinate
000861             1922   ;
000861 ED 5B FD 50 1923   OSWORD_09:		LD	DE,(SCRAP+0)
000865 2A FF 50    1924   			LD	HL,(SCRAP+2)
000868 CD FA 01    1925   			CALL	POINT_
00086B 32 01 51    1926   			LD	(SCRAP+4),A
00086E C9          1927   OSWORD_08:		RET				; Envelope not currently implemented
00086F             1928   
00086F             1929   ;
00086F             1930   ; OSBYTE
00086F             1931   ; Parameters:
00086F             1932   ; - A: FX #
00086F             1933   ; - L: First parameter
00086F             1934   ; - H: Second parameter
00086F             1935   ;
00086F FE 0B       1936   OSBYTE:			CP	0BH			; Keyboard auto-repeat delay
000871 28 31       1937   			JR	Z, OSBYTE_0B
000873 FE 0C       1938   			CP	0CH			; Keyboard auto-repeat rate
000875 28 54       1939   			JR	Z, OSBYTE_0C
000877 FE 13       1940   			CP	13H			; Wait for vblank
000879 28 77       1941   			JR	Z, OSBYTE_13
00087B FE 76       1942   			CP	76H			; Set keyboard LED
00087D 28 7B       1943   			JR	Z, OSBYTE_76
00087F FE 81       1944   			CP	81H			; Read the keyboard
000881 CA 22 09    1945   			JP	Z, OSBYTE_81
000884 FE 86       1946   			CP	86H			; Get cursor coordinates
000886 CA 3C 09    1947   			JP	Z, OSBYTE_86
000889 FE 87       1948   			CP	87H			; Fetch current mode and character under cursor
00088B CA 6B 09    1949   			JP	Z, OSBYTE_87
00088E FE A0       1950   			CP	A0H			; Fetch system variable
000890 CA 81 09    1951   			JP	Z, OSBYTE_A0
000893             1952   ;
000893             1953   ; Anything else trips an error
000893             1954   ;
000893 3E FE       1955   HUH:    		LD      A,254			; Bad command error
000895 CD 3B 3F    1956           		CALL    EXTERR
000898 42 61 64 20 1957           		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
0008A3 00          1958           		DEFB    0
0008A4             1959   
0008A4             1960   ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
0008A4             1961   ; Parameters:
0008A4             1962   ; - HL: Repeat delay
0008A4             1963   ;
0008A4             1964   OSBYTE_0B:		VDU	23
0008A4 3E 17       0001M1         LD      A, VAL
0008A6 CD 97 05    0002M1         CALL    OSWRCH
0008A9             1965   			VDU	0
0008A9 3E 00       0001M1         LD      A, VAL
0008AB CD 97 05    0002M1         CALL    OSWRCH
0008AE             1966   			VDU	vdp_keystate
0008AE 3E 88       0001M1         LD      A, VAL
0008B0 CD 97 05    0002M1         CALL    OSWRCH
0008B3             1967   			VDU	L
0008B3 7D          0001M1         LD      A, VAL
0008B4 CD 97 05    0002M1         CALL    OSWRCH
0008B7             1968   			VDU	H
0008B7 7C          0001M1         LD      A, VAL
0008B8 CD 97 05    0002M1         CALL    OSWRCH
0008BB             1969   			VDU	0
0008BB 3E 00       0001M1         LD      A, VAL
0008BD CD 97 05    0002M1         CALL    OSWRCH
0008C0             1970   			VDU 	0
0008C0 3E 00       0001M1         LD      A, VAL
0008C2 CD 97 05    0002M1         CALL    OSWRCH
0008C5             1971   			VDU	255
0008C5 3E FF       0001M1         LD      A, VAL
0008C7 CD 97 05    0002M1         CALL    OSWRCH
0008CA C9          1972   			RET
0008CB             1973   
0008CB             1974   ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
0008CB             1975   ; Parameters:
0008CB             1976   ; - HL: Repeat rate
0008CB             1977   ;
0008CB             1978   OSBYTE_0C:		VDU	23
0008CB 3E 17       0001M1         LD      A, VAL
0008CD CD 97 05    0002M1         CALL    OSWRCH
0008D0             1979   			VDU	0
0008D0 3E 00       0001M1         LD      A, VAL
0008D2 CD 97 05    0002M1         CALL    OSWRCH
0008D5             1980   			VDU	vdp_keystate
0008D5 3E 88       0001M1         LD      A, VAL
0008D7 CD 97 05    0002M1         CALL    OSWRCH
0008DA             1981   			VDU	0
0008DA 3E 00       0001M1         LD      A, VAL
0008DC CD 97 05    0002M1         CALL    OSWRCH
0008DF             1982   			VDU 	0
0008DF 3E 00       0001M1         LD      A, VAL
0008E1 CD 97 05    0002M1         CALL    OSWRCH
0008E4             1983   			VDU	L
0008E4 7D          0001M1         LD      A, VAL
0008E5 CD 97 05    0002M1         CALL    OSWRCH
0008E8             1984   			VDU	H
0008E8 7C          0001M1         LD      A, VAL
0008E9 CD 97 05    0002M1         CALL    OSWRCH
0008EC             1985   			VDU	255
0008EC 3E FF       0001M1         LD      A, VAL
0008EE CD 97 05    0002M1         CALL    OSWRCH
0008F1 C9          1986   			RET
0008F2             1987   
0008F2             1988   ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
0008F2             1989   ;
0008F2 CD 71 0A    1990   OSBYTE_13:		CALL	WAIT_VBLANK
0008F5 2E 00       1991   			LD	L, 0			; Returns 0
0008F7 C3 34 1B    1992   			JP	COUNT0
0008FA             1993   ;
0008FA             1994   ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
0008FA             1995   ; Parameters:
0008FA             1996   ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
0008FA             1997   ;
0008FA             1998   OSBYTE_76:		VDU	23
0008FA 3E 17       0001M1         LD      A, VAL
0008FC CD 97 05    0002M1         CALL    OSWRCH
0008FF             1999   			VDU	0
0008FF 3E 00       0001M1         LD      A, VAL
000901 CD 97 05    0002M1         CALL    OSWRCH
000904             2000   			VDU	vdp_keystate
000904 3E 88       0001M1         LD      A, VAL
000906 CD 97 05    0002M1         CALL    OSWRCH
000909             2001   			VDU	0
000909 3E 00       0001M1         LD      A, VAL
00090B CD 97 05    0002M1         CALL    OSWRCH
00090E             2002   			VDU 	0
00090E 3E 00       0001M1         LD      A, VAL
000910 CD 97 05    0002M1         CALL    OSWRCH
000913             2003   			VDU	0
000913 3E 00       0001M1         LD      A, VAL
000915 CD 97 05    0002M1         CALL    OSWRCH
000918             2004   			VDU	0
000918 3E 00       0001M1         LD      A, VAL
00091A CD 97 05    0002M1         CALL    OSWRCH
00091D             2005   			VDU	L
00091D 7D          0001M1         LD      A, VAL
00091E CD 97 05    0002M1         CALL    OSWRCH
000921 C9          2006   			RET
000922             2007   
000922             2008   ; OSBYTE 0x81: Read the keyboard
000922             2009   ; Parameters:
000922             2010   ; - HL = Time to wait (centiseconds)
000922             2011   ; Returns:
000922             2012   ; - F: Carry reset indicates time-out
000922             2013   ; - A: If carry set, A = character typed
000922             2014   ; Destroys: A,D,E,H,L,F
000922             2015   ;
000922 CD 11 06    2016   OSBYTE_81:		CALL	READKEY			; Read the keyboard
000925 28 09       2017   			JR	Z, @F 			; Skip if we have a key
000927 7C          2018   			LD	A, H 			; Check loop counter
000928 B5          2019   			OR 	L
000929 C8          2020   			RET 	Z 			; Return, we've not got a key at this point
00092A CD 71 0A    2021   			CALL	WAIT_VBLANK 		; Wait a frame
00092D 2B          2022   			DEC 	HL			; Decrement
00092E 18 F2       2023   			JR	OSBYTE_81		; And loop
000930             2024   ;
000930 21 FA 50    2025   @@:			LD	HL, KEYDOWN		; We have a key, so
000933 36 00       2026   			LD	(HL), 0			; clear the keydown flag
000935 FE 1B       2027   			CP	1BH			; If we are not pressing ESC,
000937 37          2028   			SCF 				; then flag we've got a character
000938 C0          2029   			RET	NZ
000939 C3 FC 05    2030   			JP	ESCSET			; Handle ESC
00093C             2031   
00093C             2032   ; OSBYTE 0x86: Fetch cursor coordinates
00093C             2033   ; Returns:
00093C             2034   ; - DE: X Coordinate (POS)
00093C             2035   ; - HL: Y Coordinate (VPOS)
00093C             2036   ;
00093C DD E5       2037   OSBYTE_86:		PUSH	IX			; Get the system vars in IX
00093E             2038   			MOSCALL	mos_sysvars		; Reset the semaphore
00093E 3E 08       0001M1 			LD	A, function
000940 49 CF       0002M1 			RST.LIS	08h
000942 5B DD CB 04 2039   			RES.LIL	0, (IX+sysvar_vpd_pflags)
       86          
000947             2040   			VDU	23
000947 3E 17       0001M1         LD      A, VAL
000949 CD 97 05    0002M1         CALL    OSWRCH
00094C             2041   			VDU	0
00094C 3E 00       0001M1         LD      A, VAL
00094E CD 97 05    0002M1         CALL    OSWRCH
000951             2042   			VDU	vdp_cursor
000951 3E 82       0001M1         LD      A, VAL
000953 CD 97 05    0002M1         CALL    OSWRCH
000956 5B DD CB 04 2043   @@:			BIT.LIL	0, (IX+sysvar_vpd_pflags)
       46          
00095B 28 F9       2044   			JR	Z, @B			; Wait for the result
00095D 16 00       2045   			LD 	D, 0
00095F 62          2046   			LD	H, D
000960 5B DD 5E 07 2047   			LD.LIL	E, (IX + sysvar_cursorX)
000964 5B DD 6E 08 2048   			LD.LIL	L, (IX + sysvar_cursorY)
000968 DD E1       2049   			POP	IX
00096A C9          2050   			RET
00096B             2051   
00096B             2052   ; OSBYTE 0x87: Fetch current mode and character under cursor
00096B             2053   ;
00096B DD E5       2054   OSBYTE_87:		PUSH	IX
00096D CD 8F 0D    2055   			CALL	GETCSR			; Get the current screen position
000970 CD 00 00    2056   			CALL	GETSCHR_1		; Read character from screen
