PC     Output      Line
040000             0001        .ASSUME ADL = 0
040000             0002    	.ORG 0x0000
000000             0003    
000000             0004        include "mos_api.inc"
000000             0001*   ;
000000             0002*   ; Title:	AGON MOS - API for user projects
000000             0003*   ; Author:	Dean Belfield
000000             0004*   ; Created:	03/08/2022
000000             0005*   ; Last Updated:	11/11/2023
000000             0006*   ;
000000             0007*   ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
000000             0008*   ;
000000             0009*   ; Modinfo:
000000             0010*   ; 05/08/2022:	Added mos_feof
000000             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
000000             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
000000             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
000000             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
000000             0015*   ; 13/10/2022:	Added mos_oscli
000000             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
000000             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
000000             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
000000             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
000000             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
000000             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
000000             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
000000             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
000000             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
000000             0025*   ; 19/05/2023:	Added sysvar_scrMode
000000             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
000000             0027*   ; 03/08/2023:	Added mos_setkbvector
000000             0028*   ; 10/08/2023:	Added mos_getkbmap
000000             0029*   ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
000000             0030*   ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
000000             0031*   ;
000000             0032*   ; VDP control (VDU 23, 0, n)
000000             0033*   ;
000000             0034*   vdp_gp:			EQU 	80h
000000             0035*   vdp_keycode:		EQU 	81h
000000             0036*   vdp_cursor:		EQU	82h
000000             0037*   vdp_scrchar:		EQU	83h
000000             0038*   vdp_scrpixel:		EQU	84h
000000             0039*   vdp_audio:		EQU	85h
000000             0040*   vdp_mode:		EQU	86h
000000             0041*   vdp_rtc:		EQU	87h
000000             0042*   vdp_keystate:		EQU	88h
000000             0043*   vdp_logicalcoords:	EQU	C0h
000000             0044*   vdp_terminalmode:	EQU	FFh
000000             0045*   
000000             0046*   ; MOS high level functions
000000             0047*   ;
000000             0048*   mos_getkey:		EQU	00h
000000             0049*   mos_load:		EQU	01h
000000             0050*   mos_save:		EQU	02h
000000             0051*   mos_cd:			EQU	03h
000000             0052*   mos_dir:		EQU	04h
000000             0053*   mos_del:		EQU	05h
000000             0054*   mos_ren:		EQU	06h
000000             0055*   mos_mkdir:		EQU	07h
000000             0056*   mos_sysvars:		EQU	08h
000000             0057*   mos_editline:		EQU	09h
000000             0058*   mos_fopen:		EQU	0Ah
000000             0059*   mos_fclose:		EQU	0Bh
000000             0060*   mos_fgetc:		EQU	0Ch
000000             0061*   mos_fputc:		EQU	0Dh
000000             0062*   mos_feof:		EQU	0Eh
000000             0063*   mos_getError:		EQU	0Fh
000000             0064*   mos_oscli:		EQU	10h
000000             0065*   mos_copy:		EQU	11h
000000             0066*   mos_getrtc:		EQU	12h
000000             0067*   mos_setrtc:		EQU	13h
000000             0068*   mos_setintvector:	EQU	14h
000000             0069*   mos_uopen:		EQU	15h
000000             0070*   mos_uclose:		EQU	16h
000000             0071*   mos_ugetc:		EQU	17h
000000             0072*   mos_uputc:		EQU 	18h
000000             0073*   mos_getfil:		EQU	19h
000000             0074*   mos_fread:		EQU	1Ah
000000             0075*   mos_fwrite:		EQU	1Bh
000000             0076*   mos_flseek:		EQU	1Ch
000000             0077*   mos_setkbvector:	EQU	1Dh
000000             0078*   mos_getkbmap:		EQU	1Eh
000000             0079*   mos_i2c_open:		EQU	1Fh
000000             0080*   mos_i2c_close:		EQU	20h
000000             0081*   mos_i2c_write:		EQU	21h
000000             0082*   mos_i2c_read:		EQU	22h
000000             0083*   
000000             0084*   
000000             0085*   ; FatFS file access functions
000000             0086*   ;
000000             0087*   ffs_fopen:		EQU	80h
000000             0088*   ffs_fclose:		EQU	81h
000000             0089*   ffs_fread:		EQU	82h
000000             0090*   ffs_fwrite:		EQU	83h
000000             0091*   ffs_flseek:		EQU	84h
000000             0092*   ffs_ftruncate:		EQU	85h
000000             0093*   ffs_fsync:		EQU	86h
000000             0094*   ffs_fforward:		EQU	87h
000000             0095*   ffs_fexpand:		EQU	88h
000000             0096*   ffs_fgets:		EQU	89h
000000             0097*   ffs_fputc:		EQU	8Ah
000000             0098*   ffs_fputs:		EQU	8Bh
000000             0099*   ffs_fprintf:		EQU	8Ch
000000             0100*   ffs_ftell:		EQU	8Dh
000000             0101*   ffs_feof:		EQU	8Eh
000000             0102*   ffs_fsize:		EQU	8Fh
000000             0103*   ffs_ferror:		EQU	90h
000000             0104*   
000000             0105*   ; FatFS directory access functions
000000             0106*   ;
000000             0107*   ffs_dopen:		EQU	91h
000000             0108*   ffs_dclose:		EQU	92h
000000             0109*   ffs_dread:		EQU	93h
000000             0110*   ffs_dfindfirst:		EQU	94h
000000             0111*   ffs_dfindnext:		EQU	95h
000000             0112*   
000000             0113*   ; FatFS file and directory management functions
000000             0114*   ;
000000             0115*   ffs_stat:		EQU	96h
000000             0116*   ffs_unlink:		EQU	97h
000000             0117*   ffs_rename:		EQU	98h
000000             0118*   ffs_chmod:		EQU	99h
000000             0119*   ffs_utime:		EQU	9Ah
000000             0120*   ffs_mkdir:		EQU	9Bh
000000             0121*   ffs_chdir:		EQU	9Ch
000000             0122*   ffs_chdrive:		EQU	9Dh
000000             0123*   ffs_getcwd:		EQU	9Eh
000000             0124*   
000000             0125*   ; FatFS volume management and system configuration functions
000000             0126*   ;
000000             0127*   ffs_mount:		EQU	9Fh
000000             0128*   ffs_mkfs:		EQU	A0h
000000             0129*   ffs_fdisk:		EQU	A1h
000000             0130*   ffs_getfree:		EQU	A2h
000000             0131*   ffs_getlabel:		EQU	A3h
000000             0132*   ffs_setlabel:		EQU	A4h
000000             0133*   ffs_setcp:		EQU	A5h
000000             0134*   
000000             0135*   ; File access modes
000000             0136*   ;
000000             0137*   fa_read:		EQU	01h
000000             0138*   fa_write:		EQU	02h
000000             0139*   fa_open_existing:	EQU	00h
000000             0140*   fa_create_new:		EQU	04h
000000             0141*   fa_create_always:	EQU	08h
000000             0142*   fa_open_always:		EQU	10h
000000             0143*   fa_open_append:		EQU	30h
000000             0144*   
000000             0145*   ; System variable indexes for api_sysvars
000000             0146*   ; Index into _sysvars in globals.asm
000000             0147*   ;
000000             0148*   sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
000000             0149*   sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
000000             0150*   sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
000000             0151*   sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
000000             0152*   sysvar_cursorX:		EQU	07h	; 1: Cursor X position
000000             0153*   sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
000000             0154*   sysvar_scrchar:		EQU	09h	; 1: Character read from screen
000000             0155*   sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
000000             0156*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
000000             0157*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
000000             0158*   sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
000000             0159*   sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
000000             0160*   sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
000000             0161*   sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
000000             0162*   sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
000000             0163*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
000000             0164*   sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
000000             0165*   sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
000000             0166*   sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
000000             0167*   sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
000000             0168*   sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
000000             0169*   sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
000000             0170*   sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
000000             0171*   sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
000000             0172*   sysvar_scrMode:		EQU	27h	; 1: Screen mode
000000             0173*   sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
000000             0174*   sysvar_mouseX:		EQU	29h	; 2: Mouse X position
000000             0175*   sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
000000             0176*   sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
000000             0177*   sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
000000             0178*   sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
000000             0179*   sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
000000             0180*   ;
000000             0181*   ; Flags for the VPD protocol
000000             0182*   ;
000000             0183*   vdp_pflag_cursor:	EQU	00000001b
000000             0184*   vdp_pflag_scrchar:	EQU	00000010b
000000             0185*   vdp_pflag_point:	EQU	00000100b
000000             0186*   vdp_pflag_audio:	EQU	00001000b
000000             0187*   vdp_pflag_mode:		EQU	00010000b
000000             0188*   vdp_pflag_rtc:		EQU	00100000b
000000             0189*   vdp_pflag_mouse:	EQU	01000000b
000000             0190*   ; vdp_pflag_buffered:	EQU	10000000b
000000             0191*   
000000             0192*   
000000             0193*   ; FatFS structures
000000             0194*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
000000             0195*   ;
000000             0196*   ; Object ID and allocation information (FFOBJID)
000000             0197*   FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
000000             0198*   FFOBJID.id:       EQU 3    ; Hosting volume mount ID
000000             0199*   FFOBJID.attr:     EQU 5    ; Object attribute
000000             0200*   FFOBJID.stat:     EQU 6    ; Object chain status
000000             0201*   FFOBJID.sclust:   EQU 7    ; Object data start cluster
000000             0202*   FFOBJID.objsize:  EQU 11   ; Object size
000000             0203*   FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
000000             0204*   ;
000000             0205*   ; File object structure (FIL)
000000             0206*   ;
000000             0207*   FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
000000             0208*   FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
000000             0209*   FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
000000             0210*   FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
000000             0211*   FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
000000             0212*   FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
000000             0213*   FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
000000             0214*   FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
000000             0215*   FIL.obj.objsize:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
000000             0216*   ;
000000             0217*   ; Directory object structure (DIR)
000000             0218*   ;
000000             0219*   DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
000000             0220*   DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
000000             0221*   DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
000000             0222*   DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
000000             0223*   DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
000000             0224*   DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
000000             0225*   DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
000000             0226*   DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
000000             0227*   ;
000000             0228*   ; File information structure (FILINFO)
000000             0229*   ;
000000             0230*   FILINFO.fsize:    EQU 0    ; File size
000000             0231*   FILINFO.fdate:    EQU 4    ; Modified date
000000             0232*   FILINFO.ftime:    EQU 6    ; Modified time
000000             0233*   FILINFO.fattrib:  EQU 8    ; File attribute
000000             0234*   FILINFO.altname:  EQU 9    ; Alternative file name
000000             0235*   FILINFO.fname:    EQU 22   ; Primary file name
000000             0236*   FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
000000             0237*   ;
000000             0238*   ; Macro for calling the API
000000             0239*   ; Parameters:
000000             0240*   ; - function: One of the function numbers listed above
000000             0241*   ;
000000             0242*   			MACRO MOSCALL	function
000000             0243*   			LD	A, function
000000             0244*   			RST.LIS	08h
000000             0245*   			ENDMACRO
000000             0005        include "equs.inc"
000000             0001*   ; ; TEMPORARY LABELS FOR PIECEMEAL ASSEMBLY
000000             0002*   ; STAVAR: EQU 0
000000             0003*   ; ACCS: EQU 0
000000             0004*   ; ; END TEMPORARY LABELS FOR PIECEMEAL ASSEMBLY
000000             0005*   
000000             0006*   ;
000000             0007*   ; Title:	BBC Basic for AGON - Equs
000000             0008*   ; Author:	Dean Belfield
000000             0009*   ; Created:	04/12/2024
000000             0010*   ; Last Updated:	05/12/2024
000000             0011*   ;
000000             0012*   ; Modinfo:
000000             0013*   ; 05/12/2024:	Removed Stack_Top
000000             0014*   
000000             0015*   ;			XREF		STAVAR
000000             0016*   ;			XREF		ACCS
000000             0017*   
000000             0018*   RAM_Top:		EQU		0FF00h
000000             0019*   
000000             0020*   ; For GPIO
000000             0021*   ; PA not available on eZ80L92
000000             0022*   ;
000000             0023*   PA_DR:			EQU		96h
000000             0024*   PA_DDR:			EQU		97h
000000             0025*   PA_ALT1:		EQU		98h
000000             0026*   PA_ALT2:		EQU		99h
000000             0027*   PB_DR:          	EQU		9Ah
000000             0028*   PB_DDR:        	 	EQU		9Bh
000000             0029*   PB_ALT1:        	EQU		9Ch
000000             0030*   PB_ALT2:        	EQU		9Dh
000000             0031*   PC_DR:          	EQU		9Eh
000000             0032*   PC_DDR:         	EQU		9Fh
000000             0033*   PC_ALT1:        	EQU		A0h
000000             0034*   PC_ALT2:        	EQU		A1h
000000             0035*   PD_DR:          	EQU		A2h
000000             0036*   PD_DDR:			EQU		A3h
000000             0037*   PD_ALT1:		EQU		A4h
000000             0038*   PD_ALT2:		EQU		A5h
000000             0039*   
000000             0040*   GPIOMODE_OUT:		EQU		0	; Output
000000             0041*   GPIOMODE_IN:		EQU		1	; Input
000000             0042*   GPIOMODE_DIO:		EQU		2	; Open Drain IO
000000             0043*   GPIOMODE_SIO:		EQU		3	; Open Source IO
000000             0044*   GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
000000             0045*   GPIOMODE_ALTF:		EQU		5;	; Alt Function
000000             0046*   GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
000000             0047*   GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
000000             0048*   GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
000000             0049*   GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
000000             0050*   
000000             0051*   ; Originally in ram.asm
000000             0052*   ;
000000             0053*   ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%) ; back to data.asm
000000             0054*   ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%) ; back to data.asm
000000             0055*   ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands ; moved to data.asm
000000             0056*   
000000             0057*   ; Originally in main.asm
000000             0058*   ;
000000             0059*   CR:			EQU     0DH
000000             0060*   LF:			EQU     0AH
000000             0061*   ESC:			EQU     1BH
000000             0006        include "macros.inc"
000000             0001*   ;
000000             0002*   ; Title:	BBC Basic Interpreter - Z80 version
000000             0003*   ;		Useful macros
000000             0004*   ; Author:	Dean Belfield
000000             0005*   ; Created:	04/12/2024
000000             0006*   ; Last Updated:	04/12/2024
000000             0007*   ;
000000             0008*   ; Modinfo:
000000             0009*   
000000             0010*           MACRO EXREG rp1, rp2
000000             0011*           PUSH    rp1
000000             0012*           POP     rp2
000000             0013*           ENDMACRO
000000             0014*   
000000             0015*           MACRO ADD8U_DE ; reg
000000             0016*           ADD     A, E
000000             0017*           LD      E, A
000000             0018*           ADC     A, D
000000             0019*           SUB     E
000000             0020*           LD      D, A
000000             0021*           ENDMACRO
000000             0022*   
000000             0023*           MACRO ADD8U_HL ; reg
000000             0024*           ADD     A, L
000000             0025*           LD      L, A
000000             0026*           ADC     A, H
000000             0027*           SUB     L
000000             0028*           LD      H, A
000000             0029*           ENDMACRO
000000             0030*   
000000             0031*           MACRO VDU VAL
000000             0032*           LD      A, VAL
000000             0033*           CALL    OSWRCH
000000             0034*           ENDMACRO
000000             0035*   
000000             0036*           MACRO SET_GPIO REG, VAL
000000             0037*           IN0     A, (REG)
000000             0038*           OR      VAL
000000             0039*           OUT0    (REG), A
000000             0040*           ENDMACRO
000000             0041*   
000000             0042*           MACRO RES_GPIO REG, VAL
000000             0043*           PUSH    BC
000000             0044*           LD      A, VAL
000000             0045*           CPL
000000             0046*           LD      C, A
000000             0047*           IN0     A, (REG)
000000             0048*           AND     C
000000             0049*           OUT0    (REG), A
000000             0050*           POP     BC
000000             0051*           ENDMACRO
000000             0007        include "agon_init.asm"
000000             0001*   ;
000000             0002*   ; Title:	BBC Basic for AGON - Initialisation Code
000000             0003*   ;		Initialisation Code
000000             0004*   ; Author:	Dean Belfield
000000             0005*   ; Created:	04/12/2024
000000             0006*   ; Last Updated:	14/12/2024
000000             0007*   ;
000000             0008*   ; Modinfo:
000000             0009*   ; 14/12/2024:	Fix for *BYE command
000000             0010*   
000000             0011*   ;			SEGMENT __VECTORS
000000             0012*   
000000             0013*   ;			XREF	START
000000             0014*   ;			XREF	ACCS
000000             0015*   ;			XREF	TELL
000000             0016*   
000000             0017*   			.ASSUME	ADL = 0
000000             0018*   			.ORG 0x0000
000000             0019*   
000000             0020*   			; INCLUDE	"equs.inc"
000000             0021*   
000000             0022*   argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
000000             0023*   
000000             0024*   ;
000000             0025*   ; Start in mixed mode. Assumes MBASE is set to correct segment
000000             0026*   ;
000000 C3 52 00    0027*   			JP	_start				; Jump to start
000003             0028*   			DS	5
000008             0029*   
       FF FF FF FF 
       FF 
000008 49 CF       0030*   RST_08:			RST.LIS	08h				; API call
00000A C9          0031*   			RET
00000B             0032*   			DS 	5
000010             0033*   
       FF FF FF FF 
       FF 
000010 49 D7       0034*   RST_10:			RST.LIS 10h				; Output
000012 C9          0035*   			RET
000013             0036*   			DS	5
000018             0037*   
       FF FF FF FF 
       FF 
000018 49 DF       0038*   RST_18:			RST.LIS	18h				; Block Output
00001A C9          0039*   			RET
00001B             0040*   			DS	5
000020             0041*   
000020             0042*   RST_20:			DS	8
000028             0043*   RST_28:			DS	8
000030             0044*   RST_30:			DS	8
000038             0045*   
000038             0046*   ;
000038             0047*   ; The NMI interrupt vector (not currently used by AGON)
000038             0048*   ;
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF 
000038 FB          0049*   RST_38:			EI
000039 ED 4D       0050*   			RETI
00003B             0051*   ;
00003B             0052*   ; The header stuff is from byte 64 onwards
00003B             0053*   ;
00003B FF FF FF FF 0054*   			ALIGN	64
       FF          
000040             0055*   
000040 4D 4F 53    0056*   			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
000043 00          0057*   			DB	00h				; MOS header version 0
000044 00          0058*   			DB	00h				; Flag for run mode (0: Z80, 1: ADL)
000045             0059*   
000045 42 42 43 42 0060*   _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
       41 53 49 43 
       2E 42 49 4E 
       00          
000052             0061*   
000052             0062*   ;
000052             0063*   ; And the code follows on immediately after the header
000052             0064*   ;
000052 5B FD E5    0065*   _start:			PUSH.LIL	IY			; Preserve IY
000055             0066*   
000055 FD 21 00 00 0067*   			LD		IY, 0			; Preserve SPS
000059 FD 39       0068*   			ADD		IY, SP
00005B 5B FD E5    0069*   			PUSH.LIL	IY
00005E             0070*   
00005E E3          0071*   			EX		(SP), HL		; Get the SPS part of the return address
00005F 5B E5       0072*   			PUSH.LIL	HL
000061 E3          0073*   			EX		(SP), HL		; And restore it for BASIC
000062             0074*   
000062 5B F5       0075*   			PUSH.LIL	AF			; Preserve the rest of the registers
000064 5B C5       0076*   			PUSH.LIL	BC
000066 5B D5       0077*   			PUSH.LIL	DE
000068 5B DD E5    0078*   			PUSH.LIL	IX
00006B             0079*   
00006B ED 6E       0080*   			LD		A, MB			; Segment base
00006D DD 21 65 01 0081*   			LD		IX, argv_ptrs		; The argv array pointer address
000071 CD 51 01    0082*   			CALL		_set_aix24		; Convert to a 24-bit address
000074 5B DD E5    0083*   			PUSH.LIL	IX
000077 CD E1 00    0084*   			CALL		_parse_params		; Parse the parameters
00007A 5B DD E1    0085*   			POP.LIL		IX			; IX: argv
00007D 06 00       0086*   			LD		B, 0			;  C: argc
00007F CD 9A 00    0087*   			CALL		_main			; Start user code
000082             0088*   
000082 5B DD E1    0089*   			POP.LIL		IX			; Restore the registers
000085 5B D1       0090*   			POP.LIL		DE
000087 5B C1       0091*   			POP.LIL		BC
000089 5B F1       0092*   			POP.LIL		AF
00008B             0093*   
00008B EB          0094*   			EX		DE, HL 			; DE: Return code from BASIC
00008C 5B E1       0095*   			POP.LIL		HL 			; The SPS part of the return address
00008E 5B FD E1    0096*   			POP.LIL		IY			; Get the preserved SPS
000091 FD F9       0097*   			LD		SP, IY			; Restore SPS
000093 E3          0098*   			EX		(SP), HL		; Store the SPS part of the return address on the stack
000094 EB          0099*   			EX		DE, HL 			; HL: Return code from BASIC
000095             0100*   
000095 5B FD E1    0101*   			POP.LIL		IY			; Restore IY
000098 49 C9       0102*   			RET.L					; Return to MOS
00009A             0103*   
00009A             0104*   ; The main routine
00009A             0105*   ; IXU: argv - pointer to array of parameters
00009A             0106*   ;   C: argc - number of parameters
00009A             0107*   ; Returns:
00009A             0108*   ;  HL: Error code, or 0 if OK
00009A             0109*   ;
00009A 21 00 52    0110*   _main:			LD	HL, ACCS		; Clear the ACCS
00009D 36 00       0111*   			LD	(HL), 0
00009F 79          0112*   			LD	A, C
0000A0 FE 02       0113*   			CP	2
0000A2 28 24       0114*   			JR	Z, _autoload		; 2 parameters = autoload
0000A4 38 35       0115*   			JR	C, _startbasic		; 1 parameter = normal start
0000A6             0116*   ;			CALL	STAR_VERSION		; Output the AGON version
0000A6 CD 7D 45    0117*   			CALL	TELL
0000A9 55 73 61 67 0118*   			DB	"Usage:\n\r"
       65 3A 0A 0D 
0000B1 52 55 4E 20 0119*   			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
0000C4 21 00 00    0120*   			LD	HL, 0			; The error code
0000C7 C9          0121*   			RET
0000C8             0122*   ;
0000C8 5B DD 27 03 0123*   _autoload:		LD.LIL	HL, (IX+3)		; HLU: Address of filename
0000CC 11 00 52    0124*   			LD	DE, ACCS		;  DE: Destination address
0000CF 5B 7E       0125*   @@:			LD.LIL	A, (HL)			; Fetch the filename byte
0000D1 12          0126*   			LD	(DE), A			;
0000D2 5B 23       0127*   			INC.LIL	HL			; Increase the source pointer
0000D4 1C          0128*   			INC	E			; We only need to increase E as ACCS is on a page boundary
0000D5 20 F8       0129*   			JR	NZ, @B			; Loop until we hit a 0 byte
0000D7 1D          0130*   			DEC	E
0000D8 3E 0D       0131*   			LD	A, CR
0000DA 12          0132*   			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
0000DB             0133*   ;
0000DB E1          0134*   _startbasic:		POP	 HL			; Pop the return address to init off SPS
0000DC 5B E5       0135*   			PUSH.LIL HL 			; Stack it on SPL (*BYE will use this as the return address)
0000DE C3 9A 37    0136*   			JP	 START			; And start BASIC
0000E1             0137*   
0000E1             0138*   ; Parse the parameter string into a C array
0000E1             0139*   ; Parameters
0000E1             0140*   ; -   A: Segment base
0000E1             0141*   ; - HLU: Address of parameter string
0000E1             0142*   ; - IXU: Address for array pointer storage
0000E1             0143*   ; Returns:
0000E1             0144*   ; -   C: Number of parameters parsed
0000E1             0145*   ;
0000E1 01 45 00    0146*   _parse_params:		LD		BC, _exec_name		; Get the address of the app name in this segment
0000E4 CD 3F 01    0147*   			CALL		_set_abc24		; Convert it to a 24-bit address based upon segment base
0000E7 5B DD 0F 00 0148*   			LD.LIL		(IX+0), BC		; ARGV[0] = the executable name
0000EB 5B DD 23    0149*   			INC.LIL		IX
0000EE 5B DD 23    0150*   			INC.LIL		IX
0000F1 5B DD 23    0151*   			INC.LIL		IX
0000F4 CD 36 01    0152*   			CALL		_skip_spaces		; Skip HL past any leading spaces
0000F7             0153*   ;
0000F7 01 01 00    0154*   			LD		BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0000FA 06 0F       0155*   			LD		B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0000FC             0156*   ;
0000FC C5          0157*   _parse_params_1:	PUSH		BC			; Stack ARGC
0000FD 5B E5       0158*   			PUSH.LIL	HL			; Stack start address of token
0000FF CD 25 01    0159*   			CALL		_get_token		; Get the next token
000102 79          0160*   			LD		A, C			; A: Length of the token in characters
000103 5B D1       0161*   			POP.LIL		DE			; Start address of token (was in HL)
000105 C1          0162*   			POP		BC			; ARGC
000106 B7          0163*   			OR		A			; Check for A=0 (no token found) OR at end of string
000107 C8          0164*   			RET		Z
000108             0165*   ;
000108 5B DD 1F 00 0166*   			LD.LIL		(IX+0), DE		; Store the pointer to the token
00010C 5B E5       0167*   			PUSH.LIL	HL			; DE=HL
00010E 5B D1       0168*   			POP.LIL		DE
000110 CD 36 01    0169*   			CALL		_skip_spaces		; And skip HL past any spaces onto the next character
000113 AF          0170*   			XOR		A
000114 5B 12       0171*   			LD.LIL		(DE), A			; Zero-terminate the token
000116 5B DD 23    0172*   			INC.LIL		IX
000119 5B DD 23    0173*   			INC.LIL		IX
00011C 5B DD 23    0174*   			INC.LIL		IX			; Advance to next pointer position
00011F 0C          0175*   			INC		C			; Increment ARGC
000120 79          0176*   			LD		A, C			; Check for C >= A
000121 B8          0177*   			CP		B
000122 38 D8       0178*   			JR		C, _parse_params_1	; And loop
000124 C9          0179*   			RET
000125             0180*   
000125             0181*   ; Get the next token
000125             0182*   ; Parameters:
000125             0183*   ; - HL: Address of parameter string
000125             0184*   ; Returns:
000125             0185*   ; - HL: Address of first character after token
000125             0186*   ; -  C: Length of token (in characters)
000125             0187*   ;
000125 0E 00       0188*   _get_token:		LD		C, 0			; Initialise length
000127 5B 7E       0189*   @@:			LD.LIL		A, (HL)			; Get the character from the parameter string
000129 B7          0190*   			OR		A			; Exit if 0 (end of parameter string in MOS)
00012A C8          0191*   			RET 		Z
00012B FE 0D       0192*   			CP		13			; Exit if CR (end of parameter string in BBC BASIC)
00012D C8          0193*   			RET		Z
00012E FE 20       0194*   			CP		' '			; Exit if space (end of token)
000130 C8          0195*   			RET		Z
000131 5B 23       0196*   			INC.LIL		HL			; Advance to next character
000133 0C          0197*   			INC 		C			; Increment length
000134 18 F1       0198*   			JR		@B
000136             0199*   
000136             0200*   ; Skip spaces in the parameter string
000136             0201*   ; Parameters:
000136             0202*   ; - HL: Address of parameter string
000136             0203*   ; Returns:
000136             0204*   ; - HL: Address of next none-space character
000136             0205*   ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
000136             0206*   ;
000136 5B 7E       0207*   _skip_spaces:		LD.LIL		A, (HL)			; Get the character from the parameter string
000138 FE 20       0208*   			CP		' '			; Exit if not space
00013A C0          0209*   			RET		NZ
00013B 5B 23       0210*   			INC.LIL		HL			; Advance to next character
00013D 18 F7       0211*   			JR		_skip_spaces		; Increment length
00013F             0212*   
00013F             0213*   ; Set the MSB of BC (U) to A
00013F             0214*   ; Parameters:
00013F             0215*   ; - BC: 16-bit address
00013F             0216*   ; -  A: Value to stick in U of BC
00013F             0217*   ; Returns:
00013F             0218*   ; - BCU
00013F             0219*   ;
00013F 5B E5       0220*   _set_abc24:		PUSH.LIL	HL			; Preserve HL
000141 5B C5       0221*   			PUSH.LIL	BC			; Stick BC onto SPL
000143 5B 21 02 00 0222*   			LD.LIL		HL, 2			; HL: SP+2
       00          
000148 5B 39       0223*   			ADD.LIL		HL, SP
00014A 5B 77       0224*   			LD.LIL		(HL), A			; Store A in it
00014C 5B C1       0225*   			POP.LIL		BC			; Fetch ammended BC
00014E 5B E1       0226*   			POP.LIL		HL			; Restore HL
000150 C9          0227*   			RET
000151             0228*   
000151             0229*   ; Set the MSB of BC (U) to A
000151             0230*   ; Parameters:
000151             0231*   ; - IX: 16-bit address
000151             0232*   ; -  A: Value to stick in U of BC
000151             0233*   ; Returns:
000151             0234*   ; - IXU
000151             0235*   ;
000151 5B DD E5    0236*   _set_aix24:		PUSH.LIL	IX			; Stick IX onto SPL
000154 5B DD 21 02 0237*   			LD.LIL		IX, 2			; IX: SP+2
       00 00       
00015A 5B DD 39    0238*   			ADD.LIL		IX, SP
00015D 5B DD 77 00 0239*   			LD.LIL		(IX), A			; Store A in it
000161 5B DD E1    0240*   			POP.LIL		IX			; Fetch ammended IX
000164 C9          0241*   			RET
000165             0242*   
000165             0243*   ; Storage for the argv array pointers
000165             0244*   ;
000165 00 00 00 00 0245*   argv_ptrs:		BLKP	argv_ptrs_max, 0		; Storage for the argv array pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
000195             0008        include "agon_graphics.asm"
000195             0001*   ;
000195             0002*   ; Title:	BBC Basic for AGON - Graphics stuff
000195             0003*   ; Author:	Dean Belfield
000195             0004*   ; Created:	04/12/2024
000195             0005*   ; Last Updated:	17/12/2024
000195             0006*   ;
000195             0007*   ; Modinfo:
000195             0008*   ; 11/12/2024:	Modified POINT_ to work with OSWORD
000195             0009*   ; 17/12/2024:	Modified GETSCHR
000195             0010*   
000195             0011*   			.ASSUME	ADL = 0
000195             0012*   
000195             0013*   			; INCLUDE	"equs.inc"
000195             0014*   			; INCLUDE "macros.inc"
000195             0015*   			; INCLUDE "mos_api.inc"	; In MOS/src
000195             0016*   
000195             0017*   			; SEGMENT CODE
000195             0018*   
000195             0019*   			; XDEF	MODE_
000195             0020*   			; XDEF	COLOUR_
000195             0021*   			; XDEF	POINT_
000195             0022*   			; XDEF	GETSCHR
000195             0023*   
000195             0024*   			; XREF	ACCS
000195             0025*   			; XREF	OSWRCH
000195             0026*   			; XREF	ASC_TO_NUMBER
000195             0027*   			; XREF	EXTERR
000195             0028*   			; XREF	EXPRI
000195             0029*   			; XREF	COMMA
000195             0030*   			; XREF	XEQ
000195             0031*   			; XREF	NXT
000195             0032*   			; XREF	BRAKET
000195             0033*   			; XREF	CRTONULL
000195             0034*   			; XREF	NULLTOCR
000195             0035*   			; XREF	CRLF
000195             0036*   			; XREF	EXPR_W2
000195             0037*   
000195             0038*   ; MODE n: Set video mode
000195             0039*   ;
000195 DD E5       0040*   MODE_:			PUSH	IX			; Get the system vars in IX
000197             0041*   			MOSCALL	mos_sysvars		; Reset the semaphore
000197 3E 08       0001*M1 			LD	A, function
000199 49 CF       0002*M1 			RST.LIS	08h
00019B 5B DD CB 04 0042*   			RES.LIL	4, (IX+sysvar_vpd_pflags)
       A6          
0001A0 CD B6 18    0043*   			CALL    EXPRI
0001A3 D9          0044*   			EXX
0001A4             0045*   			VDU	16H			; Mode change
0001A4 3E 16       0001*M1         LD      A, VAL
0001A6 CD 97 05    0002*M1         CALL    OSWRCH
0001A9             0046*   			VDU	L
0001A9 7D          0001*M1         LD      A, VAL
0001AA CD 97 05    0002*M1         CALL    OSWRCH
0001AD             0047*   			MOSCALL	mos_sysvars
0001AD 3E 08       0001*M1 			LD	A, function
0001AF 49 CF       0002*M1 			RST.LIS	08h
0001B1 5B DD CB 04 0048*   @@:			BIT.LIL	4, (IX+sysvar_vpd_pflags)
       66          
0001B6 28 F9       0049*   			JR	Z, @B			; Wait for the result
0001B8 DD E1       0050*   			POP	IX
0001BA C3 1C 25    0051*   			JP	XEQ
0001BD             0052*   
0001BD             0053*   ;
0001BD             0054*   ; Fetch a character from the screen
0001BD             0055*   ; - DE: X coordinate
0001BD             0056*   ; - HL: Y coordinate
0001BD             0057*   ; Returns
0001BD             0058*   ; - A: The character or FFh if no match
0001BD             0059*   ; - F: C if match, otherwise NC
0001BD             0060*   ;
0001BD DD E5       0061*   GETSCHR:		PUSH	IX			; Get the system vars in IX
0001BF             0062*   			MOSCALL	mos_sysvars		; Reset the semaphore
0001BF 3E 08       0001*M1 			LD	A, function
0001C1 49 CF       0002*M1 			RST.LIS	08h
0001C3 5B DD CB 04 0063*   			RES.LIL	1, (IX+sysvar_vpd_pflags)
       8E          
0001C8             0064*   			VDU	23
0001C8 3E 17       0001*M1         LD      A, VAL
0001CA CD 97 05    0002*M1         CALL    OSWRCH
0001CD             0065*   			VDU	0
0001CD 3E 00       0001*M1         LD      A, VAL
0001CF CD 97 05    0002*M1         CALL    OSWRCH
0001D2             0066*   			VDU	vdp_scrchar
0001D2 3E 83       0001*M1         LD      A, VAL
0001D4 CD 97 05    0002*M1         CALL    OSWRCH
0001D7             0067*   			VDU	E
0001D7 7B          0001*M1         LD      A, VAL
0001D8 CD 97 05    0002*M1         CALL    OSWRCH
0001DB             0068*   			VDU	D
0001DB 7A          0001*M1         LD      A, VAL
0001DC CD 97 05    0002*M1         CALL    OSWRCH
0001DF             0069*   			VDU	L
0001DF 7D          0001*M1         LD      A, VAL
0001E0 CD 97 05    0002*M1         CALL    OSWRCH
0001E3             0070*   			VDU	H
0001E3 7C          0001*M1         LD      A, VAL
0001E4 CD 97 05    0002*M1         CALL    OSWRCH
0001E7 5B DD CB 04 0071*   @@:			BIT.LIL	1, (IX+sysvar_vpd_pflags)
       4E          
0001EC 28 F9       0072*   			JR	Z, @B			; Wait for the result
0001EE 5B DD 7E 09 0073*   			LD.LIL	A, (IX+sysvar_scrchar)	; Fetch the result in A
0001F2 B7          0074*   			OR	A			; Check for 00h
0001F3 37          0075*   			SCF				; C = character map
0001F4 20 01       0076*   			JR	NZ, @F			; We have a character, so skip next bit
0001F6 AF          0077*   			XOR	A			; Clear carry
0001F7 DD E1       0078*   @@:			POP	IX
0001F9 C9          0079*   			RET
0001FA             0080*   
0001FA             0081*   ; POINT(x,y): Get the pixel colour of a point on screen
0001FA             0082*   ; Parameters:
0001FA             0083*   ; - DE: X-coordinate
0001FA             0084*   ; - HL: Y-coordinate
0001FA             0085*   ; Returns:
0001FA             0086*   ; -  A: Pixel colour
0001FA             0087*   ;
0001FA DD E5       0088*   POINT_:			PUSH	IX			; Get the system vars in IX
0001FC             0089*   			MOSCALL	mos_sysvars		; Reset the semaphore
0001FC 3E 08       0001*M1 			LD	A, function
0001FE 49 CF       0002*M1 			RST.LIS	08h
000200 5B DD CB 04 0090*   			RES.LIL	2, (IX+sysvar_vpd_pflags)
       96          
000205             0091*   			VDU	23
000205 3E 17       0001*M1         LD      A, VAL
000207 CD 97 05    0002*M1         CALL    OSWRCH
00020A             0092*   			VDU	0
00020A 3E 00       0001*M1         LD      A, VAL
00020C CD 97 05    0002*M1         CALL    OSWRCH
00020F             0093*   			VDU	vdp_scrpixel
00020F 3E 84       0001*M1         LD      A, VAL
000211 CD 97 05    0002*M1         CALL    OSWRCH
000214             0094*   			VDU	E
000214 7B          0001*M1         LD      A, VAL
000215 CD 97 05    0002*M1         CALL    OSWRCH
000218             0095*   			VDU	D
000218 7A          0001*M1         LD      A, VAL
000219 CD 97 05    0002*M1         CALL    OSWRCH
00021C             0096*   			VDU	L
00021C 7D          0001*M1         LD      A, VAL
00021D CD 97 05    0002*M1         CALL    OSWRCH
000220             0097*   			VDU	H
000220 7C          0001*M1         LD      A, VAL
000221 CD 97 05    0002*M1         CALL    OSWRCH
000224 5B DD CB 04 0098*   @@:			BIT.LIL	2, (IX+sysvar_vpd_pflags)
       56          
000229 28 F9       0099*   			JR	Z, @B			; Wait for the result
00022B             0100*   ;
00022B             0101*   ; Return the data as a 1 byte index
00022B             0102*   ;
00022B 5B DD 7E 16 0103*   			LD.LIL	A, (IX+sysvar_scrpixelIndex)
00022F DD E1       0104*   			POP	IX
000231 C9          0105*   			RET
000232             0106*   
000232             0107*   ; COLOUR colour
000232             0108*   ; COLOUR L,P
000232             0109*   ; COLOUR L,R,G,B
000232             0110*   ;
000232 CD B6 18    0111*   COLOUR_:		CALL	EXPRI			; The colour / mode
000235 D9          0112*   			EXX
000236 7D          0113*   			LD	A, L
000237 32 00 52    0114*   			LD	(VDU_BUFFER+0), A	; Store first parameter
00023A CD 8E 45    0115*   			CALL	NXT			; Are there any more parameters?
00023D FE 2C       0116*   			CP	','
00023F 28 0E       0117*   			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
000241             0118*   ;
000241             0119*   			VDU	11h			; Just set the colour
000241 3E 11       0001*M1         LD      A, VAL
000243 CD 97 05    0002*M1         CALL    OSWRCH
000246             0120*   			VDU	(VDU_BUFFER+0)
000246 3A 00 52    0001*M1         LD      A, VAL
000249 CD 97 05    0002*M1         CALL    OSWRCH
00024C C3 1C 25    0121*   			JP	XEQ
00024F             0122*   ;
00024F CD 25 21    0123*   COLOUR_1:		CALL	COMMA
000252 CD B6 18    0124*   			CALL	EXPRI			; Parse R (OR P)
000255 D9          0125*   			EXX
000256 7D          0126*   			LD	A, L
000257 32 01 52    0127*   			LD	(VDU_BUFFER+1), A
00025A CD 8E 45    0128*   			CALL	NXT			; Are there any more parameters?
00025D FE 2C       0129*   			CP	','
00025F 28 23       0130*   			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
000261             0131*   ;
000261             0132*   			VDU	13h			; VDU:COLOUR
000261 3E 13       0001*M1         LD      A, VAL
000263 CD 97 05    0002*M1         CALL    OSWRCH
000266             0133*   			VDU	(VDU_BUFFER+0)		; Logical Colour
000266 3A 00 52    0001*M1         LD      A, VAL
000269 CD 97 05    0002*M1         CALL    OSWRCH
00026C             0134*   			VDU	(VDU_BUFFER+1)		; Palette Colour
00026C 3A 01 52    0001*M1         LD      A, VAL
00026F CD 97 05    0002*M1         CALL    OSWRCH
000272             0135*   			VDU	0			; RGB set to 0
000272 3E 00       0001*M1         LD      A, VAL
000274 CD 97 05    0002*M1         CALL    OSWRCH
000277             0136*   			VDU	0
000277 3E 00       0001*M1         LD      A, VAL
000279 CD 97 05    0002*M1         CALL    OSWRCH
00027C             0137*   			VDU	0
00027C 3E 00       0001*M1         LD      A, VAL
00027E CD 97 05    0002*M1         CALL    OSWRCH
000281 C3 1C 25    0138*   			JP	XEQ
000284             0139*   ;
000284 CD 25 21    0140*   COLOUR_2:		CALL	COMMA
000287 CD B6 18    0141*   			CALL	EXPRI			; Parse G
00028A D9          0142*   			EXX
00028B 7D          0143*   			LD	A, L
00028C 32 02 52    0144*   			LD	(VDU_BUFFER+2), A
00028F CD 25 21    0145*   			CALL	COMMA
000292 CD B6 18    0146*   			CALL	EXPRI			; Parse B
000295 D9          0147*   			EXX
000296 7D          0148*   			LD	A, L
000297 32 03 52    0149*   			LD	(VDU_BUFFER+3), A
00029A             0150*   			VDU	13h			; VDU:COLOUR
00029A 3E 13       0001*M1         LD      A, VAL
00029C CD 97 05    0002*M1         CALL    OSWRCH
00029F             0151*   			VDU	(VDU_BUFFER+0)		; Logical Colour
00029F 3A 00 52    0001*M1         LD      A, VAL
0002A2 CD 97 05    0002*M1         CALL    OSWRCH
0002A5             0152*   			VDU	FFh			; Physical Colour (-1 for RGB mode)
0002A5 3E FF       0001*M1         LD      A, VAL
0002A7 CD 97 05    0002*M1         CALL    OSWRCH
0002AA             0153*   			VDU	(VDU_BUFFER+1)		; R
0002AA 3A 01 52    0001*M1         LD      A, VAL
0002AD CD 97 05    0002*M1         CALL    OSWRCH
0002B0             0154*   			VDU	(VDU_BUFFER+2)		; G
0002B0 3A 02 52    0001*M1         LD      A, VAL
0002B3 CD 97 05    0002*M1         CALL    OSWRCH
0002B6             0155*   			VDU	(VDU_BUFFER+3)		; B
0002B6 3A 03 52    0001*M1         LD      A, VAL
0002B9 CD 97 05    0002*M1         CALL    OSWRCH
0002BC C3 1C 25    0156*   			JP	XEQ
0002BF             0009        include "agon_gpio.asm"
0002BF             0001*   ;
0002BF             0002*   ; Title:	BBC Basic for AGON - GPIO functions
0002BF             0003*   ; Author:	Dean Belfield
0002BF             0004*   ; Created:	04/12/2024
0002BF             0005*   ; Last Updated:	04/12/2024
0002BF             0006*   ;
0002BF             0007*   ; Modinfo:
0002BF             0008*   
0002BF             0009*   			; INCLUDE	"macros.inc"
0002BF             0010*   			; INCLUDE	"equs.inc"
0002BF             0011*   
0002BF             0012*   			.ASSUME	ADL = 0
0002BF             0013*   ;	.ORG 0x0000
0002BF             0014*   
0002BF             0015*   ;			SEGMENT CODE
0002BF             0016*   
0002BF             0017*   ;			XDEF	GPIOB_SETMODE
0002BF             0018*   
0002BF             0019*   ;			XREF	SWITCH_A
0002BF             0020*   
0002BF             0021*   ;  A: Mode
0002BF             0022*   ;  B: Pins
0002BF             0023*   ;
0002BF CD 18 05    0024*   GPIOB_SETMODE:		CALL	SWITCH_A
0002C2 D6 02       0025*   			DW	GPIOB_M0	; Output
0002C4 FB 02       0026*   			DW	GPIOB_M1	; Input
0002C6 1B 03       0027*   			DW	GPIOB_M2	; Open Drain IO
0002C8 3B 03       0028*   			DW	GPIOB_M3	; Open Source IO
0002CA 56 03       0029*   			DW	GPIOB_M4	; Interrupt, Dual Edge
0002CC 82 03       0030*   			DW	GPIOB_M5	; Alt Function
0002CE 9D 03       0031*   			DW	GPIOB_M6	; Interrupt, Active Low
0002D0 C4 03       0032*   			DW	GPIOB_M7	; Interrupt, Active High
0002D2 E6 03       0033*   			DW	GPIOB_M8	; Interrupt, Falling Edge
0002D4 08 04       0034*   			DW	GPIOB_M9	; Interrupt, Rising Edge
0002D6             0035*   
0002D6             0036*   ; Output
0002D6             0037*   ;
0002D6             0038*   GPIOB_M0:		RES_GPIO PB_DDR,  B
0002D6 C5          0001*M1         PUSH    BC
0002D7 78          0002*M1         LD      A, VAL
0002D8 2F          0003*M1         CPL
0002D9 4F          0004*M1         LD      C, A
0002DA ED 38 9B    0005*M1         IN0     A, (REG)
0002DD A1          0006*M1         AND     C
0002DE ED 39 9B    0007*M1         OUT0    (REG), A
0002E1 C1          0008*M1         POP     BC
0002E2             0039*   			RES_GPIO PB_ALT1, B
0002E2 C5          0001*M1         PUSH    BC
0002E3 78          0002*M1         LD      A, VAL
0002E4 2F          0003*M1         CPL
0002E5 4F          0004*M1         LD      C, A
0002E6 ED 38 9C    0005*M1         IN0     A, (REG)
0002E9 A1          0006*M1         AND     C
0002EA ED 39 9C    0007*M1         OUT0    (REG), A
0002ED C1          0008*M1         POP     BC
0002EE             0040*   			RES_GPIO PB_ALT2, B
0002EE C5          0001*M1         PUSH    BC
0002EF 78          0002*M1         LD      A, VAL
0002F0 2F          0003*M1         CPL
0002F1 4F          0004*M1         LD      C, A
0002F2 ED 38 9D    0005*M1         IN0     A, (REG)
0002F5 A1          0006*M1         AND     C
0002F6 ED 39 9D    0007*M1         OUT0    (REG), A
0002F9 C1          0008*M1         POP     BC
0002FA C9          0041*   			RET
0002FB             0042*   
0002FB             0043*   ; Input
0002FB             0044*   ;
0002FB             0045*   GPIOB_M1:		SET_GPIO PB_DDR,  B
0002FB ED 38 9B    0001*M1         IN0     A, (REG)
0002FE B0          0002*M1         OR      VAL
0002FF ED 39 9B    0003*M1         OUT0    (REG), A
000302             0046*   			RES_GPIO PB_ALT1, B
000302 C5          0001*M1         PUSH    BC
000303 78          0002*M1         LD      A, VAL
000304 2F          0003*M1         CPL
000305 4F          0004*M1         LD      C, A
000306 ED 38 9C    0005*M1         IN0     A, (REG)
000309 A1          0006*M1         AND     C
00030A ED 39 9C    0007*M1         OUT0    (REG), A
00030D C1          0008*M1         POP     BC
00030E             0047*   			RES_GPIO PB_ALT2, B
00030E C5          0001*M1         PUSH    BC
00030F 78          0002*M1         LD      A, VAL
000310 2F          0003*M1         CPL
000311 4F          0004*M1         LD      C, A
000312 ED 38 9D    0005*M1         IN0     A, (REG)
000315 A1          0006*M1         AND     C
000316 ED 39 9D    0007*M1         OUT0    (REG), A
000319 C1          0008*M1         POP     BC
00031A C9          0048*   			RET
00031B             0049*   
00031B             0050*   ; Open Drain IO
00031B             0051*   ;
00031B             0052*   GPIOB_M2:		RES_GPIO PB_DDR,  B
00031B C5          0001*M1         PUSH    BC
00031C 78          0002*M1         LD      A, VAL
00031D 2F          0003*M1         CPL
00031E 4F          0004*M1         LD      C, A
00031F ED 38 9B    0005*M1         IN0     A, (REG)
000322 A1          0006*M1         AND     C
000323 ED 39 9B    0007*M1         OUT0    (REG), A
000326 C1          0008*M1         POP     BC
000327             0053*   			SET_GPIO PB_ALT1, B
000327 ED 38 9C    0001*M1         IN0     A, (REG)
00032A B0          0002*M1         OR      VAL
00032B ED 39 9C    0003*M1         OUT0    (REG), A
00032E             0054*   			RES_GPIO PB_ALT2, B
00032E C5          0001*M1         PUSH    BC
00032F 78          0002*M1         LD      A, VAL
000330 2F          0003*M1         CPL
000331 4F          0004*M1         LD      C, A
000332 ED 38 9D    0005*M1         IN0     A, (REG)
000335 A1          0006*M1         AND     C
000336 ED 39 9D    0007*M1         OUT0    (REG), A
000339 C1          0008*M1         POP     BC
00033A C9          0055*   			RET
00033B             0056*   
00033B             0057*   ; Open Source IO
00033B             0058*   ;
00033B             0059*   GPIOB_M3:		SET_GPIO PB_DDR,  B
00033B ED 38 9B    0001*M1         IN0     A, (REG)
00033E B0          0002*M1         OR      VAL
00033F ED 39 9B    0003*M1         OUT0    (REG), A
000342             0060*   			SET_GPIO PB_ALT1, B
000342 ED 38 9C    0001*M1         IN0     A, (REG)
000345 B0          0002*M1         OR      VAL
000346 ED 39 9C    0003*M1         OUT0    (REG), A
000349             0061*   			RES_GPIO PB_ALT2, B
000349 C5          0001*M1         PUSH    BC
00034A 78          0002*M1         LD      A, VAL
00034B 2F          0003*M1         CPL
00034C 4F          0004*M1         LD      C, A
00034D ED 38 9D    0005*M1         IN0     A, (REG)
000350 A1          0006*M1         AND     C
000351 ED 39 9D    0007*M1         OUT0    (REG), A
000354 C1          0008*M1         POP     BC
000355 C9          0062*   			RET
000356             0063*   
000356             0064*   ; Interrupt, Dual Edge
000356             0065*   ;
000356             0066*   GPIOB_M4:		SET_GPIO PB_DR,   B
000356 ED 38 9A    0001*M1         IN0     A, (REG)
000359 B0          0002*M1         OR      VAL
00035A ED 39 9A    0003*M1         OUT0    (REG), A
00035D             0067*   			RES_GPIO PB_DDR,  B
00035D C5          0001*M1         PUSH    BC
00035E 78          0002*M1         LD      A, VAL
00035F 2F          0003*M1         CPL
000360 4F          0004*M1         LD      C, A
000361 ED 38 9B    0005*M1         IN0     A, (REG)
000364 A1          0006*M1         AND     C
000365 ED 39 9B    0007*M1         OUT0    (REG), A
000368 C1          0008*M1         POP     BC
000369             0068*   			RES_GPIO PB_ALT1, B
000369 C5          0001*M1         PUSH    BC
00036A 78          0002*M1         LD      A, VAL
00036B 2F          0003*M1         CPL
00036C 4F          0004*M1         LD      C, A
00036D ED 38 9C    0005*M1         IN0     A, (REG)
000370 A1          0006*M1         AND     C
000371 ED 39 9C    0007*M1         OUT0    (REG), A
000374 C1          0008*M1         POP     BC
000375             0069*   			RES_GPIO PB_ALT2, B
000375 C5          0001*M1         PUSH    BC
000376 78          0002*M1         LD      A, VAL
000377 2F          0003*M1         CPL
000378 4F          0004*M1         LD      C, A
000379 ED 38 9D    0005*M1         IN0     A, (REG)
00037C A1          0006*M1         AND     C
00037D ED 39 9D    0007*M1         OUT0    (REG), A
000380 C1          0008*M1         POP     BC
000381 C9          0070*   			RET
000382             0071*   
000382             0072*   ; Alt Function
000382             0073*   ;
000382             0074*   GPIOB_M5:		SET_GPIO PB_DDR,  B
000382 ED 38 9B    0001*M1         IN0     A, (REG)
000385 B0          0002*M1         OR      VAL
000386 ED 39 9B    0003*M1         OUT0    (REG), A
000389             0075*   			RES_GPIO PB_ALT1, B
000389 C5          0001*M1         PUSH    BC
00038A 78          0002*M1         LD      A, VAL
00038B 2F          0003*M1         CPL
00038C 4F          0004*M1         LD      C, A
00038D ED 38 9C    0005*M1         IN0     A, (REG)
000390 A1          0006*M1         AND     C
000391 ED 39 9C    0007*M1         OUT0    (REG), A
000394 C1          0008*M1         POP     BC
000395             0076*   			SET_GPIO PB_ALT2, B
000395 ED 38 9D    0001*M1         IN0     A, (REG)
000398 B0          0002*M1         OR      VAL
000399 ED 39 9D    0003*M1         OUT0    (REG), A
00039C C9          0077*   			RET
00039D             0078*   
00039D             0079*   ; Interrupt, Active Low
00039D             0080*   ;
00039D             0081*   GPIOB_M6:		RES_GPIO PB_DR,   B
00039D C5          0001*M1         PUSH    BC
00039E 78          0002*M1         LD      A, VAL
00039F 2F          0003*M1         CPL
0003A0 4F          0004*M1         LD      C, A
0003A1 ED 38 9A    0005*M1         IN0     A, (REG)
0003A4 A1          0006*M1         AND     C
0003A5 ED 39 9A    0007*M1         OUT0    (REG), A
0003A8 C1          0008*M1         POP     BC
0003A9             0082*   			RES_GPIO PB_DDR,  B
0003A9 C5          0001*M1         PUSH    BC
0003AA 78          0002*M1         LD      A, VAL
0003AB 2F          0003*M1         CPL
0003AC 4F          0004*M1         LD      C, A
0003AD ED 38 9B    0005*M1         IN0     A, (REG)
0003B0 A1          0006*M1         AND     C
0003B1 ED 39 9B    0007*M1         OUT0    (REG), A
0003B4 C1          0008*M1         POP     BC
0003B5             0083*   			SET_GPIO PB_ALT1, B
0003B5 ED 38 9C    0001*M1         IN0     A, (REG)
0003B8 B0          0002*M1         OR      VAL
0003B9 ED 39 9C    0003*M1         OUT0    (REG), A
0003BC             0084*   			SET_GPIO PB_ALT2, B
0003BC ED 38 9D    0001*M1         IN0     A, (REG)
0003BF B0          0002*M1         OR      VAL
0003C0 ED 39 9D    0003*M1         OUT0    (REG), A
0003C3 C9          0085*   			RET
0003C4             0086*   
0003C4             0087*   
0003C4             0088*   ; Interrupt, Active High
0003C4             0089*   ;
0003C4             0090*   GPIOB_M7:		SET_GPIO PB_DR,   B
0003C4 ED 38 9A    0001*M1         IN0     A, (REG)
0003C7 B0          0002*M1         OR      VAL
0003C8 ED 39 9A    0003*M1         OUT0    (REG), A
0003CB             0091*   			RES_GPIO PB_DDR,  B
0003CB C5          0001*M1         PUSH    BC
0003CC 78          0002*M1         LD      A, VAL
0003CD 2F          0003*M1         CPL
0003CE 4F          0004*M1         LD      C, A
0003CF ED 38 9B    0005*M1         IN0     A, (REG)
0003D2 A1          0006*M1         AND     C
0003D3 ED 39 9B    0007*M1         OUT0    (REG), A
0003D6 C1          0008*M1         POP     BC
0003D7             0092*   			SET_GPIO PB_ALT1, B
0003D7 ED 38 9C    0001*M1         IN0     A, (REG)
0003DA B0          0002*M1         OR      VAL
0003DB ED 39 9C    0003*M1         OUT0    (REG), A
0003DE             0093*   			SET_GPIO PB_ALT2, B
0003DE ED 38 9D    0001*M1         IN0     A, (REG)
0003E1 B0          0002*M1         OR      VAL
0003E2 ED 39 9D    0003*M1         OUT0    (REG), A
0003E5 C9          0094*   			RET
0003E6             0095*   
0003E6             0096*   
0003E6             0097*   ; Interrupt, Falling Edge
0003E6             0098*   ;
0003E6             0099*   GPIOB_M8:		RES_GPIO PB_DR,   B
0003E6 C5          0001*M1         PUSH    BC
0003E7 78          0002*M1         LD      A, VAL
0003E8 2F          0003*M1         CPL
0003E9 4F          0004*M1         LD      C, A
0003EA ED 38 9A    0005*M1         IN0     A, (REG)
0003ED A1          0006*M1         AND     C
0003EE ED 39 9A    0007*M1         OUT0    (REG), A
0003F1 C1          0008*M1         POP     BC
0003F2             0100*   			SET_GPIO PB_DDR,  B
0003F2 ED 38 9B    0001*M1         IN0     A, (REG)
0003F5 B0          0002*M1         OR      VAL
0003F6 ED 39 9B    0003*M1         OUT0    (REG), A
0003F9             0101*   			SET_GPIO PB_ALT1, B
0003F9 ED 38 9C    0001*M1         IN0     A, (REG)
0003FC B0          0002*M1         OR      VAL
0003FD ED 39 9C    0003*M1         OUT0    (REG), A
000400             0102*   			SET_GPIO PB_ALT2, B
000400 ED 38 9D    0001*M1         IN0     A, (REG)
000403 B0          0002*M1         OR      VAL
000404 ED 39 9D    0003*M1         OUT0    (REG), A
000407 C9          0103*   			RET
000408             0104*   
000408             0105*   ; Interrupt, Rising Edge
000408             0106*   ;
000408             0107*   GPIOB_M9:		SET_GPIO PB_DR,   B
000408 ED 38 9A    0001*M1         IN0     A, (REG)
00040B B0          0002*M1         OR      VAL
00040C ED 39 9A    0003*M1         OUT0    (REG), A
00040F             0108*   			SET_GPIO PB_DDR,  B
00040F ED 38 9B    0001*M1         IN0     A, (REG)
000412 B0          0002*M1         OR      VAL
000413 ED 39 9B    0003*M1         OUT0    (REG), A
000416             0109*   			SET_GPIO PB_ALT1, B
000416 ED 38 9C    0001*M1         IN0     A, (REG)
000419 B0          0002*M1         OR      VAL
00041A ED 39 9C    0003*M1         OUT0    (REG), A
00041D             0110*   			SET_GPIO PB_ALT2, B
00041D ED 38 9D    0001*M1         IN0     A, (REG)
000420 B0          0002*M1         OR      VAL
000421 ED 39 9D    0003*M1         OUT0    (REG), A
000424 C9          0111*   			RET
000425             0010        include "agon_interrupt.asm"
000425             0001*   ;
000425             0002*   ; Title:	BBC Basic for AGON - Interrupts
000425             0003*   ; Author:	Dean Belfield
000425             0004*   ; Created:	04/12/2024
000425             0005*   ; Last Updated:	04/12/2024
000425             0006*   ;
000425             0007*   ; Modinfo:
000425             0008*   
000425             0009*   			.ASSUME	ADL = 0
000425             0010*   ;	.ORG 0x0000
000425             0011*   
000425             0012*   			; INCLUDE	"macros.inc"
000425             0013*   			; INCLUDE	"equs.inc"
000425             0014*   			; INCLUDE "mos_api.inc"	; In MOS/src
000425             0015*   
000425             0016*   ;			SEGMENT CODE
000425             0017*   
000425             0018*   ;			XDEF	VBLANK_INIT
000425             0019*   ;			XDEF	VBLANK_STOP
000425             0020*   ;			XDEF	VBLANK_HANDLER
000425             0021*   
000425             0022*   ;			XREF	ESCSET
000425             0023*   ;			XREF	KEYDOWN		; In ram.asm
000425             0024*   ;			XREF	KEYASCII 	; In ram.asm
000425             0025*   ;			XREF	KEYCOUNT	; In ram.asm
000425             0026*   
000425             0027*   ; Hook into the MOS VBLANK interrupt
000425             0028*   ;
000425 F3          0029*   VBLANK_INIT:		DI
000426             0030*   
000426 ED 6E       0031*   			LD		A, MB 				; Get a 24-bit pointer to
000428 21 A3 04    0032*   			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
00042B CD 65 04    0033*   			CALL		SET_AHL16 			; address is a 16-bit pointer in BBC BASIC's segment
00042E             0034*   
00042E 1E 32       0035*   			LD		E, 32h				; Set up the VBlank Interrupt Vector
000430             0036*   			MOSCALL		mos_setintvector
000430 3E 14       0001*M1 			LD	A, function
000432 49 CF       0002*M1 			RST.LIS	08h
000434             0037*   
000434 5B E5       0038*   			PUSH.LIL	HL				; HLU: Pointer to the MOS interrupt vector
000436 5B D1       0039*   			POP.LIL		DE 				; DEU: Pointer to the MOS interrupt vector
000438             0040*   
000438 21 BB 04    0041*   			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
00043B ED 6E       0042*   			LD		A, MB	 			; Get the segment BBC BASIC is running in
00043D 32 AC 04    0043*   			LD		(VBLANK_HANDLER_MB + 1), A 	; Store in the interrupt handler
000440 CD 65 04    0044*   			CALL		SET_AHL16 			; Convert pointer to an absolute 24-bit address
000443 5B ED 1F    0045*   			LD.LIL		(HL), DE			; Self-modify the code
000446 FB          0046*   			EI
000447 C9          0047*   			RET
000448             0048*   
000448             0049*   ; Unhook the custom VBLANK interrupt
000448             0050*   ;
000448 F3          0051*   VBLANK_STOP:		DI
000449 21 BB 04    0052*   			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
00044C 3A AC 04    0053*   			LD		A, (VBLANK_HANDLER_MB + 1)	; The stored MB of the segment BBC BASIC is running in
00044F F5          0054*   			PUSH		AF 				; Stack the MB for later
000450 CD 65 04    0055*   			CALL		SET_AHL16			; Convert pointer to an absolute 24-bit address
000453 5B ED 17    0056*   			LD.LIL		DE, (HL)			; DEU: Address of MOS interrupt vector
000456 5B D5       0057*   			PUSH.LIL	DE				; Transfer to HL
000458 5B E1       0058*   			POP.LIL		HL
00045A 1E 32       0059*   			LD		E, 32h
00045C             0060*   			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
00045C 3E 14       0001*M1 			LD	A, function
00045E 49 CF       0002*M1 			RST.LIS	08h
000460 F1          0061*   			POP		AF 				; Restore MB to this segment
000461 ED 6D       0062*   			LD		MB, A
000463 FB          0063*   			EI
000464 C9          0064*   			RET
000465             0065*   
000465             0066*   ; Set the MSB of HL (U) to A
000465             0067*   ;
000465 5B E5       0068*   SET_AHL16:		PUSH.LIL	HL
000467 5B 21 02 00 0069*   			LD.LIL		HL, 2
       00          
00046C 5B 39       0070*   			ADD.LIL		HL, SP
00046E 5B 77       0071*   			LD.LIL		(HL), A
000470 5B E1       0072*   			POP.LIL		HL
000472 C9          0073*   			RET
000473             0074*   
000473             0075*   ; A safe LIS call to ESCSET
000473             0076*   ;
000473             0077*   DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
000473 3E 08       0001*M1 			LD	A, function
000475 49 CF       0002*M1 			RST.LIS	08h
000477 21 99 51    0078*   			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
00047A 5B DD 7E 19 0079*   			LD.LIL		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
00047E BE          0080*   			CP 		(HL)				; with our local copy
00047F 20 09       0081*   			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
000481             0082*   ;
000481 AF          0083*   DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
000482 32 98 51    0084*   			LD		(KEYASCII), A
000485 32 97 51    0085*   			LD		(KEYDOWN), A
000488 5B C9       0086*   			RET.LIL 					; And return
00048A             0087*   ;
00048A 77          0088*   DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
00048B 5B DD 7E 18 0089*   			LD.LIL		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
00048F B7          0090*   			OR		A
000490 28 EF       0091*   			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
000492             0092*   ;
000492 32 97 51    0093*   			LD		(KEYDOWN), A 			; Store the keydown value
000495 5B DD 7E 05 0094*   			LD.LIL		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
000499 32 98 51    0095*   			LD		(KEYASCII), A 			; Store locally
00049C FE 1B       0096*   			CP		1Bh				; Is it escape?
00049E CC 18 06    0097*   			CALL		Z, ESCSET			; Yes, so set the escape flags
0004A1 49 C9       0098*   			RET.LIS						; Return to the interrupt handler
0004A3             0099*   
0004A3             0100*   ;
0004A3             0101*   ; Interrupts in mixed mode always run in ADL mode
0004A3             0102*   ;
0004A3             0103*   			.ASSUME	ADL = 1
0004A3             0104*   
0004A3 F3          0105*   VBLANK_HANDLER:		DI
0004A4 F5          0106*   			PUSH		AF
0004A5 E5          0107*   			PUSH		HL
0004A6 DD E5       0108*   			PUSH		IX
0004A8 ED 6E       0109*   			LD		A, MB
0004AA F5          0110*   			PUSH		AF
0004AB 3E 00       0111*   VBLANK_HANDLER_MB:	LD		A, 0				; This is self-modified by VBLANK_INIT
0004AD ED 6D       0112*   			LD		MB, A
0004AF 49 CD 73 04 0113*   			CALL.LIS	DO_KEYBOARD
0004B3 F1          0114*   			POP		AF
0004B4 ED 6D       0115*   			LD		MB, A
0004B6 DD E1       0116*   			POP		IX
0004B8 E1          0117*   			POP		HL
0004B9 F1          0118*   			POP		AF
0004BA             0119*   ;
0004BA             0120*   ; Finally jump to the MOS interrupt
0004BA             0121*   ;
0004BA C3 00 00 00 0122*   VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
0004BE             0011        include "agon_misc.asm"
0004BE             0001*   ;
0004BE             0002*   ; Title:	BBC Basic for AGON - Miscellaneous helper functions
0004BE             0003*   ; Author:	Dean Belfield
0004BE             0004*   ; Created:	04/12/2024
0004BE             0005*   ; Last Updated:	04/12/2024
0004BE             0006*   ;
0004BE             0007*   ; Modinfo:
0004BE             0008*   
0004BE             0009*   			; INCLUDE	"equs.inc"
0004BE             0010*   			; INCLUDE	"macros.inc"
0004BE             0011*   
0004BE             0012*   			.ASSUME	ADL = 0
0004BE             0013*   ;	.ORG 0x0000
0004BE             0014*   
0004BE             0015*   ;			SEGMENT CODE
0004BE             0016*   
0004BE             0017*   ;			XDEF	ASC_TO_NUMBER
0004BE             0018*   ;			XDEF	SWITCH_A
0004BE             0019*   ;			XDEF	NULLTOCR
0004BE             0020*   ;			XDEF	CRTONULL
0004BE             0021*   ;			XDEF	CSTR_FNAME
0004BE             0022*   ;			XDEF	CSTR_LINE
0004BE             0023*   ;			XDEF	CSTR_FINDCH
0004BE             0024*   ;			XDEF	CSTR_ENDSWITH
0004BE             0025*   ;			XDEF	CSTR_CAT
0004BE             0026*   
0004BE             0027*   ;			XREF	OSWRCH
0004BE             0028*   ;			XREF	KEYWDS
0004BE             0029*   ;			XREF	KEYWDL
0004BE             0030*   
0004BE             0031*   ; Read a number and convert to binary
0004BE             0032*   ; If prefixed with &, will read as hex, otherwise decimal
0004BE             0033*   ;   Inputs: HL: Pointer in string buffer
0004BE             0034*   ;  Outputs: HL: Updated text pointer
0004BE             0035*   ;           DE: Value
0004BE             0036*   ;            A: Terminator (spaces skipped)
0004BE             0037*   ; Destroys: A,D,E,H,L,F
0004BE             0038*   ;
0004BE C5          0039*   ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
0004BF 11 00 00    0040*   			LD	DE, 0			; Initialise DE
0004C2 CD 02 05    0041*   			CALL	SKIPSPmisc			; Skip whitespace
0004C5 7E          0042*   			LD	A, (HL)			; Read first character
0004C6 FE 26       0043*   			CP	'&'			; Is it prefixed with '&' (HEX number)?
0004C8 20 1E       0044*   			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0004CA 23          0045*   			INC	HL			; Otherwise fall through to ASC_TO_HEX
0004CB             0046*   ;
0004CB 7E          0047*   ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
0004CC CD 10 05    0048*   			CALL    UPPRCmisc			; Convert to uppercase
0004CF D6 30       0049*   			SUB	'0'			; Normalise to 0
0004D1 38 2E       0050*   			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0004D3 FE 0A       0051*   			CP 	10			; Check if >= 10
0004D5 38 06       0052*   			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
0004D7 D6 07       0053*   			SUB 	7			; Adjust ASCII A-F to nibble
0004D9 FE 10       0054*   			CP 	16			; Check for > F
0004DB 30 24       0055*   			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
0004DD EB          0056*   ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
0004DE 29          0057*   			ADD	HL, HL
0004DF 29          0058*   			ADD	HL, HL
0004E0 29          0059*   			ADD	HL, HL
0004E1 29          0060*   			ADD	HL, HL
0004E2 EB          0061*   			EX	DE, HL
0004E3 B3          0062*   			OR      E			; OR the new digit in to the least significant nibble
0004E4 5F          0063*   			LD      E, A
0004E5 23          0064*   			INC     HL			; Onto the next character
0004E6 18 E3       0065*   			JR      ASC_TO_NUMBER1		; And loop
0004E8             0066*   ;
0004E8 7E          0067*   ASC_TO_NUMBER3:		LD	A, (HL)
0004E9 D6 30       0068*   			SUB	'0'			; Normalise to 0
0004EB 38 14       0069*   			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0004ED FE 0A       0070*   			CP	10			; Check if >= 10
0004EF 30 10       0071*   			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
0004F1 EB          0072*   			EX 	DE, HL 			; Stick DE in HL
0004F2 44          0073*   			LD	B, H 			; And copy HL into BC
0004F3 4D          0074*   			LD	C, L
0004F4 29          0075*   			ADD	HL, HL 			; x 2
0004F5 29          0076*   			ADD	HL, HL 			; x 4
0004F6 09          0077*   			ADD	HL, BC 			; x 5
0004F7 29          0078*   			ADD	HL, HL 			; x 10
0004F8 EB          0079*   			EX	DE, HL
0004F9             0080*   			ADD8U_DE 			; Add A to DE (macro)
0004F9 83          0001*M1         ADD     A, E
0004FA 5F          0002*M1         LD      E, A
0004FB 8A          0003*M1         ADC     A, D
0004FC 93          0004*M1         SUB     E
0004FD 57          0005*M1         LD      D, A
0004FE 23          0081*   			INC	HL
0004FF 18 E7       0082*   			JR	ASC_TO_NUMBER3
000501 C1          0083*   ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSP here
000502             0084*   
000502             0085*   ; Skip a space
000502             0086*   ; HL: Pointer in string buffer
000502             0087*   ;
000502 7E          0088*   SKIPSPmisc:			LD      A, (HL)
000503 FE 20       0089*   			CP      ' '
000505 C0          0090*   			RET     NZ
000506 23          0091*   			INC     HL
000507 18 F9       0092*   			JR      SKIPSPmisc
000509             0093*   
000509             0094*   ; Skip a string
000509             0095*   ; HL: Pointer in string buffer
000509             0096*   ;
000509 7E          0097*   SKIPNOTSP:		LD	A, (HL)
00050A FE 20       0098*   			CP	' '
00050C C8          0099*   			RET	Z
00050D 23          0100*   			INC	HL
00050E 18 F9       0101*   			JR	SKIPNOTSP
000510             0102*   
000510             0103*   ; Convert a character to upper case
000510             0104*   ;  A: Character to convert
000510             0105*   ;
000510 E6 7F       0106*   UPPRCmisc:  		AND     7FH
000512 FE 60       0107*   			CP      '`'
000514 D8          0108*   			RET     C
000515 E6 5F       0109*   			AND     5FH			; Convert to upper case
000517 C9          0110*   			RET
000518             0111*   
000518             0112*   ; Switch on A - lookup table immediately after call
000518             0113*   ;  A: Index into lookup table
000518             0114*   ;
000518 E3          0115*   SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
000519 87          0116*   			ADD	A, A			; Multiply A by two
00051A             0117*   			ADD8U_HL 			; Add to HL (macro)
00051A 85          0001*M1         ADD     A, L
00051B 6F          0002*M1         LD      L, A
00051C 8C          0003*M1         ADC     A, H
00051D 95          0004*M1         SUB     L
00051E 67          0005*M1         LD      H, A
00051F 7E          0118*   			LD	A, (HL)			; follow the call. Fetch an address from the
000520 23          0119*   			INC	HL 			; table.
000521 66          0120*   			LD	H, (HL)
000522 6F          0121*   			LD	L, A
000523 E3          0122*   			EX	(SP), HL		; Swap this new address back, restores HL
000524 C9          0123*   			RET				; Return program control to this new address
000525             0124*   
000525             0125*   ; Convert the buffer to a null terminated string and back
000525             0126*   ; HL: Buffer address
000525             0127*   ;
000525 C5          0128*   NULLTOCR:		PUSH 	BC
000526 06 00       0129*   			LD	B, 0
000528 0E 0D       0130*   			LD	C, CR
00052A 18 05       0131*   			JR	CRTONULL0
00052C             0132*   ;
00052C C5          0133*   CRTONULL:		PUSH	BC
00052D 06 0D       0134*   			LD	B, CR
00052F 0E 00       0135*   			LD	C, 0
000531             0136*   ;
000531 E5          0137*   CRTONULL0:		PUSH	HL
000532 7E          0138*   CRTONULL1:		LD	A, (HL)
000533 B8          0139*   			CP 	B
000534 28 03       0140*   			JR	Z, CRTONULL2
000536 23          0141*   			INC	HL
000537 18 F9       0142*   			JR	CRTONULL1
000539 71          0143*   CRTONULL2:		LD	(HL), C
00053A E1          0144*   			POP 	HL
00053B C1          0145*   			POP	BC
00053C C9          0146*   			RET
00053D             0147*   
00053D             0148*   ; Copy a filename to DE and zero terminate it
00053D             0149*   ; HL: Source
00053D             0150*   ; DE: Destination (ACCS)
00053D             0151*   ;
00053D 7E          0152*   CSTR_FNAME:		LD	A, (HL)			; Get source
00053E FE 20       0153*   			CP	32			; Is it space
000540 28 09       0154*   			JR	Z, @F
000542 FE 0D       0155*   			CP	CR			; Or is it CR
000544 28 05       0156*   			JR	Z, @F
000546 12          0157*   			LD	(DE), A			; No, so store
000547 23          0158*   			INC	HL			; Increment
000548 13          0159*   			INC	DE
000549 18 F2       0160*   			JR	CSTR_FNAME		; And loop
00054B AF          0161*   @@:			XOR	A			; Zero terminate the target string
00054C 12          0162*   			LD	(DE), A
00054D 13          0163*   			INC	DE			; And point to next free address
00054E C9          0164*   			RET
00054F             0165*   
00054F             0166*   ; Copy a CR terminated line to DE and zero terminate it
00054F             0167*   ; HL: Source
00054F             0168*   ; DE: Destination (ACCS)
00054F             0169*   ;
00054F 7E          0170*   CSTR_LINE:		LD	A, (HL)			; Get source
000550 FE 0D       0171*   			CP	CR			; Is it CR
000552 28 05       0172*   			JR	Z, @F
000554 12          0173*   			LD	(DE), A			; No, so store
000555 23          0174*   			INC	HL			; Increment
000556 13          0175*   			INC	DE
000557 18 F6       0176*   			JR	CSTR_LINE		; And loop
000559 AF          0177*   @@:			XOR	A			; Zero terminate the target string
00055A 12          0178*   			LD	(DE), A
00055B 13          0179*   			INC	DE			; And point to next free address
00055C C9          0180*   			RET
00055D             0181*   
00055D             0182*   ; Find the first occurrence of a character (case sensitive)
00055D             0183*   ; HL: Source
00055D             0184*   ;  C: Character to find
00055D             0185*   ; Returns:
00055D             0186*   ; HL: Pointer to character, or end of string marker
00055D             0187*   ;
00055D 7E          0188*   CSTR_FINDCH:		LD	A, (HL)			; Get source
00055E B9          0189*   			CP	C			; Is it our character?
00055F C8          0190*   			RET	Z			; Yes, so exit
000560 B7          0191*   			OR	A			; Is it the end of string?
000561 C8          0192*   			RET	Z			; Yes, so exit
000562 23          0193*   			INC	HL
000563 18 F8       0194*   			JR	CSTR_FINDCH
000565             0195*   
000565             0196*   ; Check whether a string ends with another string (case insensitive)
000565             0197*   ; HL: Source
000565             0198*   ; DE: The substring we want to test with
000565             0199*   ; Returns:
000565             0200*   ;  F: Z if HL ends with DE, otherwise NZ
000565             0201*   ;
000565 7E          0202*   CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
000566 CD 10 05    0203*   			CALL	UPPRCmisc			; Convert to upper case
000569 4F          0204*   			LD	C, A
00056A 1A          0205*   			LD	A, (DE)			; Get the substring byte
00056B B9          0206*   			CP	C
00056C C0          0207*   			RET	NZ			; Return NZ if at any point the strings don't match
00056D B1          0208*   			OR	C			; Check whether both bytes are zero
00056E C8          0209*   			RET	Z			; If so, return, as we have reached the end of both strings
00056F 23          0210*   			INC	HL
000570 13          0211*   			INC	DE
000571 18 F2       0212*   			JR	CSTR_ENDSWITH		; And loop
000573             0213*   
000573             0214*   ; Concatenate a string onto the end of another string
000573             0215*   ; HL: Source
000573             0216*   ; DE: Second string
000573             0217*   ;
000573 7E          0218*   CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
000574 B7          0219*   			OR	A
000575 28 03       0220*   			JR	Z, CSTR_CAT_1
000577 23          0221*   			INC	HL
000578 18 F9       0222*   			JR	CSTR_CAT
00057A             0223*   ;
00057A 1A          0224*   CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
00057B 77          0225*   			LD	(HL), A
00057C B7          0226*   			OR	A			; Check for end of string
00057D C8          0227*   			RET	Z			; And return
00057E 23          0228*   			INC	HL
00057F 13          0229*   			INC	DE
000580 18 F8       0230*   			JR	CSTR_CAT_1		; Loop until finished
000582             0012        include "agon_os.asm"
000582             0001*   ;
000582             0002*   ; Title:	BBC Basic for AGON - MOS stuff
000582             0003*   ; Author:	Dean Belfield
000582             0004*   ; Created:	04/12/2024
000582             0005*   ; Last Updated:	17/12/2024
000582             0006*   ;
000582             0007*   ; Modinfo:
000582             0008*   ; 08/12/2024:	Added OSCLI and file I/O
000582             0009*   ; 11/12/2024:	Added ESC key handling
000582             0010*   ; 		Added OSWORD
000582             0011*   ; 12/12/2024:	Added OSRDCH, OSBYTE_81 and fixed *EDIT
000582             0012*   ; 17/12/2024:	Added OSWORD_01, OSWORD_02, OSWORD_0E, GET$(x,y), fixed INKEY, POS, VPOS and autoload
000582             0013*   
000582             0014*   			.ASSUME	ADL = 0
000582             0015*   
000582             0016*   			; INCLUDE	"equs.inc"
000582             0017*   			; INCLUDE "macros.inc"
000582             0018*   			; INCLUDE "mos_api.inc"	; In MOS/src
000582             0019*   
000582             0020*   			; SEGMENT CODE
000582             0021*   
000582             0022*   			; XDEF	OSWORD
000582             0023*   			; XDEF	OSBYTE
000582             0024*   			; XDEF	OSINIT
000582             0025*   			; XDEF	OSOPEN
000582             0026*   			; XDEF	OSSHUT
000582             0027*   			; XDEF	OSLOAD
000582             0028*   			; XDEF	OSSAVE
000582             0029*   			; XDEF	OSLINE
000582             0030*   			; XDEF	OSSTAT
000582             0031*   			; XDEF	OSWRCH
000582             0032*   			; XDEF	OSRDCH
000582             0033*   			; XDEF	OSBGET
000582             0034*   			; XDEF	OSBPUT
000582             0035*   			; XDEF	OSCLI
000582             0036*   			; XDEF	PROMPT
000582             0037*   			; XDEF	GETPTR
000582             0038*   			; XDEF	PUTPTR
000582             0039*   			; XDEF	GETEXT
000582             0040*   			; XDEF	TRAP
000582             0041*   			; XDEF	LTRAP
000582             0042*   			; XDEF	BYE
000582             0043*   			; XDEF	RESET
000582             0044*   			; XDEF	ESCSET
000582             0045*   
000582             0046*   			; XREF	EXTERR
000582             0047*   			; XREF	VBLANK_INIT
000582             0048*   			; XREF	VBLANK_STOP
000582             0049*   			; XREF	USER
000582             0050*   			; XREF	COUNT
000582             0051*   			; XREF	COUNT0
000582             0052*   			; XREF	COUNT1
000582             0053*   			; XREF	GETCSR
000582             0054*   			; XREF	GETSCHR_1
000582             0055*   			; XREF	NULLTOCR
000582             0056*   			; XREF	CRLF
000582             0057*   			; XREF	FLAGS
000582             0058*   			; XREF	OSWRCHPT
000582             0059*   			; XREF	OSWRCHCH
000582             0060*   			; XREF	OSWRCHFH
000582             0061*   			; XREF	KEYASCII
000582             0062*   			; XREF	KEYDOWN
000582             0063*   			; XREF	LISTON
000582             0064*   			; XREF	PAGE_
000582             0065*   			; XREF	CSTR_FNAME
000582             0066*   			; XREF	CSTR_FINDCH
000582             0067*   			; XREF	CSTR_CAT
000582             0068*   			; XREF	CSTR_ENDSWITH
000582             0069*   			; XREF	CSTR_LINE
000582             0070*   			; XREF	NEWIT
000582             0071*   			; XREF	BAD
000582             0072*   			; XREF	CLEAN
000582             0073*   			; XREF	LINNUM
000582             0074*   			; XREF	BUFFER
000582             0075*   			; XREF	NXT
000582             0076*   			; XREF	ERROR_
000582             0077*   			; XREF	XEQ
000582             0078*   			; XREF	LEXAN2
000582             0079*   			; XREF	GETTOP
000582             0080*   			; XREF	FINDL
000582             0081*   			; XREF	DEL
000582             0082*   			; XREF	LISTIT
000582             0083*   			; XREF	ESCAPE
000582             0084*   			; XREF	ASC_TO_NUMBER
000582             0085*   			; XREF	CLOOP
000582             0086*   			; XREF	SCRAP
000582             0087*   			; XREF	POINT_
000582             0088*   			; XREF	SOUND_
000582             0089*   			; XREF	EXPRI
000582             0090*   			; XREF	COMMA
000582             0091*   			; XREF	BRAKET
000582             0092*   			; XREF 	GETSCHR
000582             0093*   			; XREF	ZERO
000582             0094*   			; XREF	TRUE
000582             0095*   
000582             0096*   ;OSINIT - Initialise RAM mapping etc.
000582             0097*   ;If BASIC is entered by BBCBASIC FILENAME then file
000582             0098*   ;FILENAME.BBC is automatically CHAINed.
000582             0099*   ;   Outputs: DE = initial value of HIMEM (top of RAM)
000582             0100*   ;            HL = initial value of PAGE (user program)
000582             0101*   ;            Z-flag reset indicates AUTO-RUN.
000582             0102*   ;  Destroys: A,D,E,H,L,F
000582             0103*   ;
000582 CD 25 04    0104*   OSINIT:			CALL	VBLANK_INIT
000585 AF          0105*   			XOR	A
000586 32 92 51    0106*   			LD	(FLAGS), A		; Clear flags and set F = Z
000589 21 00 55    0107*   			LD 	HL, USER
00058C 11 00 FF    0108*   			LD	DE, RAM_Top
00058F 5F          0109*   			LD	E, A			; Page boundary
000590 3A 00 52    0110*   			LD	A, (ACCS)		; Return NZ if there is a file to chain
000593 B7          0111*   			OR	A
000594 C9          0112*   			RET
000595             0113*   
000595             0114*   ; PROMPT: output the input prompt
000595             0115*   ;
000595 3E 3E       0116*   PROMPT: 		LD	A,'>'			; Falls through to OSWRCH
000597             0117*   
000597             0118*   ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
000597             0119*   ; Parameters:
000597             0120*   ; - A: Character to write
000597             0121*   ;
000597 E5          0122*   OSWRCH:			PUSH	HL
000598 21 FE 54    0123*   			LD	HL, LISTON		; Fetch the LISTON variable
00059B CB 5E       0124*   			BIT	3, (HL)			; Check whether we are in *EDIT mode
00059D 20 0A       0125*   			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
00059F             0126*   ;
00059F 2A 95 51    0127*   			LD	HL, (OSWRCHCH)		; L: Channel #
0005A2 2D          0128*   			DEC	L			; If it is 1
0005A3 28 17       0129*   			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0005A5             0130*   ;
0005A5 E1          0131*   			POP	HL			; Otherwise
0005A6 49 D7       0132*   			RST.LIS	10h			; Output the character to MOS
0005A8 C9          0133*   			RET
0005A9             0134*   ;
0005A9 2A 93 51    0135*   OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0005AC FE 0A       0136*   			CP	0AH			; Just ignore this
0005AE 28 0A       0137*   			JR	Z, OSWRCH_BUFFER2
0005B0 FE 0D       0138*   			CP	0DH			; Is it the end of line?
0005B2 20 01       0139*   			JR	NZ, OSWRCH_BUFFER1	; No, so carry on
0005B4 AF          0140*   			XOR	A			; Turn it into a NUL character
0005B5 77          0141*   OSWRCH_BUFFER1:		LD	(HL), A			; Echo the character into the buffer
0005B6 23          0142*   			INC	HL			; Increment pointer
0005B7 22 93 51    0143*   			LD	(OSWRCHPT), HL		; Write pointer back
0005BA E1          0144*   OSWRCH_BUFFER2:		POP	HL
0005BB C9          0145*   			RET
0005BC             0146*   ;
0005BC D5          0147*   OSWRCH_FILE:		PUSH	DE
0005BD 5C          0148*   			LD	E, H			; Filehandle to E
0005BE CD 65 06    0149*   			CALL	OSBPUT			; Write the byte out
0005C1 D1          0150*   			POP	DE
0005C2 E1          0151*   			POP	HL
0005C3 C9          0152*   			RET
0005C4             0153*   
0005C4             0154*   ; OSRDCH
0005C4             0155*   ;
0005C4 CD 8E 45    0156*   OSRDCH:			CALL    NXT			; Check if we are doing GET$(x,y)
0005C7 FE 28       0157*   			CP      '('
0005C9 28 09       0158*   			JR	Z, @F 			; Yes, so skip to that functionality
0005CB             0159*   			MOSCALL	mos_getkey		; Otherwise, read keyboard
0005CB 3E 00       0001*M1 			LD	A, function
0005CD 49 CF       0002*M1 			RST.LIS	08h
0005CF FE 1B       0160*   			CP	1Bh
0005D1 28 6A       0161*   			JR	Z, LTRAP1
0005D3 C9          0162*   			RET
0005D4             0163*   ;
0005D4 FD 23       0164*   @@:			INC	IY			; Skip '('
0005D6 CD B6 18    0165*   			CALL    EXPRI         	  	; Get the first parameter
0005D9 D9          0166*   			EXX
0005DA E5          0167*   			PUSH	HL
0005DB CD 25 21    0168*   			CALL	COMMA			; Get the second parameter
0005DE CD B6 18    0169*   			CALL	EXPRI
0005E1 D9          0170*   			EXX
0005E2 D1          0171*   			POP	DE 			; DE: X coordinate
0005E3 CD 31 21    0172*   			CALL	BRAKET 			; Check for trailing bracket
0005E6 C3 BD 01    0173*   			JP 	GETSCHR			; Read the character
0005E9             0174*   
0005E9             0175*   ; OSLINE: Invoke the line editor
0005E9             0176*   ;
0005E9 1E 01       0177*   OSLINE:			LD 	E, 1			; Default is to clear the buffer
0005EB             0178*   
0005EB             0179*   ; Entry point to line editor that does not clear the buffer
0005EB             0180*   ; Parameters:
0005EB             0181*   ; - HL: addresses destination buffer (on page boundary)
0005EB             0182*   ; Returns:
0005EB             0183*   ; -  A: 0
0005EB             0184*   ; NB: Buffer filled, terminated by CR
0005EB             0185*   ;
0005EB FD E5       0186*   OSLINE1:		PUSH	IY
0005ED E5          0187*   			PUSH	HL			; Buffer address
0005EE 01 00 01    0188*   			LD	BC, 256			; Buffer length
0005F1             0189*   			MOSCALL	mos_editline		; Call the MOS line editor
0005F1 3E 09       0001*M1 			LD	A, function
0005F3 49 CF       0002*M1 			RST.LIS	08h
0005F5 E1          0190*   			POP	HL			; Pop the address
0005F6 FD E1       0191*   			POP	IY
0005F8 F5          0192*   			PUSH	AF			; Stack the return value (key pressed)
0005F9 CD 25 05    0193*   			CALL	NULLTOCR		; Turn the 0 character to a CR
0005FC CD 7E 41    0194*   			CALL	CRLF			; Display CRLF
0005FF F1          0195*   			POP	AF
000600 FE 1B       0196*   			CP	1Bh 			; Check if ESC terminated the input
000602 CA 3D 06    0197*   			JP	Z, LTRAP1 		; Yes, so do the ESC thing
000605 3A 92 51    0198*   			LD	A, (FLAGS)		; Otherwise
000608 CB BF       0199*   			RES	7, A 			; Clear the escape flag
00060A 32 92 51    0200*   			LD	(FLAGS), A
00060D CD 0E 0B    0201*   			CALL	WAIT_VBLANK 		; Wait a frame
000610 AF          0202*    			XOR	A			; Return A = 0
000611 32 97 51    0203*   			LD	(KEYDOWN), A
000614 32 98 51    0204*   			LD	(KEYASCII), A
000617 C9          0205*   			RET
000618             0206*   
000618             0207*   ;
000618             0208*   ; ESCSET
000618             0209*   ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
000618             0210*   ;
000618 E5          0211*   ESCSET: 		PUSH    HL
000619 21 92 51    0212*           		LD      HL,FLAGS		; Pointer to FLAGS
00061C CB 76       0213*           		BIT     6,(HL)			; If bit 6 is set, then
00061E 20 02       0214*           		JR      NZ,ESCDIS		; escape is disabled, so skip
000620 CB FE       0215*           		SET     7,(HL)			; Set bit 7, the escape flag
000622 E1          0216*   ESCDIS: 		POP     HL
000623 C9          0217*           		RET
000624             0218*   
000624             0219*   ;
000624             0220*   ; ESCTEST
000624             0221*   ; Test for ESC key
000624             0222*   ;
000624 CD 2D 06    0223*   ESCTEST:		CALL	READKEY			; Read the keyboard
000627 C0          0224*   			RET	NZ			; Skip if no key is pressed
000628 FE 1B       0225*   			CP	1BH			; If ESC pressed then
00062A 28 EC       0226*   			JR	Z,ESCSET		; jump to the escape set routine
00062C C9          0227*   			RET
00062D             0228*   
00062D             0229*   ; Read the keyboard
00062D             0230*   ; Returns:
00062D             0231*   ; - A: ASCII of the pressed key
00062D             0232*   ; - F: Z if the key is pressed, otherwise NZ
00062D             0233*   ;
00062D 3A 97 51    0234*   READKEY:		LD	A, (KEYDOWN)		; Get key down
000630 3D          0235*   			DEC	A 			; Set Z flag if keydown is 1
000631 3A 98 51    0236*   			LD	A, (KEYASCII)		; Get key ASCII value
000634 C9          0237*   			RET
000635             0238*   ;
000635             0239*   ; TRAP
000635             0240*   ; This is called whenever BASIC needs to check for ESC
000635             0241*   ;
000635 CD 24 06    0242*   TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
000638             0243*   ;
000638 3A 92 51    0244*   LTRAP:			LD	A,(FLAGS)		; Get FLAGS
00063B B7          0245*   			OR	A			; This checks for bit 7; if it is not set then the result will
00063C F0          0246*   			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
00063D 21 92 51    0247*   LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
000640 CB BE       0248*   			RES	7,(HL)			; Clear the escape pressed flag and
000642 C3 66 26    0249*   			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
000645             0250*   
000645             0251*   ; RESET
000645             0252*   ;
000645 C9          0253*   RESET:			RET				; Yes this is fine
000646             0254*   
000646             0255*   ; OSOPEN
000646             0256*   ; HL: Pointer to path
000646             0257*   ;  F: C Z
000646             0258*   ;     x x OPENIN
000646             0259*   ; 	  OPENOUT
000646             0260*   ;     x	  OPENUP
000646             0261*   ; Returns:
000646             0262*   ;  A: Filehandle, 0 if cannot open
000646             0263*   ;
000646 0E 01       0264*   OSOPEN:			LD	C, fa_read
000648 28 06       0265*   			JR	Z, @F
00064A 0E 32       0266*   			LD	C, fa_write | fa_open_append
00064C 38 02       0267*   			JR	C, @F
00064E 0E 0A       0268*   			LD	C, fa_write | fa_create_always
000650             0269*   @@:			MOSCALL	mos_fopen
000650 3E 0A       0001*M1 			LD	A, function
000652 49 CF       0002*M1 			RST.LIS	08h
000654 C9          0270*   			RET
000655             0271*   
000655             0272*   ;OSSHUT - Close disk file(s).
000655             0273*   ; E = file channel
000655             0274*   ;  If E=0 all files are closed (except SPOOL)
000655             0275*   ; Destroys: A,B,C,D,E,H,L,F
000655             0276*   ;
000655 C5          0277*   OSSHUT:			PUSH	BC
000656 4B          0278*   			LD	C, E
000657             0279*   			MOSCALL	mos_fclose
000657 3E 0B       0001*M1 			LD	A, function
000659 49 CF       0002*M1 			RST.LIS	08h
00065B C1          0280*   			POP	BC
00065C C9          0281*   			RET
00065D             0282*   
00065D             0283*   ; OSBGET - Read a byte from a random disk file.
00065D             0284*   ;  E = file channel
00065D             0285*   ; Returns
00065D             0286*   ;  A = byte read
00065D             0287*   ;  Carry set if LAST BYTE of file
00065D             0288*   ; Destroys: A,B,C,F
00065D             0289*   ;
00065D C5          0290*   OSBGET:			PUSH	BC
00065E 4B          0291*   			LD	C, E
00065F             0292*   			MOSCALL	mos_fgetc
00065F 3E 0C       0001*M1 			LD	A, function
000661 49 CF       0002*M1 			RST.LIS	08h
000663 C1          0293*   			POP	BC
000664 C9          0294*   			RET
000665             0295*   
000665             0296*   ; OSBPUT - Write a byte to a random disk file.
000665             0297*   ;  E = file channel
000665             0298*   ;  A = byte to write
000665             0299*   ; Destroys: A,B,C,F
000665             0300*   ;
000665 C5          0301*   OSBPUT:			PUSH	BC
000666 4B          0302*   			LD	C, E
000667 47          0303*   			LD	B, A
000668             0304*   			MOSCALL	mos_fputc
000668 3E 0D       0001*M1 			LD	A, function
00066A 49 CF       0002*M1 			RST.LIS	08h
00066C C1          0305*   			POP	BC
00066D C9          0306*   			RET
00066E             0307*   
00066E             0308*   ; OSSTAT - Read file status
00066E             0309*   ;  E = file channel
00066E             0310*   ; Returns
00066E             0311*   ;  F: Z flag set - EOF
00066E             0312*   ;  A: If Z then A = 0
00066E             0313*   ; Destroys: A,D,E,H,L,F
00066E             0314*   ;
00066E C5          0315*   OSSTAT:			PUSH	BC
00066F 4B          0316*   			LD	C, E
000670             0317*   			MOSCALL	mos_feof
000670 3E 0E       0001*M1 			LD	A, function
000672 49 CF       0002*M1 			RST.LIS	08h
000674 C1          0318*   			POP	BC
000675 FE 01       0319*   			CP	1
000677 C9          0320*   			RET
000678             0321*   
000678             0322*   ; GETPTR - Return file pointer.
000678             0323*   ;    E = file channel
000678             0324*   ; Returns:
000678             0325*   ; DEHL = pointer (0-&7FFFFF)
000678             0326*   ; Destroys: A,B,C,D,E,H,L,F
000678             0327*   ;
000678 FD E5       0328*   GETPTR:			PUSH		IY
00067A 4B          0329*   			LD		C, E
00067B             0330*   			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
00067B 3E 19       0001*M1 			LD	A, function
00067D 49 CF       0002*M1 			RST.LIS	08h
00067F 5B E5       0331*   			PUSH.LIL	HL
000681 5B FD E1    0332*   			POP.LIL		IY		; IYU: Pointer to FIL structure
000684 5B FD 6E 11 0333*   			LD.LIL		L, (IY + FIL.fptr + 0)
000688 5B FD 66 12 0334*   			LD.LIL		H, (IY + FIL.fptr + 1)
00068C 5B FD 5E 13 0335*   			LD.LIL		E, (IY + FIL.fptr + 2)
000690 5B FD 56 14 0336*   			LD.LIL		D, (IY + FIL.fptr + 3)
000694 FD E1       0337*   			POP		IY
000696 C9          0338*   			RET
000697             0339*   
000697             0340*   ; PUTPTR - Update file pointer.
000697             0341*   ;    A = file channel
000697             0342*   ; DEHL = new pointer (0-&7FFFFF)
000697             0343*   ; Destroys: A,B,C,D,E,H,L,F
000697             0344*   ;
000697 FD E5       0345*   PUTPTR:			PUSH		IY
000699 4F          0346*   			LD		C, A  		; C: Filehandle
00069A 5B E5       0347*   			PUSH.LIL	HL
00069C 5B 21 02 00 0348*   			LD.LIL		HL, 2
       00          
0006A1 5B 39       0349*   			ADD.LIL		HL, SP
0006A3 5B 73       0350*   			LD.LIL		(HL), E 	; 3rd byte of DWORD set to E
0006A5 5B E1       0351*   			POP.LIL		HL
0006A7 5A          0352*   			LD		E, D  		; 4th byte passed as E
0006A8             0353*   			MOSCALL		mos_flseek
0006A8 3E 1C       0001*M1 			LD	A, function
0006AA 49 CF       0002*M1 			RST.LIS	08h
0006AC FD E1       0354*   			POP		IY
0006AE C9          0355*   			RET
0006AF             0356*   
0006AF             0357*   ; GETEXT - Find file size.
0006AF             0358*   ;    E = file channel
0006AF             0359*   ; Returns:
0006AF             0360*   ; DEHL = file size (0-&800000)
0006AF             0361*   ; Destroys: A,B,C,D,E,H,L,F
0006AF             0362*   ;
0006AF FD E5       0363*   GETEXT:			PUSH		IY
0006B1 4B          0364*   			LD		C, E
0006B2             0365*   			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0006B2 3E 19       0001*M1 			LD	A, function
0006B4 49 CF       0002*M1 			RST.LIS	08h
0006B6 5B E5       0366*   			PUSH.LIL	HL
0006B8 5B FD E1    0367*   			POP.LIL		IY		; IYU: Pointer to FIL structure
0006BB 5B FD 6E 24 0368*   			LD.LIL		L, (IY + FIL.obj.objsize + 0)
0006BF 5B FD 66 25 0369*   			LD.LIL		H, (IY + FIL.obj.objsize + 1)
0006C3 5B FD 5E 26 0370*   			LD.LIL		E, (IY + FIL.obj.objsize + 2)
0006C7 5B FD 56 27 0371*   			LD.LIL		D, (IY + FIL.obj.objsize + 3)
0006CB FD E1       0372*   			POP		IY
0006CD C9          0373*   			RET
0006CE             0374*   
0006CE             0375*   ;OSLOAD - Load an area of memory from a file.
0006CE             0376*   ;   Inputs: HL addresses filename (CR terminated)
0006CE             0377*   ;           DE = address at which to load
0006CE             0378*   ;           BC = maximum allowed size (bytes)
0006CE             0379*   ;  Outputs: Carry reset indicates no room for file.
0006CE             0380*   ; Destroys: A,B,C,D,E,H,L,F
0006CE             0381*   ;
0006CE C5          0382*   OSLOAD:			PUSH	BC			; Stack the size
0006CF D5          0383*   			PUSH	DE			; Stack the load address
0006D0 11 00 52    0384*   			LD	DE, ACCS		; Buffer address for filename
0006D3 CD 3D 05    0385*   			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0006D6 21 00 52    0386*   			LD	HL, ACCS		; HL: Filename
0006D9 CD 17 08    0387*   			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0006DC CD 28 08    0388*   			CALL	EXT_HANDLER		; Get the default handler
0006DF D1          0389*   			POP	DE			; Restore the load address
0006E0 C1          0390*   			POP	BC			; Restore the size
0006E1 B7          0391*   			OR	A
0006E2 CA A9 07    0392*   			JP 	Z, OSLOAD_BBC
0006E5             0393*   ;
0006E5             0394*   ; Load the file in as a text file
0006E5             0395*   ;
0006E5 AF          0396*   OSLOAD_TXT:		XOR	A			; Set file attributes to read
0006E6 CD 46 06    0397*   			CALL	OSOPEN			; Open the file
0006E9 5F          0398*   			LD 	E, A 			; The filehandle
0006EA B7          0399*   			OR	A
0006EB 3E 04       0400*   			LD	A, 4			; File not found error
0006ED CA B1 07    0401*   			JP	Z, OSERROR		; Jump to error handler
0006F0 CD C1 40    0402*   			CALL	NEWIT			; Call NEW to clear the program space
0006F3             0403*   ;
0006F3 21 00 52    0404*   OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0006F6             0405*   ;
0006F6             0406*   ; First skip any whitespace (indents) at the beginning of the input
0006F6             0407*   ;
0006F6 CD 5D 06    0408*   @@:			CALL	OSBGET			; Read the byte into A
0006F9 38 1C       0409*   			JR	C, OSLOAD_TXT3		; Is it EOF?
0006FB FE 0A       0410*   			CP	LF 			; Is it LF?
0006FD 28 18       0411*   			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0006FF FE 21       0412*   			CP	21h			; Is it less than or equal to ASCII space?
000701 38 F3       0413*   			JR	C, @B 			; Yes, so keep looping
000703 77          0414*   			LD	(HL), A 		; Store the first character
000704 2C          0415*   			INC	L
000705             0416*   ;
000705             0417*   ; Now read the rest of the line in
000705             0418*   ;
000705 CD 5D 06    0419*   OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
000708 38 26       0420*   			JR	C, OSLOAD_TXT4		; Is it EOF?
00070A FE 20       0421*   			CP	20h			; Skip if not an ASCII character
00070C 38 05       0422*   			JR	C, @F
00070E 77          0423*   			LD	(HL), A 		; Store in the input buffer
00070F 2C          0424*   			INC	L			; Increment the buffer pointer
000710 CA 72 3F    0425*   			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
000713 FE 0A       0426*   @@:			CP	LF			; Check for LF
000715 20 EE       0427*   			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
000717             0428*   ;
000717             0429*   ; Finally, handle EOL/EOF
000717             0430*   ;
000717 36 0D       0431*   OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
000719 7D          0432*   			LD	A, L			; Check for minimum line length
00071A FE 02       0433*   			CP	2			; If it is 2 characters or less (including CR)
00071C 38 08       0434*   			JR	C, @F			; Then don't bother entering it
00071E D5          0435*   			PUSH	DE			; Preserve the filehandle
00071F CD 3B 07    0436*   			CALL	OSEDIT			; Enter the line in memory
000722 DC 9D 40    0437*   			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
000725 D1          0438*   			POP	DE
000726 CD 6E 06    0439*   @@:			CALL	OSSTAT			; End of file?
000729 20 C8       0440*   			JR	NZ, OSLOAD_TXT1		; No, so loop
00072B CD 55 06    0441*   			CALL	OSSHUT			; Close the file
00072E 37          0442*   			SCF				; Flag to BASIC that we're good
00072F C9          0443*   			RET
000730             0444*   ;
000730             0445*   ; Special case for BASIC programs with no blank line at the end
000730             0446*   ;
000730 FE 20       0447*   OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
000732 38 05       0448*   			JR	C, @F
000734 77          0449*   			LD	(HL), A			; Store the character
000735 2C          0450*   			INC	L
000736 CA 72 3F    0451*   			JP	Z, BAD
000739 18 DC       0452*   @@:			JR	OSLOAD_TXT3
00073B             0453*   ;
00073B             0454*   ; This bit enters the line into memory
00073B             0455*   ; Also called from OSLOAD_TXT
00073B             0456*   ; Returns:
00073B             0457*   ; F: C if a new line has been entered (CLEAN will need to be called)
00073B             0458*   ;
00073B AF          0459*   OSEDIT:			XOR	A			; Entry point after *EDIT
00073C 32 FB 54    0460*   			LD      (COUNT),A
00073F FD 21 00 52 0461*   			LD      IY,ACCS
000743 CD 0D 44    0462*   			CALL    LINNUM			; HL: The line number from the input buffer
000746 CD 8E 45    0463*   			CALL    NXT			; Skip spaces
000749 7C          0464*   			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
00074A B5          0465*   			OR      L
00074B 28 00       0466*   			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
00074D             0467*   ;
00074D             0468*   ; This bit does the lexical analysis and tokenisation
00074D             0469*   ;
00074D 11 00 53    0470*   LNZERO:			LD	DE,BUFFER
000750 0E 01       0471*                   	LD	C,1			; LEFT MODE
000752 E5          0472*                   	PUSH	HL
000753 CD 9B 44    0473*                   	CALL	LEXAN2			; LEXICAL ANALYSIS
000756 E1          0474*                   	POP	HL
000757 12          0475*                   	LD	(DE),A			; TERMINATOR
000758 AF          0476*                   	XOR	A
000759 47          0477*                   	LD	B,A
00075A 4B          0478*                   	LD	C,E			; BC=LINE LENGTH
00075B 13          0479*                   	INC	DE
00075C 12          0480*                   	LD	(DE),A			; ZERO NEXT
00075D 7C          0481*                   	LD	A,H
00075E B5          0482*                   	OR	L
00075F FD 21 00 53 0483*                   	LD	IY,BUFFER		; FOR XEQ
000763 CA 1C 25    0484*                   	JP	Z,XEQ			; DIRECT MODE
000766 C5          0485*                   	PUSH	BC
000767 CD C6 41    0486*                   	CALL	FINDL
00076A CC 6C 40    0487*                   	CALL	Z,DEL
00076D C1          0488*                   	POP	BC
00076E 79          0489*                   	LD	A,C
00076F B7          0490*                   	OR	A
000770 C8          0491*                   	RET	Z
000771 C6 04       0492*                   	ADD	A,4
000773 4F          0493*                   	LD	C,A			; LENGTH INCLUSIVE
000774 D5          0494*                   	PUSH	DE			; LINE NUMBER
000775 C5          0495*                   	PUSH	BC			; SAVE LINE LENGTH
000776 EB          0496*                   	EX	DE,HL
000777 C5          0497*                   	PUSH	BC
000778 CD A8 40    0498*                   	CALL	GETTOP
00077B C1          0499*                   	POP	BC
00077C E5          0500*                   	PUSH	HL
00077D 09          0501*                   	ADD	HL,BC
00077E E5          0502*                   	PUSH	HL
00077F 24          0503*                   	INC	H
000780 AF          0504*                   	XOR	A
000781 ED 72       0505*                   	SBC	HL,SP
000783 E1          0506*                   	POP	HL
000784 D2 C7 3F    0507*                   	JP	NC,ERROR_		; "No room"
000787 E3          0508*                   	EX	(SP),HL
000788 E5          0509*                   	PUSH	HL
000789 23          0510*                   	INC	HL
00078A B7          0511*                   	OR	A
00078B ED 52       0512*                   	SBC	HL,DE
00078D 44          0513*                   	LD	B,H			; BC=AMOUNT TO MOVE
00078E 4D          0514*                   	LD	C,L
00078F E1          0515*                   	POP	HL
000790 D1          0516*                   	POP	DE
000791 28 02       0517*                   	JR	Z,ATENDos
000793 ED B8       0518*                   	LDDR				; MAKE SPACE
000795 C1          0519*   ATENDos:          	POP	BC			; LINE LENGTH
000796 D1          0520*                   	POP	DE			; LINE NUMBER
000797 23          0521*                   	INC	HL
000798 71          0522*                   	LD	(HL),C			; STORE LENGTH
000799 23          0523*                   	INC	HL
00079A 73          0524*                   	LD	(HL),E			; STORE LINE NUMBER
00079B 23          0525*                   	INC	HL
00079C 72          0526*                   	LD	(HL),D
00079D 23          0527*                   	INC	HL
00079E 11 00 53    0528*                   	LD	DE,BUFFER
0007A1 EB          0529*                   	EX	DE,HL
0007A2 0D          0530*                   	DEC	C
0007A3 0D          0531*                   	DEC	C
0007A4 0D          0532*                   	DEC	C
0007A5 ED B0       0533*                   	LDIR				; ADD LINE
0007A7 37          0534*   			SCF
0007A8 C9          0535*   			RET
0007A9             0536*   ;
0007A9             0537*   ; Load the file in as a tokenised binary blob
0007A9             0538*   ;
0007A9             0539*   OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
0007A9 3E 01       0001*M1 			LD	A, function
0007AB 49 CF       0002*M1 			RST.LIS	08h
0007AD D0          0540*   			RET	NC			; If load returns with carry reset - NO ROOM
0007AE B7          0541*   			OR	A			; If there is no error (A=0)
0007AF 37          0542*   			SCF				; Need to set carry indicating there was room
0007B0 C8          0543*   			RET	Z			; Return
0007B1             0544*   ;
0007B1 F5          0545*   OSERROR:		PUSH	AF			; Handle the MOS error
0007B2 21 00 52    0546*   			LD	HL, ACCS		; Address of the buffer
0007B5 01 00 01    0547*   			LD	BC, 256			; Length of the buffer
0007B8 5F          0548*   			LD	E, A			; The error code
0007B9             0549*   			MOSCALL	mos_getError		; Copy the error message into the buffer
0007B9 3E 0F       0001*M1 			LD	A, function
0007BB 49 CF       0002*M1 			RST.LIS	08h
0007BD F1          0550*   			POP	AF
0007BE E5          0551*   			PUSH	HL			; Stack the address of the error (now in ACCS)
0007BF C6 7F       0552*   			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
0007C1 C3 D8 3F    0553*   			JP	EXTERR			; Trigger an external error
0007C4             0554*   
0007C4             0555*   ;OSSAVE - Save an area of memory to a file.
0007C4             0556*   ;   Inputs: HL addresses filename (term CR)
0007C4             0557*   ;           DE = start address of data to save
0007C4             0558*   ;           BC = length of data to save (bytes)
0007C4             0559*   ; Destroys: A,B,C,D,E,H,L,F
0007C4             0560*   ;
0007C4 C5          0561*   OSSAVE:			PUSH	BC			; Stack the size
0007C5 D5          0562*   			PUSH	DE			; Stack the save address
0007C6 11 00 52    0563*   			LD	DE, ACCS		; Buffer address for filename
0007C9 CD 3D 05    0564*   			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0007CC 21 00 52    0565*   			LD	HL, ACCS		; HL: Filename
0007CF CD 17 08    0566*   			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0007D2 CD 28 08    0567*   			CALL	EXT_HANDLER		; Get the default handler
0007D5 D1          0568*   			POP	DE			; Restore the save address
0007D6 C1          0569*   			POP	BC			; Restore the size
0007D7 B7          0570*   			OR	A			; Is the extension .BBC
0007D8 28 35       0571*   			JR	Z, OSSAVE_BBC		; Yes, so use that
0007DA             0572*   ;
0007DA             0573*   ; Save the file out as a text file
0007DA             0574*   ;
0007DA 3A 95 51    0575*   OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0007DD F5          0576*   			PUSH	AF
0007DE AF          0577*   			XOR	A
0007DF 3C          0578*   			INC	A			; Make sure C is clear, A is 1, for OPENOUT
0007E0 32 95 51    0579*   			LD	(OSWRCHCH), A
0007E3 CD 46 06    0580*   			CALL	OSOPEN			; Open the file
0007E6 32 96 51    0581*   			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0007E9 DD 21 FE 54 0582*   			LD	IX, LISTON		; Required for LISTIT
0007ED 2A DC 54    0583*   			LD	HL, (PAGE_)		; Get start of program area
0007F0 D9          0584*   			EXX
0007F1 01 00 00    0585*   			LD	BC, 0			; Set the initial indent counters
0007F4 D9          0586*   			EXX
0007F5 7E          0587*   OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0007F6 B7          0588*   			OR	A
0007F7 28 0A       0589*   			JR	Z, OSSAVE_TXT2
0007F9 23          0590*   			INC	HL			; Skip the length byte
0007FA 5E          0591*   			LD	E, (HL)			; Get the line number
0007FB 23          0592*   			INC	HL
0007FC 56          0593*   			LD	D, (HL)
0007FD 23          0594*   			INC	HL
0007FE CD E0 40    0595*   			CALL	LISTIT			; List the line
000801 18 F2       0596*   			JR	OSSAVE_TXT1
000803 3A 96 51    0597*   OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
000806 5F          0598*   			LD	E, A
000807 CD 55 06    0599*   			CALL	OSSHUT			; Close it
00080A F1          0600*   			POP	AF			; Restore the channel
00080B 32 95 51    0601*   			LD	(OSWRCHCH), A
00080E C9          0602*   			RET
00080F             0603*   ;
00080F             0604*   ; Save the file out as a tokenised binary blob
00080F             0605*   ;
00080F             0606*   OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
00080F 3E 02       0001*M1 			LD	A, function
000811 49 CF       0002*M1 			RST.LIS	08h
000813 B7          0607*   			OR	A			; If there is no error (A=0)
000814 C8          0608*   			RET	Z			; Just return
000815 18 9A       0609*   			JR	OSERROR			; Trip an error
000817             0610*   
000817             0611*   ; Check if an extension is specified in the filename
000817             0612*   ; Add a default if not specified
000817             0613*   ; HL: Filename (CSTR format)
000817             0614*   ;
000817 E5          0615*   EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
000818 0E 2E       0616*   			LD	C, '.'			; Search for dot (marks start of extension)
00081A CD 5D 05    0617*   			CALL	CSTR_FINDCH
00081D B7          0618*   			OR	A			; Check for end of string marker
00081E 20 06       0619*   			JR	NZ, @F			; No, so skip as we have an extension at this point
000820 11 54 08    0620*   			LD	DE, EXT_LOOKUP		; Get the first (default extension)
000823 CD 73 05    0621*   			CALL	CSTR_CAT		; Concat it to string pointed to by HL
000826 E1          0622*   @@:			POP	HL			; Restore the filename pointer
000827 C9          0623*   			RET
000828             0624*   
000828             0625*   ; Check if an extension is valid and, if so, provide a pointer to a handler
000828             0626*   ; HL: Filename (CSTR format)
000828             0627*   ; Returns:
000828             0628*   ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
000828             0629*   ;
000828 E5          0630*   EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
000829 0E 2E       0631*   			LD	C, '.'			; Find the '.'
00082B CD 5D 05    0632*   			CALL	CSTR_FINDCH
00082E 11 54 08    0633*   			LD	DE, EXT_LOOKUP		; The lookup table
000831             0634*   ;
000831 E5          0635*   EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
000832 CD 65 05    0636*   			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
000835 E1          0637*   			POP	HL			; Restore the pointer to the extension
000836 28 18       0638*   			JR	Z, EXT_HANDLER_2	; We have a match!
000838             0639*   ;
000838 1A          0640*   @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
000839 13          0641*   			INC	DE
00083A B7          0642*   			OR	A
00083B 20 FB       0643*   			JR	NZ, @B
00083D 13          0644*   			INC	DE			; Skip the file extension # byte
00083E             0645*   ;
00083E 1A          0646*   			LD	A, (DE)			; Are we at the end of the table?
00083F B7          0647*   			OR	A
000840 20 EF       0648*   			JR	NZ, EXT_HANDLER_1	; No, so loop
000842             0649*   ;
000842 3E CC       0650*   			LD      A,204			; Throw a "Bad name" error
000844 CD D8 3F    0651*           		CALL    EXTERR
000847 42 61 64 20 0652*           		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
000850             0653*   ;
000850 13          0654*   EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
000851 1A          0655*   			LD	A, (DE)
000852 E1          0656*   			POP	HL			; Restore the filename pointer
000853 C9          0657*   			RET
000854             0658*   
000854             0659*   ; Extension lookup table
000854             0660*   ; CSTR, TYPE
000854             0661*   ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
000854             0662*   ; 	- 1: Human readable plain text
000854             0663*   ;
000854 2E 42 42 43 0664*   EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
00085A 2E 54 58 54 0665*   			DB	".TXT", 0, 1
       00 01       
000860 2E 41 53 43 0666*   			DB	".ASC", 0, 1
       00 01       
000866 2E 42 41 53 0667*   			DB	".BAS", 0, 1
       00 01       
00086C 00          0668*   			DB	0			; End of table
00086D             0669*   ; OSWORD
00086D             0670*   ;
00086D FE 01       0671*   OSWORD:			CP	01H			; GETIME
00086F 28 1C       0672*   			JR	Z, OSWORD_01
000871 FE 02       0673*   			CP	02H			; PUTIME
000873 28 2E       0674*   			JR	Z, OSWORD_02
000875 FE 0E       0675*   			CP	0EH			; GETIMS
000877 28 4E       0676*   			JR	Z, OSWORD_0E
000879 FE 0F       0677*   			CP	0FH			; PUTIMS
00087B 28 0F       0678*   			JR	Z, @F
00087D FE 07       0679*   			CP	07H			; SOUND
00087F 28 A0       0680*   			JR	Z, OSWORD_07
